<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Autpwired]]></title>
    <url>%2F2019%2F01%2F01%2FSpring%2F6.%40Autowire%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Autowired]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Spring依赖注入的一些理解]]></title>
    <url>%2F2018%2F12%2F31%2FSpring%2F2.Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[问大家一个问题 Spring中注册的bean 在xml中配置 我看写的程序中没有调用 xxx.getBean(“xxx”)。那在程序中是如何使用这个bean的呢]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 千峰教育笔记]]></title>
    <url>%2F2018%2F12%2F25%2FRabbitMQ%2FRabbit%20MQ%2F</url>
    <content type="text"><![CDATA[1.RabbitMQ 简介 2.Rabbit MQ的安装 3.Rabbit MQ添加用户 4.Rabbit MQ使用教程 ⭐️4.1消息模式种类 4.2 pom&amp;log4j.properties123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qianfeng&lt;/groupId&gt; &lt;artifactId&gt;testrabbitmqdemo&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;testrabbitmqdemo&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt; &lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt; =====================amqp-clien========================== ============================ &lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;4.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.amqp/spring-rabbit􏴏􏴐 spring 􏰚􏲂􏱗,amqp 􏰪􏱚 rabbitmq 􏴑􏲅􏴒􏴓 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; ===================spring-rabbit========================= ============================ &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt; &lt;version&gt;1.7.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567log4j.rootLogger=DEBUG,A1log4j.logger.com.taotao = DEBUGlog4j.logger.org.mybatis = DEBUGlog4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c]-[%p] %m%n 4.3HelloWorld (生产者 消费者)123456789101112131415161718package com.rabbitmq;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * 用于创建连接的工具类 */public class ConnectionUtils &#123; public static Connection getConnection() throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost("94.191.24.33");//这个Host是ip地址 如果是Linux的就是Linux的ipconfig// 否则就是服务器的公网地址此处是腾讯云的公网ip地址 connectionFactory.setPort(5672);//5672是服务器的端口 15672是网页的端口 connectionFactory.setUsername("guest"); connectionFactory.setPassword("guest"); connectionFactory.setVirtualHost("/"); return connectionFactory.newConnection(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.rabbitmq;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;//生产者public class Sender &#123; private final static String QUEUEName = "RabbitmqName";//定义一个队列的名字 public static void main(String[] args) throws Exception &#123; //1。获取连接 Connection connection = ConnectionUtils.getConnection(); //2。创建通道 Channel channel = connection.createChannel(); //3。声明队列 /** * 如果队列存在则什么都不做 如果不存在才创建 * QUEUEName ： 参数1 队列的名字 * durable : 参数2 是否持久化队列 * &gt; 我们的队列模式是在内存中的 如果rabbitmq 重启 会丢失 * &gt; 如果设置为true ,则会保存到erlang自带的数据库中，重启后会重新读取 *exclusive: 参数3 是否排除 有两个作用 * &gt; 作用1： 第一个当我们的连接关闭后是否会自动删除队列 * &gt; 作用2：是否私有当前队列 如果私有了其他通道不可以访问当前对列 * &gt; 如果为true 一般是一个队列只适用于一个消费者的时候 *autodelete： 参数4：是否自动删除 * 参数5：一切其他参数 */ channel.queueDeclare(QUEUEName, false, false, false, null); //4。发送内容 channel.basicPublish("", QUEUEName, null, "发送的消息".getBytes()); //5。关闭连接 connection.close(); channel.close(); &#125;&#125; 123456789101112131415161718192021222324252627package com.rabbitmq;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.QueueingConsumer;//消费者public class Recver &#123; private final static String QUEUEName = "RabbitmqName";//定义一个队列的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUEName, false, false, false, null); //定义一个消费者 QueueingConsumer consumer = new QueueingConsumer(channel); //接受参数 参数2是自动确认 channel.basicConsume(QUEUEName, true, consumer); while (true) &#123; //获取消息 //如果没有消息会等待 有的话就获取执行然后销毁是一次性的 QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String s = new String(delivery.getBody()); System.out.println(s); &#125; &#125;&#125; RabbitMQ连接工具]]></content>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ Exchange]]></title>
    <url>%2F2018%2F12%2F25%2FRabbitMQ%2F6.Exchange%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合]]></title>
    <url>%2F2018%2F12%2F23%2FSSM%20%2FSSM%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[新建SSM项目 ，关于IDEA的版本问题强烈建议使用旗舰版，有条件的就购买，没条件的嘛。。 天朝你懂的。在欢迎界面点击Create New Project。 之后选择Maven(新建JAVAEE项目是需要安装JDK的，这个就不在这里讲解了。 )选好之后点击下一步。之后填入GroupID和ArtifactID这里尽量按照Maven的命名规范来即可。之后点击下一步，填入项目名称，这里我建议和之前填写的ArtifactID名称一样即可。点击Finish完成项目的创建。之后尽量不要做其他操作，让IDEA完成索引创建。 完善目录结构首先观察一下IDEA给我们生成的目录结构，这是一个标准的Maven目录。 但是其中少了一个webapp目录用于存放jsp、css、js、图片之类的文件。 之后还需要完善我们的目录结构，如下图：以上的命名都是我们开发过程中常用的命名规则，不一定按照我这样来，但是最好是有一定的规范。 POM.xmlpom.xml是整个maven的核心配置文件，里面有对项目的描述和项目所需要的依赖。 哦对了，在修改pom.xml文件之前我们最好先设置一下该项目的Maven设置(IDEA对每个项目的maven设置和Eclipse不一样，不是设置一次就可了，如果今后还要新建项目那就还需要设置， 同时按住ctrl,alt,s是打开设置的快捷键，更多有关IDEA的操作今后会更新相关博文。 ) IDEA的Maven设置在Eclipse中用过Maven的都应该知道，这里是将项目的Maven换成我们自己安装的Maven，下面两个目录是选择Maven配置文件，不知道是什么原因在Eclipse 中选择了配置文件之后会自动的将Maven本地厂库的路径更改为你settings.xml中配置的路径。 既然这里没有自动选中那我们就手动修改即可，尽量不要放在C盘，一是用久之后本地厂库占用的空间会比较大，二是万一系统崩溃的话还有可能找回来。 修改pom.xml以下是我的pom.xml文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress MavenModelInspection --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.crossoverJie&lt;/groupId&gt; &lt;artifactId&gt;SSM&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;4.1.4.RELEASE&lt;/spring.version&gt; &lt;jackson.version&gt;2.5.0&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 使用SpringMVC需配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 关系型数据库整合时需配置 如hibernate jpa等 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql连接 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0-alpha-1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传文件 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; spring-mvc.xml这个配置文件是springMVC的配置文件：里面的我都写有注释，应该都能看懂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package=&quot;com.crossoverJie.controller&quot; /&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;!--&lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置拦截器 --&gt; &lt;!--&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &amp;lt;!&amp;ndash; &lt;mvc:mapping path=&quot;/**&quot;/&gt;拦截所有 &amp;ndash;&amp;gt; &lt;mvc:mapping path=&quot;/user/**&quot;/&gt; &lt;mvc:mapping path=&quot;/role/**&quot;/&gt; &lt;mvc:mapping path=&quot;/function/**&quot;/&gt; &lt;mvc:mapping path=&quot;/news/**&quot;/&gt; &lt;mvc:mapping path=&quot;/img/**&quot;/&gt; &lt;bean class=&quot;com.crossoverJie.intercept.Intercept&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;--&gt;&lt;/beans&gt; 关于上面拦截器注释掉的那里，配置是没有问题的，因为这是一个整合项目，所以里边也没有用到拦截器，为了防止运行报错所以就先注释掉了。 如果后续需要增加拦截器，可以参考这里的配置。 spring-mybatis.xml这个是spring和mybatis的整合配置文件，其中还有Druid连接池的配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;com.crossoverJie&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;!-- 指定连接数据库的驱动 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;3&quot; /&gt; &lt;property name=&quot;minIdle&quot; value=&quot;3&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &apos;x&apos;&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot; /&gt; &lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt; &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapping/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.crossoverJie.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 以上两个就是最重要的配置文件了，只要其中的包名和配置文件中的名字一样就不会出问题。关于xxMpper.xml以及实体类的生成，我们可以借助mybatis-generator自动生成工具来生成，方便快捷。 —- IDEA配置Tomcat关于Tomcat的下载与安装我这里就不多介绍了。按照下图选择：在name中为这个Tomcat输入一个名字。 之后选择你本地Tomcat的目录点击Ok即可。点击apply和保存之后就返回首页即可看到Tomcat的标识。根据需要点击Run和Debug即可运行。 运行结果如下：点击上图的2,3,4可看到不同用户的结果，如果你走到这一步，那么恭喜你整合成功。 Jdbc.properties12345jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3307/ssm?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password= mybatis-config.xml1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot; /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt; &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt; &lt;/settings&gt;&lt;/configuration&gt;]]></content>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM项目实战]]></title>
    <url>%2F2018%2F12%2F22%2FSSM%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[1.实体类解析与表的创建 $商品类别$： 1:商品类别的id 2:店铺id 3:商品类别的名称 4:商品类别的权重 5:商品创建时间 $详情图片：$ 1:详情图片的id 2.图片的地址 3.图片显示的权重 大靠前显示 4.创建时间 5.属于那个商品的详情图片（多对一）的关系]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot小D课堂]]></title>
    <url>%2F2018%2F12%2F22%2FSpringBoot%E5%B0%8FD%E8%AF%BE%E5%A0%82%2F</url>
    <content type="text"><![CDATA[1、零基础快速入门SpringBoot2.0 (5节课)1、SpringBoot2.x课程全套介绍和高手系列知识点​ 简介：介绍SpringBoot2.x课程大纲章节​ java基础，jdk环境，maven基础 2、SpringBoot2.x依赖环境和版本新特性说明简介：讲解新版本依赖环境和springboot2新特性概述 1、依赖版本jdk8以上, Springboot2.x用JDK8, 因为底层是 Spring framework5, 2、安装maven最新版本，maven3.2以上版本，下载地址 ：https://maven.apache.org/download.cgi 3、Eclipse或者IDE 4、新特性 5、翻译工具：https://translate.google.cn/ 6、springbootGitHub地址：https://github.com/spring-projects/spring-boot 7、springboot官方文档：https://spring.io/guides/gs/spring-boot/ ​ 3、快速创建SpringBoot2.x应用之手工创建web应用简介：使用Maven手工创建SpringBoot2.x应用 手工创建:https://projects.spring.io/spring-boot/#quick-start 官方推荐包命名接口，不要使用默认 defaultPackage 官方文档: https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-using-the-default-package 例子： com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java 4、快速创建SpringBoot2.x应用之工具类自动创建web应用简介：使用构建工具自动生成项目基本架构​ 1、工具自动创建:http://start.spring.io/ 5、SpringBoot2.x的依赖默认Maven版本​ 简介：讲解SpringBoot2.x的默认Maven依赖版本​ 1、官网地址​ https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#appendix-dependency-versions 2、SpringBoot接口Http协议开发实战 8节课1、SpringBoot2.xHTTP请求配置讲解 简介：SpringBoot2.xHTTP请求注解讲解和简化注解配置技巧 1、@RestController and @RequestMapping是springMVC的注解，不是springboot特有的 2、@RestController = @Controller+@ResponseBody 3、@SpringBootApplication = @Configuration+@EnableAutoConfiguration+@ComponentScan localhost:8080 2、开发接口必备工具之PostMan接口调试工具介绍和使用​ 简介：模拟Http接口测试工具PostMan安装和讲解 1、接口调试工具安装和基本使用 2、下载地址：https://www.getpostman.com/ ​ 3、SpringBoot基础HTTP接口GET请求实战​ 简介:讲解springboot接口，http的get请求，各个注解使用​ 1、GET请求​ 1、单一参数@RequestMapping(path = “/{id}”, method = RequestMethod.GET)​ 1) public String getUser(@PathVariable String id ) {}​​ 2）@RequestMapping(path = “/{depid}/{userid}”, method = RequestMethod.GET) 可以同时指定多个提交方法​ getUser(@PathVariable(“depid”) String departmentID,@PathVariable(“userid”) String userid)​​ 3）一个顶俩​ @GetMapping = @RequestMapping(method = RequestMethod.GET)​ @PostMapping = @RequestMapping(method = RequestMethod.POST)​ @PutMapping = @RequestMapping(method = RequestMethod.PUT)​ @DeleteMapping = @RequestMapping(method = RequestMethod.DELETE)​​ 4）@RequestParam(value = “name”, required = true)​ 可以设置默认值，比如分页​ 4)@RequestBody 请求体映射实体类 需要指定http头为 content-type为application/json charset=utf-8 5）@RequestHeader 请求头，比如鉴权 @RequestHeader(&quot;access_token&quot;) String accessToken 6）HttpServletRequest request自动注入获取参数 4、SpringBoot基础HTTP接口POST,PUT,DELETE请求实战​ 简介：讲解http请求post，put, delete提交方式 5、常用json框架介绍和Jackson返回结果处理​ 简介：介绍常用json框架和注解的使用，自定义返回json结构和格式 1、常用框架 阿里 fastjson,谷歌gson等 JavaBean序列化为Json，性能：Jackson &gt; FastJson &gt; Gson &gt; Json-lib 同个结构 Jackson、FastJson、Gson类库各有优点，各有自己的专长 空间换时间，时间换空间 2、jackson处理相关自动 指定字段不返回：@JsonIgnore 指定日期格式：@JsonFormat(pattern=&quot;yyyy-MM-dd hh:mm:ss&quot;,locale=&quot;zh&quot;,timezone=&quot;GMT+8&quot;) 空字段不返回：@JsonInclude(Include.NON_NUll) 指定别名：@JsonProperty 6、SpringBoot2.x目录文件结构讲解​ 简介：讲解SpringBoot目录文件结构和官方推荐的目录规范 1、目录讲解 src/main/java：存放代码 src/main/resources static: 存放静态文件，比如 css、js、image, （访问方式 http://localhost:8080/js/main.js） templates:存放静态页面jsp,html,tpl config:存放配置文件,application.properties resources: 2、引入依赖 Thymeleaf &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 注意：如果不引人这个依赖包，html文件应该放在默认加载文件夹里面， 比如resources、static、public这个几个文件夹，才可以访问 3、同个文件的加载顺序,静态资源文件 Spring Boot 默认会挨个从 META/resources &gt; resources &gt; static &gt; public 里面找是否存在相应的资源，如果有则直接返回。 4、默认配置 1）官网地址：https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content 2）spring.resources.static-locations = classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ 5、静态资源文件存储在CDN 7、SpringBoot2.x文件上传实战​ 简介：讲解HTML页面文件上传和后端处理实战​ 1、讲解springboot文件上传 MultipartFile file，源自SpringMVC​​ 1）静态页面直接访问：localhost:8080/index.html​ 注意点：​ 如果想要直接访问html页面，则需要把html放在springboot默认加载的文件夹下面​ 2）MultipartFile 对象的transferTo方法，用于文件保存（效率和操作比原先用FileOutStream方便和高效）​​ 访问路径 http://localhost:8080/images/39020dbb-9253-41b9-8ff9-403309ff3f19.jpeg ​ 8、jar包方式运行web项目的文件上传和访问处理（核心知识）​ 简介：讲解SpingBoot2.x使用 java -jar运行方式的图片上传和访问处理 1、文件大小配置，启动类里面配置 @Bean public MultipartConfigElement multipartConfigElement() { MultipartConfigFactory factory = new MultipartConfigFactory(); //单个文件最大 factory.setMaxFileSize(&quot;10240KB&quot;); //KB,MB /// 设置总上传数据总大小 factory.setMaxRequestSize(&quot;1024000KB&quot;); return factory.createMultipartConfig(); } 2、打包成jar包，需要增加maven依赖 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 如果没加相关依赖，执行maven打包，运行后会报错:no main manifest attribute, in XXX.jar GUI：反编译工具，作用就是用于把class文件转换成java文件 3、文件上传和访问需要指定磁盘路径 application.properties中增加下面配置 1) web.images-path=/Users/jack/Desktop 2) spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,classpath:/test/,file:${web.upload-path} 4、文件服务器：fastdfs，阿里云oss，nginx搭建一个简单的文件服务器 3.SpringBoot热部署devtool和配置文件自动注入实战 3节课1、SpringBoot2.x使用Dev-tool热部署​ 简介:介绍什么是热部署，使用springboot结合dev-tool工具，快速加载启动应用 官方地址：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools 核心依赖包： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 添加依赖后，在ide里面重启应用，后续修改后马上可以生效 classloader 不被热部署的文件 1、/META-INF/maven, /META-INF/resources, /resources, /static, /public, or /templates 2、指定文件不进行热部署 spring.devtools.restart.exclude=static/**,public/** 3、手工触发重启 spring.devtools.restart.trigger-file=trigger.txt 改代码不重启，通过一个文本去控制 https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools-restart-exclude 注意点：生产环境不要开启这个功能，如果用java -jar启动，springBoot是不会进行热部署的 2、SpringBoot2.x配置文件讲解​ 简介：SpringBoot2.x常见的配置文件 xml、yml、properties的区别和使用 xml、properties、json、yaml 1、常见的配置文件 xx.yml, xx.properties， 1)YAML（Yet Another Markup Language） 写 YAML 要比写 XML 快得多(无需关注标签或引号) 使用空格 Space 缩进表示分层，不同层次之间的缩进可以使用不同的空格数目 注意：key后面的冒号，后面一定要跟一个空格,树状结构 application.properties示例 server.port=8090 server.session-timeout=30 server.tomcat.max-threads=0 server.tomcat.uri-encoding=UTF-8 application.yml示例 server: port: 8090 session-timeout: 30 tomcat.max-threads: 0 tomcat.uri-encoding: UTF-8 2、默认示例文件仅作为指导。 不要将整个内容复制并粘贴到您的应用程序中，只挑选您需要的属性。 3、参考：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#common-application-properties 如果需要修改，直接复制对应的配置文件，加到application.properties里面 3、SpringBoot注解把配置文件自动映射到属性和实体类实战​ 简介：讲解使用@value注解配置文件自动映射到属性和实体类​​ 1、配置文件加载​ 方式一​ 1、Controller上面配置​ @PropertySource({“classpath:resource.properties”})​ 2、增加属性​ @Value(“${test.name}”)​ private String name;​​ 方式二：实体类配置文件​ 步骤：​ 1、添加 @Component 注解；​ 2、使用 @PropertySource 注解指定配置文件位置；​ 3、使用 @ConfigurationProperties 注解，设置相关属性；​​ 4、必须 通过注入IOC对象Resource 进来 ， 才能在类中使用获取的配置文件值。​ @Autowired​ private ServerSettings serverSettings;​ 例子： @Configuration @ConfigurationProperties(prefix=”test”) @PropertySource(value=”classpath:resource.properties”) public class ServerConstant { 常见问题： 1、配置文件注入失败，Could not resolve placeholder 解决：根据springboot启动流程，会有自动扫描包没有扫描到相关注解, 默认Spring框架实现会从声明@ComponentScan所在的类的package进行扫描，来自动注入， 因此启动类最好放在根路径下面，或者指定扫描包范围 spring-boot扫描启动类对应的目录和子目录 2、注入bean的方式，属性名称和配置文件里面的key一一对应，就用加@Value 这个注解 如果不一样，就要加@value(&quot;${XXX}&quot;) 4、Springboot2.0单元测试进阶实战和自定义异常处理. 5节课1、@SpringBootTest单元测试实战​ 简介：讲解SpringBoot的单元测试​ 1、引入相关依赖​ ​ ​ org.springframework.boot​ spring-boot-starter-test​ test​ 2、使用 @RunWith(SpringRunner.class) //底层用junit SpringJUnit4ClassRunner @SpringBootTest(classes={XdclassApplication.class})//启动整个springboot工程 public class SpringBootTests { } 2、SpringBoot测试进阶高级篇之MockMvc讲解​ 简介:讲解MockMvc类的使用和模拟Http请求实战 1、增加类注解 @AutoConfigureMockMvc @SpringBootTest(classes={XdclassApplication.class}) 2、相关API perform：执行一个RequestBuilder请求 andExpect：添加ResultMatcher-&gt;MockMvcResultMatchers验证规则 andReturn：最后返回相应的MvcResult-&gt;Response 3、SpringBoot2.x个性化启动banner设置和debug日志​ 简介：自定义应用启动的趣味性日志图标和查看调试日志 1、启动获取更多信息 java -jar xxx.jar --debug 2、修改启动的banner信息 1）在类路径下增加一个banner.txt，里面是启动要输出的信息 2）在applicatoin.properties增加banner文件的路径地址 spring.banner.location=banner.txt 3）官网地址 https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-banners 4、SpringBoot2.x配置全局异常实战​ 讲解：服务端异常讲解和SpringBoot配置全局异常实战 1、默认异常测试 int i = 1/0，不友好 2、异常注解介绍 @ControllerAdvice 如果是返回json数据 则用 RestControllerAdvice,就可以不加 @ResponseBody //捕获全局异常,处理所有不可知的异常 @ExceptionHandler(value=Exception.class) ​ 5、SpringBoot2.x配置全局异常返回自定义页面​ 简介：使用SpringBoot自定义异常和错误页面跳转实战 1、返回自定义异常界面，需要引入thymeleaf依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2、resource目录下新建templates,并新建error.html ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;error.html&quot;); modelAndView.addObject(&quot;msg&quot;, e.getMessage()); return modelAndView; https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-error-handling 5、SpringBoot部署war项目到tomcat9和启动原理讲解 2节课1、SpringBoot启动方式讲解和部署war项目到tomcat9简介：SpringBoot常见启动方式讲解和部署war项目Tomcat 1、ide启动 2、jar包方式启动 maven插件: &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 如果没有加，则执行jar包 ，报错如下 java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar no main manifest attribute, in spring-boot-demo-0.0.1-SNAPSHOT.jar 如果有安装maven 用 mvn spring-boot:run 项目结构 example.jar | +-META-INF | +-MANIFEST.MF +-org | +-springframework | +-boot | +-loader | +-&lt;spring boot loader classes&gt; +-BOOT-INF +-classes | +-mycompany | +-project | +-YourClasses.class +-lib +-dependency1.jar +-dependency2.jar 目录结构讲解 https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#executable-jar-jar-file-structure 3、war包方式启动 1)在pom.xml中将打包形式 jar 修改为war &lt;packaging&gt;war&lt;/packaging&gt; 构建项目名称 &lt;finalName&gt;xdclass_springboot&lt;/finalName&gt; 2)tocmat下载 https://tomcat.apache.org/download-90.cgi 3)修改启动类 public class XdclassApplication extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { return application.sources(XdclassApplication.class); } public static void main(String[] args) throws Exception { SpringApplication.run(XdclassApplication.class, args); } } 4)打包项目，启动tomcat 4、启动容器介绍和第三方测试数据讲解 使用Jmter测试工具测试性能，QPS,TPS，RT https://examples.javacodegeeks.com/enterprise-java/spring/tomcat-vs-jetty-vs-undertow-comparison-of-spring-boot-embedded-servlet-containers/ 2、SpringBoot2.x启动原理概述​ 简介：讲解SpringBoot启动流程概述和基本加载案例 6、SpringBoot拦截器实战和 Servlet3.0自定义Filter、Listener 4节课加入小D课堂技术交流答疑群：Q群：699347262 1、深入SpringBoot2.x过滤器Filter和使用Servlet3.0配置自定义Filter实战(核心知识)​ 简介:讲解SpringBoot里面Filter讲解和使用Servlet3.0配置自定义Filter实战​​ filter简单理解：人—&gt;检票员（filter）—&gt; 景点​​ 1、SpringBoot启动默认加载的Filter​ characterEncodingFilter​ hiddenHttpMethodFilter​ httpPutFormContentFilter​ requestContextFilter​​ 2、Filter优先级​ Ordered.HIGHEST_PRECEDENCE Ordered.LOWEST_PRECEDENCE 低位值意味着更高的优先级 Higher values are interpreted as lower priority 自定义Filter，避免和默认的Filter优先级一样，不然会冲突 注册Filter的bean FilterRegistrationBean 同模块里面有相关默认Filter web-&gt;servlet-&gt;filter 3、自定义Filter 1）使用Servlet3.0的注解进行配置 2）启动类里面增加 @ServletComponentScan，进行扫描 3）新建一个Filter类，implements Filter，并实现对应的接口 4) @WebFilter 标记一个类为filter，被spring进行扫描 urlPatterns：拦截规则，支持正则 6）控制chain.doFilter的方法的调用，来实现是否通过放行 不放行，web应用resp.sendRedirect(&quot;/index.html&quot;); 场景：权限控制、用户登录(非前端后端分离场景)等 1、官网地址：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-embedded-container-servlets-filters-listeners 2、Servlet3.0的注解自定义原生Servlet实战​ 讲解：使用 Servlet3.0的注解自定义原生Servlet和Listener​ 1、自定义原生Servlet @WebServlet(name = &quot;userServlet&quot;,urlPatterns = &quot;/test/customs&quot;) public class UserServlet extends HttpServlet{ @Override public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().print(&quot;custom sevlet&quot;); resp.getWriter().flush(); resp.getWriter().close(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 3、Servlet3.0的注解自定义原生Listener监听器实战​ 简介：监听器介绍和Servlet3.0的注解自定义原生Listener监听器实战 1、自定义Listener(常用的监听器 servletContextListener、httpSessionListener、servletRequestListener) @WebListener public class RequestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { // TODO Auto-generated method stub System.out.println(&quot;======requestDestroyed========&quot;); } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(&quot;======requestInitialized========&quot;); } 4、SpringBoot2.X自定义拦截器实战及新旧配置对比(核心知识)​ 简介: 讲解拦截器使用，Spingboot2.x新版本配置拦截拦截器和旧版本SpringBoot配置拦截器区别讲解​​ 1、@Configuration​ 继承WebMvcConfigurationAdapter(SpringBoot2.X之前旧版本)​​ SpringBoot2.X 新版本配置拦截器 implements WebMvcConfigurer​​ 2、自定义拦截器 HandlerInterceptor​ preHandle：调用Controller某个方法之前​ postHandle：Controller之后调用，视图渲染之前，如果控制器Controller出现了异常，则不会执行此方法​ afterCompletion：不管有没有异常，这个afterCompletion都会被调用，用于资源清理​ 3、按照注册顺序进行拦截，先注册，先被拦截 拦截器不生效常见问题： 1）是否有加@Configuration 2）拦截路径是否有问题 ** 和 * 3）拦截器最后路径一定要 “/**”， 如果是目录的话则是 /*/ Filter 是基于函数回调 doFilter()，而Interceptor则是基于AOP思想 Filter在只在Servlet前后起作用，而Interceptor够深入到方法前后、异常抛出前后等 依赖于Servlet容器即web应用中，而Interceptor不依赖于Servlet容器所以可以运行在多种环境。 在接口调用的生命周期里，Interceptor可以被多次调用，而Filter只能在容器初始化时调用一次。 Filter和Interceptor的执行顺序 过滤前-&gt;拦截前-&gt;action执行-&gt;拦截后-&gt;过滤后 7 SpringBoot常用Starter介绍和整合模板引擎Freemaker、thymeleaf 4节课1、SpringBoot Starter讲解​ 简介：介绍什么是SpringBoot Starter和主要作用 1、官网地址：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-starter 2、starter主要简化依赖用的 spring-boot-starter-web -&gt;里面包含多种依赖 3、几个常用的starter spring-boot-starter-activemq spring-boot-starter-aop spring-boot-starter-data-redis spring-boot-starter-freemarker spring-boot-starter-thymeleaf spring-boot-starter-webflux ​ 2、SpringBoot2.x常见模板引擎讲解和官方推荐使用​ 简介：介绍常用的SpringBoot2.x模板引擎和官方推荐案例 1、JSP（后端渲染，消耗性能） Java Server Pages 动态网页技术,由应用服务器中的JSP引擎来编译和执行，再将生成的整个页面返回给客户端 可以写java代码 持表达式语言（el、jstl） 内建函数 JSP-&gt;Servlet(占用JVM内存)permSize javaweb官方推荐 springboot不推荐 https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-jsp-limitations 2、Freemarker FreeMarker Template Language（FTL） 文件一般保存为 xxx.ftl 严格依赖MVC模式，不依赖Servlet容器（不占用JVM内存） 内建函数 3、Thymeleaf (主推) 轻量级的模板引擎（负责逻辑业务的不推荐，解析DOM或者XML会占用多的内存） 可以直接在浏览器中打开且正确显示模板页面 直接是html结尾，直接编辑 xdlcass.net/user/userinfo.html 社会工程学 伪装 3、SpringBoot2.x整合模板引擎freemarker实战​ 简介：SpringBoot2.x整合模板引擎freemarker实战 1、Freemarker相关maven依赖 &lt;!-- 引入freemarker模板引擎的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; 2、Freemarker基础配置 # 是否开启thymeleaf缓存,本地为false，生产建议为true spring.freemarker.cache=false spring.freemarker.charset=UTF-8 spring.freemarker.allow-request-override=false spring.freemarker.check-template-location=true #类型 spring.freemarker.content-type=text/html spring.freemarker.expose-request-attributes=true spring.freemarker.expose-session-attributes=true #文件后缀 spring.freemarker.suffix=.ftl #路径 spring.freemarker.template-loader-path=classpath:/templates/ 3、建立文件夹 1)src/main/resources/templates/fm/user/ 2)建立一个index.ftl 3)user文件夹下面建立一个user.html 4、简单测试代码编写和访问 4、SpringBoot2.x整合模板引擎thymeleaf实战​ 讲解：SpringBoot2.x整合模板引擎thymeleaf实战 官网地址：https://www.thymeleaf.org/doc/articles/thymeleaf3migration.html 1、thymeleaf相关maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2、thymeleaf基础配置 #开发时关闭缓存,不然没法看到实时页面 spring.thymeleaf.cache=false spring.thymeleaf.mode=HTML5 #前缀 spring.thymeleaf.prefix=classpath:/templates/ #编码 spring.thymeleaf.encoding=UTF-8 #类型 spring.thymeleaf.content-type=text/html #名称的后缀 spring.thymeleaf.suffix=.html 3、建立文件夹 1)src/main/resources/templates/tl/ 2)建立一个index.html 4、简单测试代码编写和访问 注意：$表达式只能写在th标签内部 快速入门：https://www.thymeleaf.org/doc/articles/standarddialect5minutes.html 8 数据库操作之整合Mybaties和事务讲解 5节课1、SpringBoot2.x持久化数据方式介绍​​ 简介：介绍近几年常用的访问数据库的方式和优缺点​​ 1、原始java访问数据库​ 开发流程麻烦​ 1、注册驱动/加载驱动​ Class.forName(“com.mysql.jdbc.Driver”)​ 2、建立连接​ Connection con = DriverManager.getConnection(“jdbc:mysql://localhost:3306/dbname”,”root”,”root”);​ 3、创建Statement​​ 4、执行SQL语句​ 5、处理结果集 6、关闭连接，释放资源 2、apache dbutils框架 比上一步简单点 官网:https://commons.apache.org/proper/commons-dbutils/ 3、jpa框架 spring-data-jpa jpa在复杂查询的时候性能不是很好 4、Hiberante 解释：ORM：对象关系映射Object Relational Mapping 企业大都喜欢使用hibernate 5、Mybatis框架 互联网行业通常使用mybatis 不提供对象和关系模型的直接映射,半ORM 2、SpringBoot2.x整合Mybatis3.x注解实战​ 简介：SpringBoot2.x整合Mybatis3.x注解配置实战 1、使用starter, maven仓库地址：http://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter 2、加入依赖(可以用 http://start.spring.io/ 下载) &lt;!-- 引入starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL的JDBC驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 引入第三方数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; 3、加入配置文件 #mybatis.type-aliases-package=net.xdclass.base_project.domain #可以自动识别 #spring.datasource.driver-class-name =com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/movie?useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.username =root spring.datasource.password =password #如果不使用默认的数据源 （com.zaxxer.hikari.HikariDataSource） spring.datasource.type =com.alibaba.druid.pool.DruidDataSource 加载配置，注入到sqlSessionFactory等都是springBoot帮我们完成 4、启动类增加mapper扫描 @MapperScan(&quot;net.xdclass.base_project.mapper&quot;) 技巧：保存对象，获取数据库自增id @Options(useGeneratedKeys=true, keyProperty=&quot;id&quot;, keyColumn=&quot;id&quot;) 4、开发mapper 参考语法 http://www.mybatis.org/mybatis-3/zh/java-api.html 5、sql脚本 CREATE TABLE `user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(128) DEFAULT NULL COMMENT &apos;名称&apos;, `phone` varchar(16) DEFAULT NULL COMMENT &apos;用户手机号&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;创建时间&apos;, `age` int(4) DEFAULT NULL COMMENT &apos;年龄&apos;, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8; 相关资料： http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/#Configuration https://github.com/mybatis/spring-boot-starter/tree/master/mybatis-spring-boot-samples 整合问题集合： https://my.oschina.net/hxflar1314520/blog/1800035 https://blog.csdn.net/tingxuetage/article/details/80179772 3、SpringBoot2.x整合Mybatis3.x增删改查实操和控制台打印SQL语句​ 讲解:SpringBoot2.x整合Mybatis3.x增删改查实操, 控制台打印sql语句​​ 1、控制台打印sql语句​ #增加打印sql语句，一般用于本地开发测试​ mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl​​ 2、增加mapper代码​ @Select(“SELECT FROM user”)​ @Results({​ @Result(column = “create_time”,property = “createTime”) //javaType = java.util.Date.class​ })​ List getAll();​​ @Select(“SELECT FROM user WHERE id = #{id}”)​ @Results({​ @Result(column = “create_time”,property = “createTime”)​ })​ User findById(Long id);​ @Update(“UPDATE user SET name=#{name} WHERE id =#{id}”) void update(User user); @Delete(&quot;DELETE FROM user WHERE id =#{userId}&quot;) void delete(Long userId); 3、增加API @GetMapping(&quot;find_all&quot;) public Object findAll(){ return JsonData.buildSuccess(userMapper.getAll()); } @GetMapping(&quot;find_by_Id&quot;) public Object findById(long id){ return JsonData.buildSuccess(userMapper.findById(id)); } @GetMapping(&quot;del_by_id&quot;) public Object delById(long id){ userMapper.delete(id); return JsonData.buildSuccess(); } @GetMapping(&quot;update&quot;) public Object update(String name,int id){ User user = new User(); user.setName(name); user.setId(id); userMapper.update(user); return JsonData.buildSuccess(); } 4、事务介绍和常见的隔离级别，传播行为​​ 简介：讲解什么是数据库事务，常见的隔离级别和传播行为​​ 1、介绍什么是事务，单机事务，分布式事务处理等​​ 2、讲解场景的隔离级别​ Serializable： 最严格，串行处理，消耗资源大​ Repeatable Read：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据​ Read Committed：大多数主流数据库的默认事务等级​ Read Uncommitted：保证了读取过程中不会读取到非法数据。 3、讲解常见的传播行为 PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务,最常见的选择。 PROPAGATION_SUPPORTS--支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY--支持当前事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW--新建事务，如果当前存在事务，把当前事务挂起, 两个事务之间没有关系，一个异常，一个提交，不会同时回滚 PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER--以非事务方式执行，如果当前存在事务，则抛出异常 5、SpringBoot整合mybatis之事务处理实战​ 简介：SpringBoot整合Mybatis之事务处理实战​ 1、service逻辑引入事务 @Transantional(propagation=Propagation.REQUIRED) 2、service代码 @Override @Transactional public int addAccount() { User user = new User(); user.setAge(9); user.setCreateTime(new Date()); user.setName(&quot;事务测试&quot;); user.setPhone(&quot;000121212&quot;); userMapper.insert(user); int a = 1/0; return user.getId(); } 9 SpringBoot2.x整合Redis实战 4节课​ 1、分布式缓存Redis介绍​ 简介:讲解为什么要用缓存和介绍什么是Redis，新手练习工具​​ 1、redis官网 https://redis.io/download​​ 2、新手入门redis在线测试工具：http://try.redis.io/ 2、源码编译安装Redis4.x​ 简介：使用源码安装Redis4.x和配置外网访问 1、快速安装 https://redis.io/download#installation wget http://download.redis.io/releases/redis-4.0.9.tar.gz tar xzf redis-4.0.9.tar.gz cd redis-4.0.9 make 启动服务端：src/redis-server 启动客户端：src/redis-cli 2、默认是本地访问的，需要开放外网访问 1）打开redis.conf文件在NETWORK部分修改 注释掉bind 127.0.0.1可以使所有的ip访问redis 修改 protected-mode，值改为no 3、SpringBoot2.x整合redis实战讲解 简介：使用springboot-starter整合reids实战 1、官网：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-redis 集群文档：https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#cluster 2、springboot整合redis相关依赖引入 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 3、相关配置文件配置 #=========redis基础配置========= spring.redis.database=0 spring.redis.host=127.0.0.1 spring.redis.port=6390 # 连接超时时间 单位 ms（毫秒） spring.redis.timeout=3000 #=========redis线程池设置========= # 连接池中的最大空闲连接，默认值也是8。 spring.redis.pool.max-idle=200 #连接池中的最小空闲连接，默认值也是0。 spring.redis.pool.min-idle=200 # 如果赋值为-1，则表示不限制；pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。 spring.redis.pool.max-active=2000 # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时 spring.redis.pool.max-wait=1000 4、常见redistemplate种类讲解和缓存实操(使用自动注入) 1、注入模板 @Autowired private StirngRedisTemplate strTplRedis 2、类型String，List,Hash,Set,ZSet 对应的方法分别是opsForValue()、opsForList()、opsForHash()、opsForSet()、opsForZSet() 4、Redis工具类封装讲解和实战​ 简介：高效开发方式 Redis工具类封装讲解和实战​ 1、常用客户端 https://redisdesktop.com/download​ 2、封装redis工具类并操作 10 SpringBoot整合定时任务和异步任务处理 3节课加入小D课堂技术交流答疑群：Q群：699347262 1、SpringBoot定时任务schedule讲解​ 简介：讲解什么是定时任务和常见定时任务区别 1、常见定时任务 Java自带的java.util.Timer类 timer:配置比较麻烦，时间延后问题 timertask:不推荐 2、Quartz框架 配置更简单 xml或者注解 3、SpringBoot使用注解方式开启定时任务 1）启动类里面 @EnableScheduling开启定时任务，自动扫描 2）定时任务业务类 加注解 @Component被容器扫描 3）定时执行的方法加上注解 @Scheduled(fixedRate=2000) 定期执行一次 2、SpringBoot常用定时任务配置实战​ 简介：SpringBoot常用定时任务表达式配置和在线生成器 1、cron 定时任务表达式 @Scheduled(cron=&quot;*/1 * * * * *&quot;) 表示每秒 1）crontab 工具 https://tool.lu/crontab/ 2、fixedRate: 定时多久执行一次（上一次开始执行时间点后xx秒再次执行；） 3、fixedDelay: 上一次执行结束时间点后xx秒再次执行 4、fixedDelayString: 字符串形式，可以通过配置文件指定 3、SpringBoot2.x异步任务实战（核心知识）​ 简介：讲解什么是异步任务，和使用SpringBoot2.x开发异步任务实战​ 1、什么是异步任务和使用场景：适用于处理log、发送邮件、短信……等​ 下单接口-&gt;查库存 100​ 余额校验 150​ 风控用户100​ …. 2、启动类里面使用@EnableAsync注解开启功能，自动扫描 3、定义异步任务类并使用@Component标记组件被容器扫描,异步方法加上@Async 注意点： 1）要把异步任务封装到类里面，不能直接写到Controller 2）增加Future&lt;String&gt; 返回结果 AsyncResult&lt;String&gt;(&quot;task执行完成&quot;); 3）如果需要拿到结果 需要判断全部的 task.isDone() 4、通过注入方式，注入到controller里面，如果测试前后区别则改为同步则把Async注释掉 11 Logback日志框架介绍和SpringBoot整合实战 2节课加入小D课堂技术交流答疑群：Q群：699347262 1、新日志框架LogBack介绍​ 简介：日志介绍和新日志框架Logback讲解 1.常用处理java的日志组件 slf4j,log4j,logback,common-logging 等 2、logback介绍：基于Log4j基础上大量改良，不能单独使用，推荐配合日志框架SLF4J来使用 logback当前分成三个模块：logback-core,logback-classic和logback-access; logback-core是其它两个模块的基础模块 3、Logback的核心对象： Logger：日志记录器 Appender：指定日志输出的目的地，目的地可以是控制台，文件 Layout：日志布局 格式化日志信息的输出 ​​ 4、日志级别：DEBUG &lt; INFO &lt; WARN &lt; ERROR​​ ===========log4j示例===========​ ### 设置###​ log4j.rootLogger = debug,stdout,D,E​​ ### 输出信息到控制抬 ###​ log4j.appender.stdout = org.apache.log4j.ConsoleAppender​ log4j.appender.stdout.Target = System.out​ log4j.appender.stdout.layout = org.apache.log4j.PatternLayout​ log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n​ ### 输出DEBUG 级别以上的日志到=D://logs/error.log ### log4j.appender.D = org.apache.log4j.DailyRollingFileAppender log4j.appender.D.File = D://logs/log.log log4j.appender.D.Append = true log4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayout log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [ %t:%r ] - [ %p ] %m%n ### 输出ERROR 级别以上的日志到=D://logs/error.log ### log4j.appender.E = org.apache.log4j.DailyRollingFileAppender log4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = true log4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayout log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [ %t:%r ] - [ %p ] %m%n ===========logback============ 4、Log4j日志转换为logback在线工具（支持log4j.properties转换为logback.xml,不支持 log4j.xml转换为logback.xml） https://logback.qos.ch/translator/ 2、SpringBoot2.x日志讲解和自定义Logback配置实战​ 简介：讲解SpringBoot2.x整合Logback配置实战 1、官网介绍：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-logging 各个组件案例：https://logback.qos.ch/manual/index.html 2、分析SpringBoot启动日志 1）默认情况下，Spring Boot将日志输出到控制台 3、整合Logback实战 1）创建 日志文件logback-spring.xml，官方推荐 -spring.xml结尾 默认加载加载配置顺序 logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy 注释： &lt;configuration&gt; 子节点 &lt;appender&gt;&lt;/appender&gt; &lt;logger&gt;&lt;/logger&gt; &lt;root&gt;&lt;/root&gt;(要加在最后) 12章 搜索框架ElasticSearch介绍和整合SpringBoot 4节课1、搜索引擎知识和搜索框架elasticsearch基本介绍​ 简介：通过京东电商 介绍什么是搜索引擎，和开源搜索框架ElasticSearch6.x新特性介绍 前言：介绍ES的主要特点和使用场景，新特性讲解 mysql：like 模糊，性能问题, solr:针对企业，Lucene elasticsearch：针对数据量特别大，PB,TB 纯java开发，springboot使用，5.6版本 es升级4-&gt;5版本，改动大，但是5版本后，改动不大 elasticSearch主要特点 1、特点：全文检索，结构化检索，数据统计、分析，接近实时处理，分布式搜索(可部署数百台服务器)，处理PB级别的数据 搜索纠错，自动完成 2、使用场景：日志搜索，数据聚合，数据监控，报表统计分析 3、国内外使用者：维基百科，Stack Overflow，GitHub 新特性讲解 1、6.2.x版本基于Lucene 7.x，更快，性能进一步提升,对应的序列化组件，升级到Jackson 2.8 mysql：database table rocord es : index type（只能存在一个) document 2、推荐使用5.0版本推出的Java REST/HTTP客户端，依赖少，比Transport使用更方便，在基准测试中，性能并不输于Transport客户端， 在5.0到6.0版本中，每次有对应的API更新, 文档中也说明，推荐使用这种方式进行开发使用,所有可用节点间的负载均衡 在节点故障和特定响应代码的情况下进行故障转移,失败的连接处罚（失败的节点是否重试取决于失败的连续次数;失败的失败次数越多，客户端在再次尝试同一节点之前等待的时间越长） 3、(重要)不再支持一个索引库里面多个type，6.x版本已经禁止一个index里面多个type，所以一个index索引库只能存在1个type 官方文档： 1、6.0更新特性 https://www.elastic.co/guide/en/elasticsearch/reference/6.0/release-notes-6.0.0.html#breaking-java-6.0.0 2、6.1更新特性 https://www.elastic.co/guide/en/elasticsearch/reference/6.1/release-notes-6.1.0.html 2、快熟部署ElastcSearch5.6.x​ 简介：讲解为什么不用ES6.x版本，及本地快速安装ElasticSeach和场景问题处理​​ 配置JDK1.8​ 使用wget 下载elasticsearch安装包​ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.8.tar.gz​ 解压​ tar -zxvf elasticsearch-5.6.8.tar.gz​ 官网：https://www.elastic.co/products/elasticsearch​​ 外网访问配置：​ config目录下面elasticsearch.yml​ 修改为 network.host: 0.0.0.0 配置es出现相关问题处理（阿里云、腾讯云，亚马逊云安装问题集合）： 1、问题一 Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c5330000, 986513408, 0) failed; error=&apos;Cannot allocate memory&apos; (errno=12) # # There is insufficient memory for the Java Runtime Environment to continue. # Native memory allocation (mmap) failed to map 986513408 bytes for committing reserved memory. # An error report file with more information is saved as: # /usr/local/software/temp/elasticsearch-6.2.2/hs_err_pid1912.log 解决：内存不够，购买阿里云的机器可以动态增加内存 2、问题二 [root@iZwz95j86y235aroi85ht0Z bin]# ./elasticsearch [2018-02-22T20:14:04,870][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [] uncaught exception in thread [main] org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:125) ~[elasticsearch-6.2.2.jar:6.2.2] at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:112) ~[elasticsearch-6.2.2.jar:6.2.2] at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-6.2.2.jar:6.2.2] at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) ~[elasticsearch-cli-6.2.2.jar:6.2.2] 解决：用非root用户 添加用户：useradd -m 用户名 然后设置密码 passwd 用户名 3、问题三 ./elasticsearch Exception in thread &quot;main&quot; java.nio.file.AccessDeniedException: /usr/local/software/temp/elasticsearch-6.2.2/config/jvm.options 解决：权限不够 chmod 777 -R 当前es目录 常见配置问题资料：https://www.jianshu.com/p/c5d6ec0f35e0 3、ElasticSearch5.6.8测试数据准备​ 简介: ElasticSearch5.6.x简单测试​ 1、步骤 https://www.elastic.co/guide/en/elasticsearch/reference/5.6/index.html​ 2、使用POSTMAN 工具 基础 查看集群状态：localhost:9200/_cat/health?v 查看索引列表：localhost:9200/_cat/indices?v 4、SpringBoot2.x整合elasticsearch5.6.x​ 简介：SpringBoot2.x整合elasticSearch5.6.8实战 Spring Data Elasticsearch文档地址 https://docs.spring.io/spring-data/elasticsearch/docs/3.0.6.RELEASE/reference/html/ 版本说明：SpringBoot整合elasticsearch https://github.com/spring-projects/spring-data-elasticsearch/wiki/Spring-Data-Elasticsearch---Spring-Boot---version-matrix 1、添加maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; 2、接口继承ElasticSearchRepository,里面有很多默认实现 注意点： 索引名称记得小写，类属性名称也要小写 新建实体对象article 加上类注解 @Document(indexName = &quot;blog&quot;, type = &quot;article&quot;) 3、配置文件：ELASTICSEARCH (ElasticsearchProperties) ​ spring.data.elasticsearch.cluster-name=elasticsearch # Elasticsearch cluster name.​ spring.data.elasticsearch.cluster-nodes=localhost:9300 # Comma-separated list of cluster node addresses.​ spring.data.elasticsearch.repositories.enabled=true # Whether to enable Elasticsearch repositories.​​ 4、QueryBuilder使用​ https://www.elastic.co/guide/en/elasticsearch/client/java-api/1.3/query-dsl-queries.html​ //单个匹配，搜索name为jack的文档 QueryBuilder queryBuilder = QueryBuilders.matchQuery(“title”, “搜”); 4、查看es数据 查看索引信息：http://localhost:9200/_cat/indices?v 查看某个索引库结构：http://localhost:9200/blog 查看某个对象：http://localhost:9200/blog/article/1 13 消息队列介绍和SpringBoot2.x整合RockketMQ、ActiveMQ 9节课加入小D课堂技术交流答疑群：Q群：699347262 1、JMS介绍和使用场景及基础编程模型​ 简介：讲解什么是小写队列，JMS的基础知识和使用场景​ 1、什么是JMS: Java消息服务（Java Message Service),Java平台中关于面向消息中间件的接口 2、JMS是一种与厂商无关的 API，用来访问消息收发系统消息，它类似于JDBC(Java Database Connectivity)。这里，JDBC 是可以用来访问许多不同关系数据库的 API 3、使用场景： 1）跨平台 2）多语言 3）多项目 4）解耦 5）分布式事务 6）流量控制 7）最终一致性 8）RPC调用 上下游对接，数据源变动-&gt;通知下属 4、概念 JMS提供者：Apache ActiveMQ、RabbitMQ、Kafka、Notify、MetaQ、RocketMQ JMS生产者(Message Producer) JMS消费者(Message Consumer) JMS消息 JMS队列 JMS主题 JMS消息通常有两种类型：点对点（Point-to-Point)、发布/订阅（Publish/Subscribe） 5、编程模型 MQ中需要用的一些类 ConnectionFactory ：连接工厂，JMS 用它创建连接 Connection ：JMS 客户端到JMS Provider 的连接 Session： 一个发送或接收消息的线程 Destination ：消息的目的地;消息发送给谁. MessageConsumer / MessageProducer： 消息接收者，消费者 2、ActiveMQ5.x消息队列基础介绍和安装​​ 简介：介绍ActiveMQ5.x消息队列基础特性和本地快速安装​ 特点：​ 1）支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议​ 2）支持许多高级功能，如消息组，虚拟目标，通配符和复合目标​ 3) 完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息​ 4) Spring支持，ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置​ 5) 支持在流行的J2EE服务器（如TomEE，Geronimo，JBoss，GlassFish和WebLogic）中进行测试​ 6) 使用JDBC和高性能日志支持非常快速的持久化​ …​​ 1、下载地址：http://activemq.apache.org/activemq-5153-release.html​ 2、快速开始：http://activemq.apache.org/getting-started.html​ 3、如果我们是32位的机器，就双击win32目录下的activemq.bat,如果是64位机器，则双击win64目录下的activemq.bat​ 4、bin目录里面启动 选择对应的系统版本和位数，activeMQ start 启动​ 5、启动后访问路径http://127.0.0.1:8161/​​ 6、用户名和密码默认都是admin​ 7、官方案例集合​ https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples​ 面板：​ Name：队列名称。​ Number Of Pending Messages：等待消费的消息个数。​ Number Of Consumers：当前连接的消费者数目​ Messages Enqueued：进入队列的消息总个数，包括出队列的和待消费的，这个数量只增不减。​ Messages Dequeued：已经消费的消息数量。 3、SpringBoot2.x整合ActiveMQ实战之点对点消息(p2p)​​ 简介:SpringBoot2.x整合ActiveMQ实战之点对点消息​​ 1、官网地址：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-activemq​​ 2、加入依赖​ ​ ​ org.springframework.boot​ spring-boot-starter-activemq​ ​ org.apache.activemq activemq-pool 3、application.properties配置文件配置 #整合jms测试，安装在别的机器，防火墙和端口号记得开放 spring.activemq.broker-url=tcp://127.0.0.1:61616 #集群配置 #spring.activemq.broker-url=failover:(tcp://localhost:61616,tcp://localhost:61617) spring.activemq.user=admin spring.activemq.password=admin #下列配置要增加依赖 spring.activemq.pool.enabled=true spring.activemq.pool.max-connections=100 4、springboot启动类 @EnableJms，开启支持jms 5、模拟请求 localhost:8080/api/v1/order?msg=12312321321312 6、消费者：实时监听对应的队列 @JmsListener(destination = &quot;order.queue&quot;) ​ 4、SpringBoot整合ActiveMQ实战之发布订阅模式(pub/sub)​ 简介：SpringBoot整合ActiveMQ实战之发布订阅模式(pub/sub),及同时支持点对点和发布订阅模型 1、需要加入配置文件，支持发布订阅模型，默认只支持点对点 #default point to point spring.jms.pub-sub-domain=true 注意点： 1、默认消费者并不会消费订阅发布类型的消息，这是由于springboot默认采用的是p2p模式进行消息的监听 修改配置：spring.jms.pub-sub-domain=true 2、@JmsListener如果不指定独立的containerFactory的话是只能消费queue消息 修改订阅者container：containerFactory=&quot;jmsListenerContainerTopic&quot; //需要给topic定义独立的JmsListenerContainer @Bean public JmsListenerContainerFactory&lt;?&gt; jmsListenerContainerTopic(ConnectionFactory activeMQConnectionFactory) { DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory(); bean.setPubSubDomain(true); bean.setConnectionFactory(activeMQConnectionFactory); return bean; } 在配置文件里面，注释掉 #spring.jms.pub-sub-domain=true 5、RocketMQ4.x消息队列介绍​ 简介：阿里开源消息队列 RocketMQ4.x介绍和新概念讲解 1、Apache RocketMQ作为阿里开源的一款高性能、高吞吐量的分布式消息中间件 2、特点 1)在高压下1毫秒内响应延迟超过99.6％。 2)适合金融类业务，高可用性跟踪和审计功能。 3)支持发布订阅模型，和点对点 4）支持拉pull和推push两种消息模式 5)单一队列百万消息 6)支持单master节点，多master节点，多master多slave节点 ... 3、概念 Producer:消息生产者 Producer Group:消息生产者组，发送同类消息的一个消息生产组 Consumer:消费者 Consumer Group:消费同个消息的多个实例 Tag:标签，子主题（二级分类）,用于区分同一个主题下的不同业务的消息 Topic:主题 Message：消息 Broker：MQ程序，接收生产的消息，提供给消费者消费的程序 Name Server：给生产和消费者提供路由信息，提供轻量级的服务发现和路由 3、官网地址：http://rocketmq.apache.org/ 学习资源： 1）http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/ 2）https://www.jianshu.com/p/453c6e7ff81c 6、RocketMQ4.x本地快速部署​ 简介:RocketMQ4.x本地快速部署 1、安装前提条件(推荐) 64bit OS, Linux/Unix/Mac 64bit JDK 1.8+; 2、快速开始 http://rocketmq.apache.org/docs/quick-start/ 下载安装包：https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.2.0/rocketmq-all-4.2.0-bin-release.zip 路径：/Users/jack/Desktop/person/springboot/资料/第13章/第5课/rocketmq-all-4.2.0-bin-release/bin 3、解压压缩包 1）进入bin目录，启动namesrv nohup sh mqnamesrv &amp; 2) 查看日志 tail -f nohup.out 结尾：The Name Server boot success. serializeType=JSON 表示启动成功 3、启动broker nohup sh mqbroker -n 127.0.0.1:9876 &amp; 4)、关闭nameserver broker执行的命令 sh mqshutdown namesrv sh mqshutdown broker 7、RoekerMQ4.x可视化控制台讲解​ 简介：RoekerMQ4.x可视化控制台讲解 1、下载 https://github.com/apache/rocketmq-externals 2、编译打包 mvn clean package -Dmaven.test.skip=true 3、target目录 通过java -jar的方式运行 4、无法连接获取broker信息 1）修改配置文件,名称路由地址为 namesrvAddr，例如我本机为 2）src/main/resources/application.properties rocketmq.config.namesrvAddr=192.168.0.101:9876 5、默认端口 localhost:8080 6、注意： 在阿里云，腾讯云或者虚拟机，记得检查端口号和防火墙是否启动 8、Springboot2.x整合RocketMQ4.x实战上集​ 简介：Springboot2.x整合RocketMQ4.x实战，加入相关依赖，开发生产者代码​​ 启动nameser和broker​​ 1、加入相关依赖​ ​ org.apache.rocketmq​ rocketmq-client​ ${rocketmq.version}​ ​ ​ org.apache.rocketmq​ rocketmq-common​ ${rocketmq.version}​ 2、application.properties加入配置文件 # 消费者的组名 apache.rocketmq.consumer.PushConsumer=orderConsumer # 生产者的组名 apache.rocketmq.producer.producerGroup=Producer # NameServer地址 apache.rocketmq.namesrvAddr=127.0.0.1:9876 3、开发MsgProducer /** * 生产者的组名 */ @Value(&quot;${apache.rocketmq.producer.producerGroup}&quot;) private String producerGroup; /** * NameServer 地址 */ @Value(&quot;${apache.rocketmq.namesrvAddr}&quot;) private String namesrvAddr; private DefaultMQProducer producer ; ​​ public DefaultMQProducer getProducer(){​ return this.producer;​ }​​ @PostConstruct​ public void defaultMQProducer() {​ //生产者的组名​ producer = new DefaultMQProducer(producerGroup);​ //指定NameServer地址，多个地址以 ; 隔开​ //如 producer.setNamesrvAddr(“192.168.100.141:9876;192.168.100.142:9876;192.168.100.149:9876”);​ producer.setNamesrvAddr(namesrvAddr);​ producer.setVipChannelEnabled(false);​​ try {​ /*​ Producer对象在使用之前必须要调用start初始化，只能初始化一次​ */​ producer.start();​ } catch (Exception e) { e.printStackTrace(); } // producer.shutdown(); 一般在应用上下文，关闭的时候进行关闭，用上下文监听器 } 9、Springboot2.x整合RocketMQ4.x实战下集​ 简介：Springboot2.x整合RocketMQ4.x实战，开发消费者代码，常见问题处理 1、创建消费者 问题： 1、Caused by: org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;172.17.42.1:10911&gt; failed 2、com.alibaba.rocketmq.client.exception.MQClientException: Send [1] times, still failed, cost [1647]ms, Topic: TopicTest1, BrokersSent: [broker-a, null, null] 3、org.apache.rocketmq.client.exception.MQClientException: Send [3] times, still failed, cost [497]ms, Topic: TopicTest, BrokersSent: [chenyaowudeMacBook-Air.local, chenyaowudeMacBook-Air.local, chenyaowudeMacBook-Air.local] 解决：多网卡问题处理 1、设置producer: producer.setVipChannelEnabled(false); 2、编辑ROCKETMQ 配置文件：broker.conf（下列ip为自己的ip） namesrvAddr = 192.168.0.101:9876 brokerIP1 = 192.168.0.101 4、DESC: service not available now, maybe disk full, CL: 解决：修改启动脚本runbroker.sh，在里面增加一句话即可： JAVA_OPT=&quot;${JAVA_OPT} -Drocketmq.broker.diskSpaceWarningLevelRatio=0.98&quot; （磁盘保护的百分比设置成98%，只有磁盘空间使用率达到98%时才拒绝接收producer消息） 常见问题处理： https://blog.csdn.net/sqzhao/article/details/54834761 https://blog.csdn.net/mayifan0/article/details/67633729 https://blog.csdn.net/a906423355/article/details/78192828 14 高级篇幅之SpringBoot多环境配置 1节课1、SpringBoot多环境配置介绍和项目实战（核心知识）​ 简介：SpringBoot介绍多环境配置和使用场景 1、不同环境使用不同配置 例如数据库配置，在开发的时候，我们一般用开发数据库，而在生产环境的时候，我们是用正式的数据 2、配置文件存放路径 classpath根目录的“/config”包下 classpath的根目录下 3、spring boot允许通过命名约定按照一定的格式(application-{profile}.properties)来定义多个配置文件 15 高级篇幅之SpringBoot2.0响应式编程 4节课 1、SprinBoot2.x响应式编程简介​ 简介:讲解什么是reactive响应式编程和使用的好处 1、基础理解： 依赖于事件，事件驱动(Event-driven) 一系列事件称为“流” 异步 非阻塞 观察者模式 网上的一个例子： int b= 2; int c=3 int a = b+c //命令式编程后续b和c变化，都不影响a b=5; int b= 2; int c= 3 int a = b+c //响应式编程中，a的变化，会和b、c的变化而变化（事件驱动） b=5; 2、官网：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-webflux SpingBoot2底层是用spring5,开始支持响应式编程，Spring又是基于Reactor试下响应式。 ​ 学习资料 1、reactive-streams学习资料：http://www.reactive-streams.org/ 2、web-flux相关资料：https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux 2、SpringBoot2.x响应式编程webflux介绍​ 简介：讲解SpringBoot2.x响应式编程介绍 Mono、Flux对象和优缺点​​ 1、Spring WebFlux是Spring Framework 5.0中引入的新的反应式Web框架​ 与Spring MVC不同，它不需要Servlet API，完全异步和非阻塞，并 通过Reactor项目实现Reactive Streams规范。​ RxJava 2、Flux和Mono User List&lt;User&gt; 1）简单业务而言：和其他普通对象差别不大，复杂请求业务，就可以提升性能 2）通俗理解： Mono 表示的是包含 0 或者 1 个元素的异步序列 mono-&gt;单一对象 User redis-&gt;用户ID-》唯一的用户Mono&lt;User&gt; Flux 表示的是包含 0 到 N 个元素的异步序列 flux-&gt;数组列表对象 List&lt;User&gt; redis-&gt;男性用户-&gt;Flux&lt;User&gt; Flux 和 Mono 之间可以进行转换 3、Spring WebFlux有两种风格：基于功能和基于注解的。基于注解非常接近Spring MVC模型，如以下示例所示： 第一种： @RestController @RequestMapping（“/ users”） public class MyRestController { @GetMapping（“/ {user}”） public Mono &lt;User&gt; getUser（ @PathVariable Long user）{ // ... } @GetMapping（“/ {user} / customers”） public Flux &lt;Customer&gt; getUserCustomers（ @PathVariable Long user）{ // ... } @DeleteMapping（“/ {user}”） public Mono &lt;User&gt; deleteUser（ @PathVariable Long user）{ // ... } } 第二种： 路由配置与请求的实际处理分开 @Configuration public class RoutingConfiguration { @Bean public RouterFunction &lt;ServerResponse&gt; monoRouterFunction（UserHandler userHandler）{ return route（GET（ “/ {user}”）.and（accept（APPLICATION_JSON）），userHandler :: getUser） .andRoute（GET（“/ {user} / customers”）.and（accept（APPLICATION_JSON）），userHandler :: getUserCustomers） .andRoute（DELETE（“/ {user}”）.and（accept（APPLICATION_JSON）），userHandler :: deleteUser）; } } @Component public class UserHandler { 公共 Mono &lt;ServerResponse&gt; getUser（ServerRequest请求）{ // ... } public Mono &lt;ServerResponse&gt; getUserCustomers（ServerRequest request）{ // ... } 公共 Mono &lt;ServerResponse&gt; deleteUser（ServerRequest请求）{ // ... } } 4、Spring WebFlux应用程序不严格依赖于Servlet API，因此它们不能作为war文件部署，也不能使用src/main/webapp目录 5、可以整合多个模板引擎 除了REST Web服务外，您还可以使用Spring WebFlux提供动态HTML内容。Spring WebFlux支持各种模板技术，包括Thymeleaf，FreeMarker 3、SpringBoot2.x webflux实战​ 简介:webflux响应式编程实战​​ 1、WebFlux中，请求和响应不再是WebMVC中的ServletRequest和ServletResponse，而是ServerRequest和ServerResponse​​ 2、加入依赖，如果同时存在spring-boot-starter-web，则会优先用spring-boot-starter-web​ ​ org.springframework.boot​ spring-boot-starter-webflux​ ​​ 测试​ localhost:8080/api/v1/user/test​ 3、启动方式默认是Netty,8080端口 ​ 4、参考：https://spring.io/blog/2016/04/19/understanding-reactive-types 4、WebFlux客户端WebClient讲解​ 简介：讲解SpringBoot2.x WebFlux客户端WebClient的介绍和使用​ 1、反应式客户端 官网地址：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-webclient 16 高级篇幅之SpringBoot2.0服务器端主动推送SSE技术讲解 2节课加入小D课堂技术交流答疑群：Q群：699347262 1、服务端推送常用技术介绍​ 简介：服务端常用推送技术介绍，如websocket，sse轮询等​ 1、客户端轮询:ajax定时拉取 2、服务端主动推送:WebSocket 全双工的，本质上是一个额外的tcp连接，建立和关闭时握手使用http协议，其他数据传输不使用http协议 更加复杂一些，适用于需要进行复杂双向数据通讯的场景 3、服务端主动推送:SSE (Server Send Event) html5新标准，用来从服务端实时推送数据到浏览器端， 直接建立在当前http连接上，本质上是保持一个http长连接，轻量协议 简单的服务器数据推送的场景，使用服务器推送事件 学习资料：http://www.w3school.com.cn/html5/html_5_serversentevents.asp 2、SpringBoot2.x服务端主动推送SSE​ 简介：讲解SpringBoot2.x服务端主动推送Sever-Send-Events​​ 1、localhost:8080/index.html 2、需要把response的类型 改为 text/event-stream，才是sse的类型 17 高级篇幅之云服务器介绍和部署生产环境实战 5节课1、阿里云服务器介绍和使用讲解​ 简介：阿里云服务器介绍和使用讲解 2、阿里云Linux服务器部署JDK8实战​ 简介：在阿里云服务器上安装JDK8和配置环境变量 lnux下使用wget下载jdk8: 进到目录/usr/local/software 配置环境变量 vim /etc/profile 加入 export JAVA_HOME=/usr/local/software/jdk8 export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export JAVA_HOME PATH CLASSPATH 使用 source /etc/profile 让配置立刻生效 3、阿里云服务器SpringBoot2.x生产环境部署实战​ 简介：讲解SpringBoot生产环境部署和常见注意事项​​​ 1、去除相关生产环境没用的jar​ 比如热部署dev-tool​​ 2、本地maven打包成jar包​ mvn clean package -Dmaven.test.skip=true 跳过测试​​ 3、服务器安装jdk，上传Jar包​ 上传工具：​ windows:​ winscp​ securtyCRT​ mac：​ filezilla​ ssh root@120.79.160.143​ 访问路径 http://120.79.160.143:8080/api/v1/user/find​ java -jar xxxx.jar 守护进程、系统服务、shell脚本 打包指定配置文件 1、使用maven的profiles 2、使用springboot的profile=active 访问不了 1、阿里云防火墙是否开启，可以选择关闭，关闭是不安全的，可以选择开放端口 2、阿里云的安全访问组，开启对应的端口，如果应用是以80端口启动，则默认可以访问 4、成熟的互联网公司应该有的架构 本地提交生产代码-&gt;gitlab仓库-&gt;Jenkins自动化构建-&gt;运维或者开发人员发布 4、SpringBoot2.x监控Actuator实战上集​ 简介：讲解SpringBoot使用actuator监控配置和使用 可用性：100%，99.9% 1、介绍什么是actuator 官方介绍： Spring Boot包含许多附加功能，可帮助您在将应用程序投入生产时监视和管理应用程序。 可以选择使用HTTP端点或JMX来管理和监控您的应用程序，自动应用于审计，健康和指标收集; 一句话：springboot提供用于监控和管理生产环境的模块 官方文档：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#production-ready 2、加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 3、加入上述依赖后，访问几个url /actuator/health /actuator/info /actuator 5、SpringBoot2.x监控Actuator实战下集及生产环境建议（核心知识)​ 简介：SpringBoot2.x监控Actuator实战下集及生产环境建议，SpringBoot新旧版本区别 注意点: 网上的资料大多数没有讲到访问的前缀 端点基础路径由 / 调整到 /actuator 如：/info调整为/actuator/info /actuator/xxx 1、只能访问几个url 1）需要在配置文件中加入下列配置 management.endpoints.web.exposure.include=* 2）官网说明：https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-actuator 原因： 出于安全考虑，除/ health和/ info之外的所有执行器默认都是禁用的。 management.endpoints.web.exposure.include属性可用于启用执行器 2、建议 在设置management.endpoints.web.exposure.include之前，请确保暴露的执行器不包含敏感信息和/ 或通过将其放置在防火墙进行控制，不对外进行使用 禁用的端点将从应用程序上下文中完全删除。如果您只想更改端点所暴露的技术，请改用 include和exclude属性 。 例子： 开启全部：management.endpoints.web.exposure.include=* 开启某个：management.endpoints.web.exposure.include=metrics 关闭某个：management.endpoints.web.exposure.exclude=metrics 或者用springadmin进行管理 相关资料：https://www.cnblogs.com/ityouknow/p/8440455.html 或者用自己编写脚本监控 CPU、内存、磁盘、nginx的http响应状态码200,404,5xx 3、介绍常用的几个 /health 查看应用健康指标 /actuator/metrics 查看应用基本指标列表 /actuator/metrics/{name} 通过上述列表，查看具体 查看具体指标 /actuator/env 显示来自Spring的 ConfigurableEnvironment的属性]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2018%2F12%2F21%2FRedis%2FReids%2F</url>
    <content type="text"><![CDATA[Jredies 参照杨开整的书 注意Netty不要使用默认的 要换成书里面的]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F12%2F21%2FGit%20Maven%20%2FGit%2F</url>
    <content type="text"><![CDATA[GitHub创建仓库提示代码123456echo &quot;# 项目名&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@github.com:qiubaiying/项目名.gitgit push -u origin master 若仓库存在直接push: 12git remote add origin git@github.com:qiubaiying/test.gitgit push -u origin master 常用操作创建仓库（初始化)123456在当前指定目录下创建git init新建一个仓库目录git init [project-name]克隆一个远程项目git clone [url] ##添加文件到缓存区 12345添加所有变化的文件 git add .添加名称指定文件git add text.txt 配置123设置提交代码时的用户信息git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 提交123456789101112131415161718提交暂存区到仓库区git commit -m &quot;msg&quot;# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] ##标签Tags 1234567891011121314151617181920212223添加标签 在当前commitgit tag -a v1.0 -m &apos;xxx&apos; 添加标签 在指定commitgit tag v1.0 [commit]查看git tag删除git tag -d V1.0删除远程taggit push origin :refs/tags/[tagName]推送git push origin --tags拉取git fetch origin tag V1.0新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archives]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf]]></title>
    <url>%2F2018%2F12%2F19%2FJSP%20Servlet%20Thyme%2FThymeleaf%2F</url>
    <content type="text"><![CDATA[#Thymeleaf中取值 reservation：$. {reservations}其中${reservations}的值是modeandview里面的 #reservation的值是随 便起的变量 放在reservation里面 –表格]]></content>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html]]></title>
    <url>%2F2018%2F12%2F19%2FHTML%2BCSS%2BJS%2FHTML%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F15%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[邪不压正找到你让子弹飞你好 之华人不彪悍枉少年#我不是药神仙 影一本好书]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F15%2Ft%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[for 循环]]></title>
    <url>%2F2018%2F12%2F15%2Fjava%E5%9F%BA%E7%A1%80%2Ffor%E5%BE%AA%E7%8E%AF%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[for 循环 大圈套小圈#1.1for循环思想 123456789public class code4 &#123; public static void main(String[] args) &#123; for (int x = 0; x &lt; 3; x++) &#123; for (int y = 0; y &lt; 4; y++) &#123; System.out.println("ok"); &#125; &#125; &#125;&#125; 读第一个for循环初始化一个x 变量x=0： ​ 先执行x=0; 执行x&lt;3满足条件—&gt; 执行第二个for循环语句初始化一个变量y=0; ​ 先执行y=0;执行y&lt;4满足条件–&gt;打印一次ok 当内循环没有结束时循环出不去执行–&gt;y++;打印四次ok； y++=4时候y&lt;4不成立 跳出循环 y在内存中消失 –&gt;执行–x++ 满足条件 又产生一个y=0,内循环继续循环四次 所以一共打印12个ok #1.2验证doc命令行 123456789101112131415161718public class code5 &#123;/** * for循环基本思想demo1 * 输出： * ***** * ***** * ***** * ***** */ public static void main(String[] args) &#123; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; i 控制行 第一个for循环 j控制列 第二个for循环 （每一列的个数） #1.3验证doc命令行 123456789101112131415161718public class code6 &#123; /** 输出doc界面： * ***** * **** * *** * ** * * */ public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = i; j &lt; 5; j++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; 分析： #1.4验证doc 123456789101112131415161718public class code7 &#123; /** * * * ** * *** * **** * ***** */ public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; #1.5验证doc⭐️ 1234567891011121314151617public class code8 &#123; /** * 54321 * 5432 * 543 * 54 * 5 */ public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 5; j &gt; i; j--) &#123; System.out.print(j); &#125; System.out.println(); &#125; &#125;&#125; int j=5 j&gt;i j– 其中j—是关键 123456789101112131415161718public class code9 &#123; /** * 1 * 22 * 333 * 4444 * 55555 */ public static void main(String[] args) &#123; for (int i = 1; i &lt;= 5; i++) &#123; for (int j = 1; j &lt;=i; j++) &#123; System.out.print(i); &#125; System.out.println(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526public class code10 &#123; /** * * * * * * * * -* * * * * --* * * * ---* * * ----* * 由两个图形组成一个由向下的*组成 * 一个由向上的——组成 */ public static void main(String[] args) &#123; for (int i = 1; i &lt;= 5; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(" "); &#125; for (int z = i; z&lt;=5 ; z++) &#123; System.out.print("* "); &#125;System.out.println(); &#125; &#125;&#125; 分析： #1.6作 业：打印 123456789101112131415161718public class code8 &#123; /** * 54321 * 5432 * 543 * 54 * 5 */ public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 5; j &gt;i; j--) &#123; System.out.print(j); &#125;System.out.println(); &#125; &#125;&#125; 分析： 规律：for内循环 如果ji 并且让j– 1234567891011121314151617public class code9 &#123; /** * 1 * 22 * 333 * 4444 * 55555 */ public static void main(String[] args) &#123; for (int i = 1; i &lt;=5; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.print(i); &#125;System.out.println(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery]]></title>
    <url>%2F2018%2F12%2F14%2FJquery%2F</url>
    <content type="text"><![CDATA[1.获取Jquery对象1234567&lt;input type="text" id="username" value="jack"/&gt;&lt;script type="text/javascript"&gt; //jquery获得数据 语法$&#123;"选择器"&#125;==Jquery（"选择器"） var usernmae = $("#username"); //val() 函数 用于获得value属性的值 jack alert(usernmae.val());&lt;/script&gt; 2.Jquery与Dom对象的互相转换12345678910111213141516171819202122&lt;input type="text" id="username" value="jack"/&gt;&lt;script type="text/javascript"&gt; //Jquery对象和Dom对象的转换 //1。使用Javascripe获取value的值 var username = document.getElementById("username"); alert(username.value);//jack用的是属性 //2。将dom对象 转换为Jquery对象 //# 语法：$(dom对象) //# 建议 ：Jquery对象变量名字 建议以$开头 var $username = $(username); alert($username.val()); //3.将jquery对象转为Dom对象 //3.1 Jquery对象内部使用数组存放所有的数据 可以通过数组的下标获取（索引） var username2 = $username[0]; alert(username2.value); //3.2Jquery提供函数get()转换为dom对象 var username3 = $username.get(0); alert(username3.value);&lt;/script&gt; 3. 选择器3.1 基本选择器【重要】 id ,id选择器 通过id 值获得元素 element，标签选择器 通过标签名获得元素 .class 类选择器 通过class值获得元素。注意：使用点开头 s1,s2,… 多选择器，将多个选择器的结果添加一个数组中。 123456789101112131415161718192021&lt;script type="text/javascript"&gt; //window.onload=function()&#123;...&#125;匿名函数 //jquery 页面加载--&gt;function()匿名函数 $(document).ready(function () &#123; &#125;); //id选择器 为id绑定一个事件 然后传递一个函数 $("#btn1").click(function () &#123; $("#one").css("background-color", "#ff0") &#125;); //类选择器 $(".btn2").click(function () &#123; $(".one").css("background-color", "#ff0"); &#125;); //元素选择器 $("div").background = "#ff2";&lt;/script&gt;&lt;input type="button" id="btn1" value="选择id为one的元素"&gt;&lt;input type="button" class="btn2" value="选择id为one的元素"&gt; 3.2层级选择器 3.3基本过滤选择器——“：关键字“ 123456789101112131415161718192021222324252627&lt;label for="username"&gt;&lt;/label&gt;&lt;input type="text" id="username" value="jack"/&gt;&lt;script type="text/javascript"&gt; // &lt;input type="text" value="请输入账号" defaultValue="请输入账号"&gt; $("input[type='text']").on("blur focus", function () &#123; //1.获得默认值 var attr = $(this).attr("defaultValue"); //2.判断是否获得焦点 if ($(this).is(":focus")) &#123; //2.1 获得焦点，清空value值 ，this 当前执行对象 是dom对象用$(this)转为jquery对象 if ($(this).val() === attr) &#123; $(this).val(""); &#125; &#125; else &#123; //2.2失去焦点 设置默认值 if ($(this).val() === "") &#123; $(this).val(attr); &#125; &#125; &#125;);&lt;/script&gt;&lt;label&gt; &lt;input type="text" value="请输入账号" defaultValue="请输入账号"&gt; &lt;input type="text" value="请输入账号" defaultValue="请输入密码"&gt;&lt;/label&gt;&lt;/body&gt;&lt;/html&gt; 3.4内容过滤 3.5可见性过滤 （重要） 123456789101112*/// &lt;input type="button" value="选取所有可见的div元素" id="bt1"&gt;$("#b1").click(function () &#123; $("div:hidden").css("background-color", "#ff0");&#125;);// &lt;input type="button" value="选取所有不可见的元素利用jquery中的show（）将他们显示出来" id="bt2"&gt;$("#bt2").click(function () &#123; $("div:hidden").css("background-color", "#ff0");&#125;); 3.6实战 3.7属性选择器（掌握） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="js/jquery-2.1.0.js"&gt;&lt;/script&gt; &lt;!--1 ⭐️&lt;input type="button" value="选取含有属性title的div元素" id="btn1"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn1").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title]").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--2&lt;input type="button" value="选取属性title值等于"test"的div元素" id="btn2"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn2").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title='test']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--3 &lt;input type="button" value="选取属性title值不等于"test"的div元素（没有title属性的也会被选中）" id="btn3"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn2").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title！='test']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--4 &lt;input type="button" value="选取属性title值 以"te"开始的div元素（没有title属性的也会被选中）" id="btn4"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn2").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title^='te']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--5 &lt;input type="button" value="选取属性title值 以"est"结束的div元素（没有title属性的也会被选中）" id="btn5"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn2").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title$='est']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--6 &lt;input type="button" value="选取属性title值 含有"es"的div元素（没有title属性的也会被选中）" id="btn5"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn2").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title*='es']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--⭐️7&lt;input type="button" value="组合属性选择器 首先选取有属性id的div元素。然后在结果中 选取title 值含有"es"的元素"）" id="btn5"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn5").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[id][title*='es']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt; 3.8选择器 （子元素过滤） 123456789101112131415&lt;!--1 &lt;input type="button" value="选取每个class为one的div父元素下的第2个子元素" id="btn1"&gt;--&gt; &lt;script type="text/javascript"&gt; $("btn1").click(function () &#123; //子元素 选择使用前提 表达式前面必须是元素 如：$(div:nth-child(2)) //如果元素上添加 条件 必须使用空格 如$("div[class='one'] :nth-child(2)") $("div[class='one'] :nth-child(2)").css("background-color", "#ff0"); $("div.one :nth-child(2)").css("background-color", "#ff0"); &#125;); /** * 对比： * $("div.one") 所有的div自己的样式为one * $("div .one") 所有的div中后代元素 样式为one 空格 */ &lt;/script&gt; 123456789101112131415161718192021222324&lt;script type="text/javascript"&gt; $("btn1").click(function () &#123; $("div.one :first-child").css("background-color", "#ff0"); &#125;); &lt;/script&gt; &lt;!--&lt;input type="button" value="如果class为one的div父元素下的第一个子元素 " id="bt4"&gt;--&gt; &lt;script type="text/javascript"&gt; $("btn4").click(function () &#123; $("div.one :first-child").css("background-color", "#ff0"); &#125;); &lt;/script&gt; &lt;!--&lt;input type="button" value="如果class为one的div父元素下的最后一个子元素 " id="bt4"&gt;--&gt; &lt;script type="text/javascript"&gt; $("btn4").click(function () &#123; $("div.one :last-child").css("background-color", "#ff0"); &#125;); &lt;/script&gt; &lt;!--&lt;input type="button" value="如果class为one的div父元素下的仅仅只有一个子元素 " id="bt4"&gt;--&gt; &lt;script type="text/javascript"&gt; $("btn4").click(function () &#123; $("div.one :only-child").css("background-color", "#ff0"); &#125;); &lt;/script&gt; 3.9表单过滤选择器 表单对象属性过滤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 &lt;script src="js/jquery-2.1.0.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //1. &lt;button id="btn1"&gt;对表单内 可用input enable 赋值操作.&lt;/button&gt; $(document).ready(function () &#123; $("input:enabled").val("enabled"); &#125;); // 2 &lt;button id="btn2"&gt;对表单内 不可用input 赋值操作.&lt;/button&gt; $(document).ready(function () &#123; $("input:disabled").val("disabled"); &#125;); // 3 &lt;button id="btn3"&gt;获取多选框选中的个数.&lt;/button&gt; // &lt;input type="checkbox" name="newsletter" checked="checked" value="test1"/&gt;test1 $(document).ready(function () &#123; var s1 = $("[name='newsletter']:checked").length; // var s2 = $("[name='newsletter']:checked").size(); alert(s1) &#125;); // &lt;button id="btn4"&gt;获取下拉框选中的内容.&lt;/button&gt; $(":selected").each(function () &#123; //val()获得&lt;option &gt;如果没有value值 将获得text的值 //html（）获得标签体的内容 $("#selectDivId").append($(this).val()); // $("#selectDivId").append($(this).html()); &#125;); &lt;/script&gt; ------------ ------------ ------------ ------------ ------------ &lt;/head&gt;&lt;body&gt;&lt;h3&gt; 表单对象属性过滤选择器.&lt;/h3&gt;&lt;button type="reset"&gt;重置所有表单元素&lt;/button&gt;&lt;input type="checkbox" id="isreset" checked="checked"/&gt;&lt;label for="isreset"&gt;点击下列按钮时先自动重置页面&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;&lt;button id="btn1"&gt;对表单内 可用input 赋值操作.&lt;/button&gt;&lt;button id="btn2"&gt;对表单内 不可用input 赋值操作.&lt;/button&gt;&lt;button id="btn3"&gt;获取多选框选中的个数.&lt;/button&gt;&lt;button id="btn4"&gt;获取下拉框选中的内容.&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;可用元素：&lt;input name="add" value="可用文本框"/&gt; &lt;br/&gt;不可用元素：&lt;input name="email" disabled="disabled" value="不可用文本框"/&gt;&lt;br/&gt;可用元素： &lt;input name="che" value="可用文本框"/&gt;&lt;br/&gt;不可用元素：&lt;input name="name" disabled="disabled" value="不可用文本框"/&gt;&lt;br/&gt;&lt;br/&gt;多选框：&lt;br/&gt;&lt;input type="checkbox" name="newsletter" checked="checked" value="test1"/&gt;test1&lt;input type="checkbox" name="newsletter" value="test2"/&gt;test2&lt;input type="checkbox" name="newsletter" value="test3"/&gt;test3&lt;input type="checkbox" name="newsletter" checked="checked" value="test4"/&gt;test4&lt;input type="checkbox" name="newsletter" value="test5"/&gt;test5&lt;div id="checkboxDivId"&gt;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;下拉列表1：&lt;br/&gt;&lt;select name="test" multiple="multiple" style="height:100px"&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option selected="selected"&gt;湖南&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option selected="selected"&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;&lt;br/&gt;下拉列表2：&lt;br/&gt;&lt;select name="test2"&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option&gt;湖南&lt;/option&gt; &lt;option selected="selected"&gt;北京&lt;/option&gt; &lt;option&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;&lt;br/&gt;&lt;div id="selectDivId"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 选择器案例1234567891011121314151617181920 &lt;script type="text/javascript"&gt; $(document).ready(function () &#123;//从第5个开始 不要最后一个控制显示和隐藏 //1 隐藏 var $allLi = $("li:gt(4):not(:last)"); $allLi.hide();//2 点击显示 $("span").click(function () &#123; //$allLi.show(); // $allLi.toggle(); if ($allLi.is(":hidden")) &#123; $allLi.show(); $(this).html("隐藏"); &#125; else &#123; $allLi.hide(); $(this).html("显示"); &#125; &#125;); &#125;); &lt;/script&gt; 属性 CSS Jquery文档1.8.3]]></content>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯随笔]]></title>
    <url>%2F2018%2F12%2F14%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[一些笔记1.Java整型与字符串相互转换(转) ####1如何将字串 String 转换成整数 int? 有两个方法: 1) int i = Integer.parseInt([String]); ​ i = Integer.parseInt([String],[int radix]); 2). int i = Integer.valueOf(my_str).intValue(); 注: 字串转成 Double, Float, L #####2 如何将整数 int 转换成字串 String ? A. 有叁种方法: 1.) String s = String.valueOf(i); 2.) String s = Integer.toString(i); 3.) String s = “” + i; 注: Double, Float, Long 转成字串的方法大同小异. &amp;&amp; : 逻辑与 当前仅当两个操作数都为真的时候条件才为真|| ： 逻辑或 如果任何两个操作数任何一个为真 条件为真]]></content>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F12%2F13%2FMybatis%2F%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[—]]></content>
  </entry>
  <entry>
    <title><![CDATA[类加载器]]></title>
    <url>%2F2018%2F12%2F12%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%20%2F</url>
    <content type="text"><![CDATA[1.ClassLoader##1.1什么是类加载器]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC 及bean容器 注入]]></title>
    <url>%2F2018%2F12%2F10%2FSpring%2F4.SpringBean%20%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1 Spring Bean 装配之Bean的定义及其作用域的注解实现 ​ &lt; context:component-scan&gt; 例子123&lt;context:component-scan base-package="bean.BeanAnnotation"&gt; &lt;context:component-scan/&gt; 1234567package bean;@Componentpublic class BeanAnnotation &#123; public void say()&#123; System,out.print("Hello Spring"); &#125;&#125; 1234 @Test BeanAnnotation bean=super.getBean("beanAnnotation");//类名小写 bean.say("This is Tese");&#125; 2 Spring装配 基于java容器的注解说明 @importResource和@Value 123456789public class MyDriverManager &#123; public MyDriverManager(String url, String userName, String password) &#123; System.out.print(url); System.out.print(userName); System.out.print(password); &#125;&#125; 123456789101112131415161718@Configuration@ImportResource("classpath:config.xml")public class StoreConfig &#123; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; @Bean public MyDriverManager myDriverManager() &#123; return new MyDriverManager(url, username, password); &#125;&#125; 12345678public class Test &#123; @Test public void testMyDreiverManager() &#123; MyDriverManager myDriverManager = super.getBean("myDriverManager"); myDriverManager.getClass().getName(); &#125;&#125; 123jdbc.password=rootjdbc.url=127.0.0.1jdbc.username=root 3@Bean 和@Scope 4基于泛型的自动装配 Aware 和Autowiring]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F12%2F10%2Fjava%E5%9F%BA%E7%A1%80%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031public class ClassDemo1 &#123; public static void main(String[] args) &#123; // Foo的实例对象如何表示 Foo foo1 = new Foo();// foo1就表示出来了 // Foo 这个类 也是个实例对象 ，Class类的实列对象 如何表示呢 // 任何一个类都是Class的实列对象 这个实列对象有三种表示方式 /** * c1 c2表示了Foo类的类类型（class type） * 万事万物皆对象 * 类也是对象 是Class类的实列对象 * 这个对象我们称为该类的lei lei */ // 第一种表示方式---&gt;实际在告诉我们任何一个类都以一个隐含的静态成员 Class c1=Foo.class; // 第二种表示方式--&gt;已经知道该类的对象通过getClass方法 Class c2 = foo1.getClass(); //第三种方式 Class c3=Class.forName("com.package.Foo") &#125; // 我们完全可以通过类类型创建该类的对象实列 // --&gt;通过c1 or c2 创建Foo的实例 Foo foo = (Foo) c1.newInstance();foo.print(); class Foo &#123; void print() &#123; &#125; &#125;&#125; 123456789101112131415161718package com.imooc.reflect;public class ClassDemo2 &#123; public static void main(String[] args) &#123; Class c1 = int.class;//int 的类类型 Class c2 = String.class;//String类的类类型 String类字节码（自己发明的) Class c3 = double.class; Class c4 = Double.class; Class c5 = void.class; System.out.println(c1.getName()); System.out.println(c2.getName()); System.out.println(c2.getSimpleName());//不包含包名的类的名称 System.out.println(c5.getName()); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.imooc.reflect;public class ClassDemo1 &#123; public static void main(String[] args) &#123; //Foo的实例对象如何表示 Foo foo1 = new Foo();//foo1就表示出来了. //Foo这个类 也是一个实例对象，Class类的实例对象,如何表示呢 //任何一个类都是Class的实例对象，这个实例对象有三种表示方式 //第一种表示方式---&gt;实际在告诉我们任何一个类都有一个隐含的静态成员变量class Class c1 = Foo.class; //第二中表达方式 已经知道该类的对象通过getClass方法 Class c2 = foo1.getClass(); /*官网 c1 ,c2 表示了Foo类的类类型(class type) * 万事万物皆对象， * 类也是对象，是Class类的实例对象 * 这个对象我们称为该类的类类型 * */ //不管c1 or c2都代表了Foo类的类类型，一个类只可能是Class类的一个实例对象 System.out.println(c1 == c2); //第三种表达方式 Class c3 = null; try &#123; c3 = Class.forName("com.imooc.reflect.Foo"); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(c2==c3); //我们完全可以通过类的类类型创建该类的对象实例----&gt;通过c1 or c2 or c3创建Foo的实例对象 try &#123; Foo foo = (Foo)c1.newInstance();//需要有无参数的构造方法 foo.print(); &#125; catch (InstantiationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;class Foo&#123; void print()&#123; System.out.println("foo"); &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.imooc.reflect;import java.lang.reflect.Method;public class BeanUtil &#123; /** * 根据标准javaBean对象的属性名获取其属性值 * * @param obj * @param propertyName * @return */ public static Object getValueByPropertyName(Object obj, String propertyName) &#123; // 1.根据属性名称就可以获取其get方法 String getMethodName = "get" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1); //2.获取方法对象 Class c = obj.getClass(); try &#123; //get方法都是public的且无参数 Method m= c.getMethod(getMethodName); //3 通过方法的反射操作方法 Object value = m.invoke(obj); return value; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.imooc.reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ClassUtil &#123; /** * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数) * @param obj 该对象所属类的信息 */ public static void printClassMethodMessage(Object obj)&#123; //要获取类的信息 首先要获取类的类类型 Class c = obj.getClass();//传递的是哪个子类的对象 c就是该子类的类类型 //获取类的名称 System.out.println("类的名称是:"+c.getName()); /* * Method类，方法对象 * 一个成员方法就是一个Method对象 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限 */ Method[] ms = c.getMethods();//c.getDeclaredMethods() for(int i = 0; i &lt; ms.length;i++)&#123; //得到方法的返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName()+" "); //得到方法的名称 System.out.print(ms[i].getName()+"("); //获取参数类型---&gt;得到的是参数列表的类型的类类型 Class[] paramTypes = ms[i].getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125; /** * 获取成员变量的信息 * @param obj */ public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); /* * 成员变量也是对象 * java.lang.reflect.Field * Field类封装了关于成员变量的操作 * getFields()方法获取的是所有的public的成员变量的信息 * getDeclaredFields获取的是该类自己声明的成员变量的信息 */ //Field[] fs = c.getFields(); Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; //得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName+" "+fieldName); &#125; &#125; /** * 打印对象的构造函数的信息 * @param obj */ public static void printConMessage(Object obj)&#123; Class c = obj.getClass(); /* * 构造函数也是对象 * java.lang. Constructor中封装了构造函数的信息 * getConstructors获取所有的public的构造函数 * getDeclaredConstructors得到所有的构造函数 */ //Constructor[] cs = c.getConstructors(); Constructor[] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName()+"("); //获取构造函数的参数列表---&gt;得到的是参数列表的类类型 Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 Rabbit MQ 老师源代码]]></title>
    <url>%2F2018%2F12%2F05%2FRabbitMQ%2Fquickstart%2F</url>
    <content type="text"><![CDATA[慕课网 Rabbit MQ 老师源代码12345678910111213141516171819202122232425262728public class Procuder &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 通过Channel发送数据 for(int i=0; i &lt; 5; i++)&#123; String msg = &quot;Hello RabbitMQ!&quot;; //1 exchange 2 routingKey channel.basicPublish(&quot;&quot;, &quot;test001&quot;, null, msg.getBytes()); &#125; //5 记得要关闭相关的连接 channel.close(); connection.close(); &#125;&#125; quickstart12345678910111213141516171819202122232425262728293031package com.example.rabbitmq.start;import org.springframework.boot.SpringApplication;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class Procuder &#123; // 生产端Procuder http://94.191.24.33:15672/#/ public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;94.191.24.33&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); // 2.通过连接工厂创建连接connectionFactory.newConnection(); Connection connection = connectionFactory.newConnection(); // 3.通过connection创建一个Channel Channel channel = connection.createChannel(); // 4.通过Channel发送数据 String msg = &quot;Hello RabbitMQ&quot;; // channel.basicPublish(exchange, routingKey, props, body); channel.basicPublish(&quot;&quot;, &quot;test001&quot;, null, msg.getBytes()); channel.close(); connection.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.rabbitmq.start;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import com.rabbitmq.client.QueueingConsumer;import com.rabbitmq.client.QueueingConsumer.Delivery;public class Consumer &#123; @SuppressWarnings(&quot;deprecation&quot;) public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory，并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;94.191.24.33&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); // 2.通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); // 3 通过连接工厂创建连接 Channel channel = connection.createChannel(); // 4.申明（创建）一个队列 String queueName = &quot;test001&quot;; // channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments) channel.queueDeclare(&quot;test001&quot;, true, false, false, null); // 5.创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); /** * 6.设置channel # channel.basicConsume(queue,autoAck, autoAck) # 1：queue：队列的名字 * 2.autoAck：是否自动签收 3:autoAck：具体的消费者对象 */ channel.basicConsume(queueName, true, queueingConsumer); // 7.获取消息 while (true) &#123; Delivery delivery = queueingConsumer.nextDelivery(); byte[] body = delivery.getBody(); String msg = new String(delivery.getBody());// 获取消息 System.out.println(&quot;消费端&quot; + msg); &#125; &#125;&#125;//String string =new String(delivery.getBody()); 12345678910111213141516171819202122232425262728293031323334353637public class Consumer &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 声明（创建）一个队列 String queueName = &quot;test001&quot;; channel.queueDeclare(queueName, true, false, false, null); //5 创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); //6 设置Channel channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; //7 获取消息 Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费端: &quot; + msg); //Envelope envelope = delivery.getEnvelope(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829public class Procuder &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 通过Channel发送数据 for(int i=0; i &lt; 5; i++)&#123; String msg = &quot;Hello RabbitMQ!&quot;; //1 exchange 2 routingKey channel.basicPublish(&quot;&quot;, &quot;test001&quot;, null, msg.getBytes()); &#125; //5 记得要关闭相关的连接 channel.close(); connection.close(); &#125;&#125; apiack1234567891011121314151617181920212223242526272829public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_ack_exchange&quot;; String queueName = &quot;test_ack_queue&quot;; String routingKey = &quot;ack.#&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); // 手工签收 必须要关闭 autoAck = false channel.basicConsume(queueName, false, new MyConsumer(channel)); &#125;&#125; 1234567891011121314151617181920212223242526272829public class MyConsumer extends DefaultConsumer &#123; private Channel channel ; public MyConsumer(Channel channel) &#123; super(channel); this.channel = channel; &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;body: &quot; + new String(body)); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if((Integer)properties.getHeaders().get(&quot;num&quot;) == 0) &#123; channel.basicNack(envelope.getDeliveryTag(), false, true); &#125; else &#123; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_ack_exchange&quot;; String routingKey = &quot;ack.save&quot;; for(int i =0; i&lt;5; i ++)&#123; Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;(); headers.put(&quot;num&quot;, i); AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .deliveryMode(2) .contentEncoding(&quot;UTF-8&quot;) .headers(headers) .build(); String msg = &quot;Hello RabbitMQ ACK Message &quot; + i; channel.basicPublish(exchange, routingKey, true, properties, msg.getBytes()); &#125; &#125;&#125; confirm1234567891011121314151617181920212223242526272829303132333435363738public class Consumer &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 获取C onnection Connection connection = connectionFactory.newConnection(); //3 通过Connection创建一个新的Channel Channel channel = connection.createChannel(); String exchangeName = &quot;test_confirm_exchange&quot;; String routingKey = &quot;confirm.#&quot;; String queueName = &quot;test_confirm_queue&quot;; //4 声明交换机和队列 然后进行绑定设置, 最后制定路由Key channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); //5 创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费端: &quot; + msg); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Producer &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 获取C onnection Connection connection = connectionFactory.newConnection(); //3 通过Connection创建一个新的Channel Channel channel = connection.createChannel(); //4 指定我们的消息投递模式: 消息的确认模式 channel.confirmSelect(); String exchangeName = &quot;test_confirm_exchange&quot;; String routingKey = &quot;confirm.save&quot;; //5 发送一条消息 String msg = &quot;Hello RabbitMQ Send confirm message!&quot;; channel.basicPublish(exchangeName, routingKey, null, msg.getBytes()); //6 添加一个确认监听 channel.addConfirmListener(new ConfirmListener() &#123; @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException &#123; System.err.println(&quot;-------no ack!-----------&quot;); &#125; @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException &#123; System.err.println(&quot;-------ack!-----------&quot;); &#125; &#125;); &#125;&#125; Consumer123456789101112131415161718192021222324252627public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_consumer_exchange&quot;; String routingKey = &quot;consumer.#&quot;; String queueName = &quot;test_consumer_queue&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); channel.basicConsume(queueName, true, new MyConsumer(channel)); &#125;&#125; 123456789101112131415161718public class MyConsumer extends DefaultConsumer &#123; public MyConsumer(Channel channel) &#123; super(channel); &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;consumerTag: &quot; + consumerTag); System.err.println(&quot;envelope: &quot; + envelope); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); &#125;&#125; 12345678910111213141516171819202122232425public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_consumer_exchange&quot;; String routingKey = &quot;consumer.save&quot;; String msg = &quot;Hello RabbitMQ Consumer Message&quot;; for(int i =0; i&lt;5; i ++)&#123; channel.basicPublish(exchange, routingKey, true, null, msg.getBytes()); &#125; &#125;&#125; dlx12345678910111213141516171819202122232425262728293031323334353637public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); // 这就是一个普通的交换机 和 队列 以及路由 String exchangeName = &quot;test_dlx_exchange&quot;; String routingKey = &quot;dlx.#&quot;; String queueName = &quot;test_dlx_queue&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); Map&lt;String, Object&gt; agruments = new HashMap&lt;String, Object&gt;(); agruments.put(&quot;x-dead-letter-exchange&quot;, &quot;dlx.exchange&quot;); //这个agruments属性，要设置到声明队列上 channel.queueDeclare(queueName, true, false, false, agruments); channel.queueBind(queueName, exchangeName, routingKey); //要进行死信队列的声明: channel.exchangeDeclare(&quot;dlx.exchange&quot;, &quot;topic&quot;, true, false, null); channel.queueDeclare(&quot;dlx.queue&quot;, true, false, false, null); channel.queueBind(&quot;dlx.queue&quot;, &quot;dlx.exchange&quot;, &quot;#&quot;); channel.basicConsume(queueName, true, new MyConsumer(channel)); &#125;&#125; 123456789101112131415public class MyConsumer extends DefaultConsumer &#123; public MyConsumer(Channel channel) &#123; super(channel); &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;consumerTag: &quot; + consumerTag); System.err.println(&quot;envelope: &quot; + envelope); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); &#125; 123456789101112131415161718192021222324252627282930public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_dlx_exchange&quot;; String routingKey = &quot;dlx.save&quot;; String msg = &quot;Hello RabbitMQ DLX Message&quot;; for(int i =0; i&lt;1; i ++)&#123; AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .deliveryMode(2) .contentEncoding(&quot;UTF-8&quot;) .expiration(&quot;10000&quot;) .build(); channel.basicPublish(exchange, routingKey, true, properties, msg.getBytes()); &#125; &#125;&#125; exchange–direct123456789101112131415161718192021222324252627282930313233343536373839404142public class Consumer4DirectExchange &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory() ; connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); connectionFactory.setAutomaticRecoveryEnabled(true); connectionFactory.setNetworkRecoveryInterval(3000); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_direct_exchange&quot;; String exchangeType = &quot;direct&quot;; String queueName = &quot;test_direct_queue&quot;; String routingKey = &quot;test.direct&quot;; //表示声明了一个交换机 channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null); //表示声明了一个队列 channel.queueDeclare(queueName, false, false, false, null); //建立一个绑定关系: channel.queueBind(queueName, exchangeName, routingKey); //durable 是否持久化消息 QueueingConsumer consumer = new QueueingConsumer(channel); //参数：队列名称、是否自动ACK、Consumer channel.basicConsume(queueName, true, consumer); //循环获取消息 while(true)&#123; //获取消息，如果没有消息，这一步将会一直阻塞 Delivery delivery = consumer.nextDelivery(); String msg = new String(delivery.getBody()); System.out.println(&quot;收到消息：&quot; + msg); &#125; &#125;&#125; 1234567891011121314151617181920212223242526public class Producer4DirectExchange &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 创建Connection Connection connection = connectionFactory.newConnection(); //3 创建Channel Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_direct_exchange&quot;; String routingKey = &quot;test.direct111&quot;; //5 发送 String msg = &quot;Hello World RabbitMQ 4 Direct Exchange Message 111 ... &quot;; channel.basicPublish(exchangeName, routingKey , null , msg.getBytes()); &#125; &#125; Exchange-fanout12345678910111213141516171819202122232425262728293031323334353637public class Consumer4FanoutExchange &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory() ; connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); connectionFactory.setAutomaticRecoveryEnabled(true); connectionFactory.setNetworkRecoveryInterval(3000); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_fanout_exchange&quot;; String exchangeType = &quot;fanout&quot;; String queueName = &quot;test_fanout_queue&quot;; String routingKey = &quot;&quot;; //不设置路由键 channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null); channel.queueDeclare(queueName, false, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); //durable 是否持久化消息 QueueingConsumer consumer = new QueueingConsumer(channel); //参数：队列名称、是否自动ACK、Consumer channel.basicConsume(queueName, true, consumer); //循环获取消息 while(true)&#123; //获取消息，如果没有消息，这一步将会一直阻塞 Delivery delivery = consumer.nextDelivery(); String msg = new String(delivery.getBody()); System.out.println(&quot;收到消息：&quot; + msg); &#125; &#125;&#125; 123456789101112131415161718192021222324252627public class Producer4FanoutExchange &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 创建Connection Connection connection = connectionFactory.newConnection(); //3 创建Channel Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_fanout_exchange&quot;; //5 发送 for(int i = 0; i &lt; 10; i ++) &#123; String msg = &quot;Hello World RabbitMQ 4 FANOUT Exchange Message ...&quot;; channel.basicPublish(exchangeName, &quot;&quot;, null , msg.getBytes()); &#125; channel.close(); connection.close(); &#125; &#125; Exchange -topic123456789101112131415161718192021222324252627282930313233343536373839404142public class Consumer4TopicExchange &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory() ; connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); connectionFactory.setAutomaticRecoveryEnabled(true); connectionFactory.setNetworkRecoveryInterval(3000); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_topic_exchange&quot;; String exchangeType = &quot;topic&quot;; String queueName = &quot;test_topic_queue&quot;; //String routingKey = &quot;user.*&quot;; String routingKey = &quot;user.*&quot;; // 1 声明交换机 channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null); // 2 声明队列 channel.queueDeclare(queueName, false, false, false, null); // 3 建立交换机和队列的绑定关系: channel.queueBind(queueName, exchangeName, routingKey); //durable 是否持久化消息 QueueingConsumer consumer = new QueueingConsumer(channel); //参数：队列名称、是否自动ACK、Consumer channel.basicConsume(queueName, true, consumer); //循环获取消息 while(true)&#123; //获取消息，如果没有消息，这一步将会一直阻塞 Delivery delivery = consumer.nextDelivery(); String msg = new String(delivery.getBody()); System.out.println(&quot;收到消息：&quot; + msg); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031public class Producer4TopicExchange &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 创建Connection Connection connection = connectionFactory.newConnection(); //3 创建Channel Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_topic_exchange&quot;; String routingKey1 = &quot;user.save&quot;; String routingKey2 = &quot;user.update&quot;; String routingKey3 = &quot;user.delete.abc&quot;; //5 发送 String msg = &quot;Hello World RabbitMQ 4 Topic Exchange Message ...&quot;; channel.basicPublish(exchangeName, routingKey1 , null , msg.getBytes()); channel.basicPublish(exchangeName, routingKey2 , null , msg.getBytes()); channel.basicPublish(exchangeName, routingKey3 , null , msg.getBytes()); channel.close(); connection.close(); &#125; &#125; limit1234567891011121314151617181920212223242526272829303132public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_qos_exchange&quot;; String queueName = &quot;test_qos_queue&quot;; String routingKey = &quot;qos.#&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); //1 限流方式 第一件事就是 autoAck设置为 false channel.basicQos(0, 1, false); channel.basicConsume(queueName, false, new MyConsumer(channel)); &#125;&#125; 123456789101112131415161718192021222324public class MyConsumer extends DefaultConsumer &#123; private Channel channel ; public MyConsumer(Channel channel) &#123; super(channel); this.channel = channel; &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;consumerTag: &quot; + consumerTag); System.err.println(&quot;envelope: &quot; + envelope); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125;&#125; 123456789101112131415161718192021222324public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_qos_exchange&quot;; String routingKey = &quot;qos.save&quot;; String msg = &quot;Hello RabbitMQ QOS Message&quot;; for(int i =0; i&lt;5; i ++)&#123; channel.basicPublish(exchange, routingKey, true, null, msg.getBytes()); &#125; &#125;&#125; message123456789101112131415161718192021222324252627282930313233343536373839public class Consumer &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 声明（创建）一个队列 String queueName = &quot;test001&quot;; channel.queueDeclare(queueName, true, false, false, null); //5 创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); //6 设置Channel channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; //7 获取消息 Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费端: &quot; + msg); Map&lt;String, Object&gt; headers = delivery.getProperties().getHeaders(); System.err.println(&quot;headers get my1 value: &quot; + headers.get(&quot;my1&quot;)); //Envelope envelope = delivery.getEnvelope(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940public class Procuder &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;(); headers.put(&quot;my1&quot;, &quot;111&quot;); headers.put(&quot;my2&quot;, &quot;222&quot;); AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .deliveryMode(2) .contentEncoding(&quot;UTF-8&quot;) .expiration(&quot;10000&quot;) .headers(headers) .build(); //4 通过Channel发送数据 for(int i=0; i &lt; 5; i++)&#123; String msg = &quot;Hello RabbitMQ!&quot;; //1 exchange 2 routingKey channel.basicPublish(&quot;&quot;, &quot;test001&quot;, properties, msg.getBytes()); &#125; //5 记得要关闭相关的连接 channel.close(); connection.close(); &#125;&#125; returnlistener12345678910111213141516171819202122232425262728293031323334public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_return_exchange&quot;; String routingKey = &quot;return.#&quot;; String queueName = &quot;test_return_queue&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); QueueingConsumer queueingConsumer = new QueueingConsumer(channel); channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费者: &quot; + msg); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_return_exchange&quot;; String routingKey = &quot;return.save&quot;; String routingKeyError = &quot;abc.save&quot;; String msg = &quot;Hello RabbitMQ Return Message&quot;; channel.addReturnListener(new ReturnListener() &#123; @Override public void handleReturn(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;---------handle return----------&quot;); System.err.println(&quot;replyCode: &quot; + replyCode); System.err.println(&quot;replyText: &quot; + replyText); System.err.println(&quot;exchange: &quot; + exchange); System.err.println(&quot;routingKey: &quot; + routingKey); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); &#125; &#125;); channel.basicPublish(exchange, routingKeyError, true, null, msg.getBytes()); //channel.basicPublish(exchange, routingKeyError, true, null, msg.getBytes());&#125;&#125;]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[千峰RabbitMQ 老师源代码]]></title>
    <url>%2F2018%2F12%2F05%2FRabbitMQ%2F%E5%8D%83%E5%B3%B0%20Rabbit%20MQ%20%E8%80%81%E5%B8%88%E6%BA%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[千峰 Rabbit MQ 老师源代码hello123456789101112131415161718192021public class Recver &#123; private final static String QUEUE = &quot;testhello&quot;;//队列的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE,false,false,false,null); QueueingConsumer consumer =new QueueingConsumer(channel);//定义一个消费者,QueueingConsumer已经过时,建议使用DefaultConsumer子类 //接收消息 ,参数2 是自动确认 channel.basicConsume(QUEUE, true, consumer); while (true) &#123; //获取消息 QueueingConsumer.Delivery delivery = consumer.nextDelivery();//如果没有消息会等待,有的话就获取执行然后销毁,是一次性的 String message = new String(delivery.getBody()); System.out.println(message); &#125; &#125;&#125; 123456789101112131415161718192021222324public class Sender &#123; private final static String QUEUE = &quot;testhello&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; //获取连接 Connection connection = ConnextionUtil.getConnection(); //创建通道 Channel channel = connection.createChannel(); //声明队列,如果队列存在则什么都不做,如果不存在才创建 // 参数1 队列的名字 //参数2 是否持久化队列,我们的队列模式是在内存中的,如果 rabbitmq 重启会丢失,如果我们设置为 true, 则会保存到 erlang 自带的数据库中,重启后会重新读取 //参数3 是否排外,有两个作用,第一个当我们的连接关闭后是否会自动删除队列,作用二 是否私有当天前队列,如果私有了,其他通道不可以访问当前队列,如果为 true, 一般是一个队列只适用于一个消费者的时候 //参数4 是够自动删除 //参数5 我们的一些其他参数 channel.queueDeclare(QUEUE, false, false, false, null); //发送内容 channel.basicPublish(&quot;&quot;,QUEUE,null,&quot;发送的消息&quot;.getBytes()); //关闭连接 channel.close(); connection.close(); &#125;&#125; persist1234567891011121314151617181920public class Recver &#123; private static String EXCHANGE_NAME = &quot;testpersist&quot;; private static String QUEUE_NAME = &quot;testpersistqueue&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;, true, false, null); //声明持久化的队列 channel.queueDeclare(QUEUE_NAME, true, false, false, null); channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,&quot;abc&quot;); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;收到消息:&quot;+new String(body)); &#125; &#125;; channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 12345678910111213141516public class Sender &#123; private static String EXCHANGE_NAME = &quot;testpersist&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); //声明持久化的交换机 channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;, true, false, null); //声明持久化消息 channel.basicPublish(EXCHANGE_NAME, &quot;abc&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, &quot;持久化的消息&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; publish123456789101112131415161718192021222324public class Recver1 &#123; private final static String EXCHANGE_NAME = &quot;testexchange&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testpubqueue1&quot;, false, false, false,null); //绑定队列到交换机 channel.queueBind(&quot;testpubqueue1&quot;, EXCHANGE_NAME, &quot;&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者11111111:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testpubqueue1&quot;, false, consumer); &#125;&#125; 1234567891011121314151617181920public class Recver2 &#123; private final static String EXCHANGE_NAME = &quot;testexchange&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testpubqueue2&quot;, false, false, false,null); //绑定队列到交换机 channel.queueBind(&quot;testpubqueue2&quot;, EXCHANGE_NAME, &quot;&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者2222222:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testpubqueue2&quot;, false, consumer); &#125;&#125; 1234567891011121314public class Sender &#123; private final static String EXCHANGE_NAME = &quot;testexchange&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);//定义一个交换机,类型是fanout,也就是发布订阅模式 //发布订阅模式的,因为消息是先发到交换机中,而交换机是没有保存功能的,所以如果没有消费者,消息会丢失 channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, &quot;发布订阅模式的消息&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; ##route 12345678910111213141516171819202122232425public class Recver1 &#123; private final static String EXCHANGE_NAME = &quot;testeoute&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testroutequeue1&quot;, false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 // 绑定队列到交换机,绑定自己的关键字 key 为key,注意在绑定到指定路由(交换机)的时候,该路由必须存在,也就是我们必须先由发送者创建一个路由才可以 channel.queueBind(&quot;testroutequeue1&quot;, EXCHANGE_NAME, &quot;key1&quot;); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind(&quot;testroutequeue1&quot;, EXCHANGE_NAME, &quot;key2&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者11111111:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testroutequeue1&quot;, false, consumer); &#125;&#125; 1234567891011121314151617181920212223public class Recver2 &#123; private final static String EXCHANGE_NAME = "testeoute";//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare("testroutequeue2", false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 channel.queueBind("testroutequeue2", EXCHANGE_NAME, "key1"); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind("testroutequeue2", EXCHANGE_NAME, "key3"); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println("消费者22222:"+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume("testroutequeue2", false, consumer); &#125;&#125; 123456789101112public class Sender &#123; private final static String EXCHANGE_NAME = &quot;testeoute&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);//定义路由格式的交换机 channel.basicPublish(EXCHANGE_NAME, &quot;key3&quot;, null, &quot;路由消息&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; ##spring 12345678910 */public class MyConsumer &#123; /** * 用于接收消息 * @param message */ public void test(String message) &#123; System.err.println(message); &#125;&#125; 12345678public class SpringTest &#123; public static void main(String[] args) throws Exception&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); RabbitTemplate template = context.getBean(RabbitTemplate.class); template.convertAndSend(&quot;spring 的消息&quot;); ((ClassPathXmlApplicationContext) context).destroy(); &#125;&#125; spring212345678@Component(&quot;confirmCallBackListener&quot;)public class ConfirmCallBackListener implements RabbitTemplate.ConfirmCallback &#123; @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; System.err.println(&quot;确认回调 ack==&quot;+ack+&quot; cause==&quot;+cause); &#125;&#125; 12345678910 @Component(&quot;publishUtil&quot;)public class PublishUtil &#123; @Autowired private AmqpTemplate amqpTemplate; public void send(String exchange, String routingkey, Object message) &#123; amqpTemplate.convertAndSend(exchange,routingkey,message ); &#125;&#125; 1234567891011121314151617181920@Component(&quot;receiveConfirmTestListener&quot;)public class ReceiveConfirmTestListener implements ChannelAwareMessageListener &#123; /** * 收到消息的时候执行的监听 * @param message * @param channel * @throws Exception */ @Override public void onMessage(Message message, Channel channel) throws Exception &#123; try &#123; System.err.println(&quot;消费者收到了消息&quot; + message); channel.basicAck(message.getMessageProperties().getDeliveryTag(),false); &#125;catch (Exception e)&#123; e.printStackTrace(); channel.basicAck(message.getMessageProperties().getDeliveryTag(),false); &#125; &#125;&#125; 12345678 @Component(&quot;returnCallBackListener&quot;)public class ReturnCallBackListener implements RabbitTemplate.ReturnCallback &#123; @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) &#123; System.err.println(&quot;失败 message==&quot;+new String(message.getBody())+&quot; replyCode==&quot;+replyCode+&quot; replyText&quot;+replyText+&quot; exchange&quot;+exchange+&quot; routingKey&quot;+routingKey); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext2.xml&quot;&#125;)public class TestMain &#123; @Autowired private PublishUtil publishUtil; private static String exChange = &quot;DIRECT_EX&quot;;//交换机 private static String queue = &quot;CONFIRM_TEST&quot;; /** * EXCHANGE QUEUE都对, confirm 会执行, ack=true * @throws Exception */ @Test public void test1() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange, queue, message); Thread.sleep(2000); &#125; /** * EXCHANGE错误 QUEUE对, confirm 会执行, ack=false * @throws Exception */ @Test public void test2() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange+&quot;!&quot;, queue, message); Thread.sleep(2000); &#125; /** * EXCHANGE对的 QUEUE错的,confirm 会执行 act=true, 失败会执行 * @throws Exception */ @Test public void test3() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange, queue+&quot;1&quot;, message); Thread.sleep(2000); &#125; /** * EXCHANGE QUEUE都是错的 confirm 会执行,但是ack=false * @throws Exception */ @Test public void test4() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange+&quot;`&quot;, queue+&quot;1&quot;, message); Thread.sleep(2000); &#125; topic123456789101112131415161718192021222324 public class Recver1 &#123; private final static String EXCHANGE_NAME = &quot;testtopic&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testtopicqueue1&quot;, false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 channel.queueBind(&quot;testtopicqueue1&quot;, EXCHANGE_NAME, &quot;key.*&quot;); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind(&quot;testtopicqueue1&quot;, EXCHANGE_NAME, &quot;abc.#&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者11111111:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testtopicqueue1&quot;, false, consumer); &#125;&#125; 1234567891011121314151617181920212223public class Recver2 &#123; private final static String EXCHANGE_NAME = &quot;testtopic&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testtopicqueue2&quot;, false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 channel.queueBind(&quot;testtopicqueue2&quot;, EXCHANGE_NAME, &quot;key.#&quot;); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind(&quot;testtopicqueue2&quot;, EXCHANGE_NAME, &quot;abc.#&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者22222:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testtopicqueue2&quot;, false, consumer); &#125;&#125; 1234567891011121314public class Sender &#123; private final static String EXCHANGE_NAME = &quot;testtopic&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange,声明为 topic 也就是通配符类型 channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;); //发送 abc.1.2数据,凡是能匹配到这个关键词的都会收到 channel.basicPublish(EXCHANGE_NAME, &quot;abc.1.2&quot;, null, &quot;topic 模式消息111&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; util123456789101112 public class ConnextionUtil &#123; public static Connection getConnection () throws Exception&#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.3.233&quot;);//设置 server 的地址 connectionFactory.setPort(5672); connectionFactory.setUsername(&quot;test&quot;); connectionFactory.setPassword(&quot;test&quot;); connectionFactory.setVirtualHost(&quot;/test&quot;); return connectionFactory.newConnection();//创建一个新的连接 &#125;&#125; work12345678910111213141516171819202122232425262728293031public class Recver1 &#123; private final static String QUEUE = &quot;testwork&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE,false,false,false,null); // 同一时刻服务器只会发一条消息给消费者,只有当前消费者将消息处理完成后才会获取到下一条消息 //注释掉后可以获取多条消息,但是会一条一条处理 channel.basicQos(1);//告诉服务器,在我们没有确认当前消息完成之前,不要给我发新的消息 DefaultConsumer consumer =new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //当我们收到消息的时候调用 System.out.println(&quot;消费者1 收到的内容是:&quot;+new String(body)); //确认 try &#123; Thread.sleep(10);//模拟耗时 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false);//参数2,false 为确认收到消息, true 为拒接收到消息 &#125; &#125;; //注册消费者, 参数2 手动确认,代表我们收到消息后需要手动告诉服务器,我收到消息了 channel.basicConsume(QUEUE,false,consumer); &#125;&#125; 1234567891011121314151617181920212223242526272829public class Recver2 &#123; private final static String QUEUE = &quot;testwork&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE,false,false,false,null); channel.basicQos(1);//告诉服务器,在我们没有确认当前消息完成之前,不要给我发新的消息 DefaultConsumer consumer =new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //当我们收到消息的时候调用 System.out.println(&quot;消费者2 收到的内容是:&quot;+new String(body)); try &#123; Thread.sleep(300);//模拟耗时 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //确认 channel.basicAck(envelope.getDeliveryTag(), false);//参数2,false 为确认收到消息, true 为拒接收到消息 &#125; &#125;; //注册消费者, 参数2 手动确认,代表我们收到消息后需要手动告诉服务器,我收到消息了 channel.basicConsume(QUEUE,false,consumer); &#125;&#125; 123456789101112131415161718192021222324252627 public class Sender &#123; private final static String QUEUE = &quot;testwork&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; //获取连接 Connection connection = ConnextionUtil.getConnection(); //创建通道 Channel channel = connection.createChannel(); //声明队列,如果队列存在则什么都不做,如果不存在才创建 // 参数1 队列的名字 //参数2 是否持久化队列,我们的队列模式是在内存中的,如果 rabbitmq 重启会丢失,如果我们设置为 true, 则会保存到 erlang 自带的数据库中,重启后会重新读取 //参数3 是否排外,有两个作用,第一个当我们的连接关闭后是否会自动删除队列,作用二 是否私有当天前队列,如果私有了,其他通道不可以访问当前队列,如果为 true, 一般是一个队列只适用于一个消费者的时候 //参数4 是够自动删除 //参数5 我们的一些其他参数 channel.queueDeclare(QUEUE, false, false, false, null); for (int i = 0; i &lt; 100; i++) &#123; //发送内容 channel.basicPublish(&quot;&quot;,QUEUE,null,(&quot;发送的消息&quot;+i).getBytes()); &#125; //关闭连接 channel.close(); connection.close(); &#125;&#125; resourceapplication.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xsi:schemaLocation="http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.7.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"&gt; &lt;!--1 定义连接工厂--&gt; &lt;rabbit:connection-factory id="connectionFactory" host="192.168.3.233" port="5672" username="test" password="test" virtual-host="/test"/&gt; &lt;!--消息是发送到交换机还是队列--&gt; &lt;!--定义 rabbitmq 的模板 queue="" 如果发送到队列则写队列 exchange="" 如果发送到交换机则写交换机 routing-key="" 定义路由的关键字 --&gt; &lt;rabbit:template id="template" connection-factory="connectionFactory" exchange="fanoutExchange" /&gt; &lt;rabbit:admin connection-factory="connectionFactory"/&gt; &lt;!--定义队列--&gt; &lt;rabbit:queue name="myQueue" auto-declare="true"/&gt; &lt;!--定义交换机--&gt; &lt;rabbit:fanout-exchange name="fanoutExchange" auto-declare="true"&gt; &lt;!--将队列绑定到交换机--&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="myQueue"&gt; &lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:fanout-exchange&gt;&lt;!--定义监听容易,当收到消息的时候会执行内部的配置--&gt; &lt;rabbit:listener-container connection-factory="connectionFactory"&gt;&lt;!--定义到底哪个类里面的什么方法用于处理收到的消息--&gt; &lt;rabbit:listener ref="consumer" method="test" queue-names="myQueue"/&gt; &lt;/rabbit:listener-container&gt; &lt;!--定义消费者--&gt; &lt;bean id="consumer" class="com.qianfeng.spring.MyConsumer"/&gt;&lt;!-- &lt;rabbit:direct-exchange name="directExchange" durable="true" auto-delete="false"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="myQueue" key="key1"&gt; &lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:direct-exchange&gt;--&gt; &lt;!-- &lt;rabbit:topic-exchange name="topicExchange" durable="true" auto-delete="false"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding pattern="dfasfsd.*" queue="myQueue"/&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:topic-exchange&gt;--&gt;&lt;/beans&gt; application2.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.7.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;context:component-scan base-package="com.qianfeng"/&gt; &lt;bean id="jsonMessageConverter" class="org.springframework.amqp.support.converter.Jackson2JsonMessageConverter" /&gt; &lt;!-- 􏰽􏰾RabbitMQ􏰙􏰆􏰇􏴜􏴡 publisher-confirms 􏰒􏵠􏱈􏱉, publisher-confirms 为 true的情况下 确认失败等回调才会执行 􏵡􏳚􏰀􏰔􏵈􏵉--&gt; &lt;rabbit:connection-factory id="connectionFactory" host="192.168.3.233" port="5672" username="test" password="test" virtual-host="/test" publisher-confirms="true" /&gt; &lt;rabbit:admin connection-factory="connectionFactory" /&gt; &lt;!-- 􏰬􏱊􏵞􏱯􏰽􏵢􏴿􏰩 --&gt;&lt;!-- mandatory􏳅􏳆􏲬􏳿true,return callback􏰶􏴟􏵣 --&gt; &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" confirm-callback="confirmCallBackListener" return-callback="returnCallBackListener" mandatory="true"/&gt; &lt;rabbit:queue name="CONFIRM_TEST" /&gt; &lt;rabbit:direct-exchange name="DIRECT_EX" id="DIRECT_EX" &gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="CONFIRM_TEST" /&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:direct-exchange&gt; &lt;!-- 􏴁􏳿consumer, 􏰿􏱀􏰙􏴛􏲇queue􏰙􏱚􏱖􏳲􏲘 --&gt; &lt;rabbit:listener-container connection-factory="connectionFactory" acknowledge="manual" &gt; &lt;rabbit:listener queues="CONFIRM_TEST" ref="receiveConfirmTestListener" /&gt;&lt;/rabbit:listener-container&gt;&lt;/beans&gt; 1234567log4j.rootLogger=DEBUG,A1log4j.logger.com.taotao = DEBUGlog4j.logger.org.mybatis = DEBUGlog4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c]-[%p] %m%n]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消费生产与消费]]></title>
    <url>%2F2018%2F12%2F05%2FRabbitMQ%2F4%E6%B6%88%E8%B4%B9%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9%2F</url>
    <content type="text"><![CDATA[1.加入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;scope&gt;3.6.5&lt;/scope&gt; &lt;/dependency&gt; 2.编码实战2.1Productor12345678910111213141516171819202122public class Procuder &#123; // 生产端Procuder http://94.191.24.33:15672/#/ public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost("94.191.24.33"); connectionFactory.setPort(15672); connectionFactory.setVirtualHost("/"); // 2.通过连接工厂创建连接connectionFactory.newConnection(); Connection connection = connectionFactory.newConnection(); // 3.通过connection创建一个Channel Channel channel = connection.createChannel(); // 4.通过Channel发送数据 String msg = "Hello RabbitMQ"; //channel.basicPublish(exchange, routingKey, props, body); channel.basicPublish("", "test001", null, msg.getBytes()); channel.close(); connection.close(); &#125; 2.2.Consumer12345678910111213141516171819202122232425262728293031323334353637public class Consumer &#123; public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory，并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost("94.191.24.33"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost("/"); // 2.通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); // 3 通过连接工厂创建连接 Channel channel = connection.createChannel(); // 4.申明（创建）一个队列 String queueName = "test001"; // channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments) channel.queueDeclare("test001", true, false, false, null); // 5.创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); /** * 6.设置channel # channel.basicConsume(queue,autoAck, autoAck) # 1：queue：队列的名字 * 2.autoAck：是否自动签收 3:autoAck：具体的消费者对象 */ channel.basicConsume(queueName, true, queueingConsumer); //7.获取消息 while (true) &#123; Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody());// 获取消息 System.out.println("消费端" + msg); &#125; &#125;&#125; 2.3 启动程序看管控台 2.4 方法的API3.一些基础]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java引用传递]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[基本数据类型（show（）方法出栈 栈里面只有成员变量）123456789101112package 引用传递;//基本数据类型参数传递public class Demo &#123; public static void main(String[] args) &#123; int x = 3; show(x);//⭐️x=3 show（）方法出栈 栈里面只有3 System.out.println("x=" + x); &#125; public static void show(int x) &#123; x = 4; &#125;&#125; 123456789101112package 引用传递;//基本数据类型参数传递public class Demo &#123; public static void main(String[] args) &#123; int x = 3; show(x);// 答案x=4 执行的是show 里面的方法 &#125; public static void show(int x) &#123; x = 4; System.out.println("x=" + x); &#125;&#125; 引用数据类型参数传递 1234567891011121314package 引用传递;//引用数据类型public class Demo2 &#123; int x = 3; public static void main(String[] args) &#123; Demo2 demo2 = new Demo2(); demo2.x=9; show(demo2);// ⭐️ x=4 System.out.println(demo2.x); &#125; public static void show(Demo2 d) &#123; d.x = 4; &#125;&#125; 总结 引用数据类型传递详解 栈内存：保存所有的对象名称 d(保存了引用堆内存空间的地址） 堆内存空间。保存具体对象的具体属性 全局数据区：保存static类型的属性 全局代码区：保存所有的方法定义 java的引用传递 同一块堆内存空间，同时被多个栈内存指向，不同的栈可以修改同一块堆内存空间的地址 123456789101112131415161718192021222324252627282930313233package 引用传递;class Demo1 &#123; private int data = 10; public Demo1() &#123; &#125; public Demo1(int data) &#123; this.data = data; &#125; public int getData() &#123; return this.data; &#125; public void setData(int data) &#123; this.data = data; &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; Demo1 demo1 = new Demo1(); fun(demo1);// System.out.println(demo1.getData());//30 &#125; public static void fun(Demo1 temp) &#123; // 接受引用 temp.setData(30);// 修改属性内容 &#125;&#125; https://blog.csdn.net/lym152898/article/details/54411956]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ管控台]]></title>
    <url>%2F2018%2F12%2F04%2FRabbitMQ%2F3.%E7%AE%A1%E6%8E%A7%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[不积跬步 无以至千里 养成写博客理解的习惯#博客在学习的时候写 看最好的视频 写做好的博客 cheerUP]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbit MQ命令总结]]></title>
    <url>%2F2018%2F12%2F04%2FRabbitMQ%2FRabbit%20MQ%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[命令总结 RabbitMQ不积跬步无以至千里1.lsof -i :5672 查看有没有启动成功 2.rabbitmq 3.rabbitmqctl list_queues 查看所有队列的名称 4.rabbitmqctl list_vhosts 5.rabbitmqctl status 查看当前节点的状态]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaSE 总结 IO 集合 线程]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1.集合]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[java反射机制完全详解#1.反射源头 —Class类 1.1 取得Class类对象 ⭐️1234567public class Demo &#123; public static void main(String[] args) &#123; Date date = new Date(); Class&lt;? extends Date&gt; class1 = date.getClass();//取得class类对象 System.out.println(class1);//class java.util.Date &#125;&#125; 12345678//利用类.class获得反射的是实例划对象public class Demo1 &#123; public static void main(String[] args) &#123; Date date = new Date(); Class&lt;? extends Date&gt; class1 = java.util.Date.class ;//取得class类对象 System.out.println(class1);//class java.util.Date &#125;&#125; 12345678//利用Class类提供的方法实例化对向public class Demo2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class&lt;?&gt; forName = Class.forName("java.util.Date"); System.out.println(forName);//class java.util.Date &#125;&#125; #2.利用反射实例化对象 2.1public T newInstacne ⭐️⭐️123456789101112131415161718public class Demo3 &#123; public Demo3() &#123; System.out.println("^^^^"); &#125; public String toString() &#123; return "######"; &#125;&#125;-------------------------------------------------------------------------------- public class Demo4 &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; class1 = Class.forName("反射.Demo3"); Object object = class1.newInstance();// 实例化对象 // Demo3 demo3=new Demo3();//调用无参构造 System.out.println(class1); System.out.println(object); &#125;&#125; 2.2。工厂设计模式 3.取得类继承结构 123456789101112131415161718192021222324252627public class Demo3 extends Object implements Serializable &#123; public Demo3() &#123; System.out.println("^^^^"); &#125; public String toString() &#123; return "######"; &#125;&#125;-------------------------------------------------------------------------------- public class Demo4 &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; class1 = Class.forName("反射.Demo3"); class1.getName();// 包名.类名 class1.getPackage();// package 包名 class1.getPackage().getName();// 包名 class1.getSimpleName();// 类名 class1.getSuperclass().getName();// 父类的包名 Class&lt;?&gt;[] icls = class1.getInterfaces();// [Ljava.lang.Class;@6bf256fa for (int i = 0; i &lt; icls.length; i++) &#123; System.out.println(icls[i].getSimpleName());//Serializable &#125; 4.反射取得构造方法（invoke） 5.反射取得方法 ⭐️⭐️⭐️ 1234567891011121314public class Demo5 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; getMethodDemo(); &#125; // 获取指定Class中的公共函数 public static void getMethodDemo() throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = Class.forName(&quot;反射.Persion&quot;); Method[] methods = clazz.getMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; System.out.println(methods[i]); &#125; &#125; 6.Invoke –]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于java的容器注解 @Bean⭐️]]></title>
    <url>%2F2018%2F12%2F04%2FSpring%2F3.java%E5%AE%B9%E5%99%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/196 后续更新 1.实战 总结]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean装配 基于xml形式]]></title>
    <url>%2F2018%2F12%2F04%2FSpring%2F5.bean%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Spring Awre 123456789public class MoocApplicationContext implements ApplicationContextAware &#123; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println("MoocApplicationContext : " + applicationContext.getBean("moocApplicationContext").hashCode()); &#125; &#125; 1234567891011121314151617public class MoocBeanName implements BeanNameAware, ApplicationContextAware &#123; private String beanName; @Override public void setBeanName(String name) &#123; this.beanName = name; System.out.println("MoocBeanName : " + name); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println("setApplicationContext : " + applicationContext.getBean(this.beanName).hashCode()); &#125;&#125; Autowiring 1234567public class AutoWiringDAO &#123; public void say(String word) &#123; System.out.println("AutoWiringDAO : " + word); &#125;&#125; 12345678910111213141516171819public class AutoWiringService &#123; private AutoWiringDAO autoWiringDAO; public AutoWiringService(AutoWiringDAO autoWiringDAO) &#123; System.out.println("AutoWiringService"); this.autoWiringDAO = autoWiringDAO; &#125; public void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) &#123; System.out.println("setAutoWiringDAO"); this.autoWiringDAO = autoWiringDAO; &#125; public void say(String word) &#123; this.autoWiringDAO.say(word); &#125;&#125; 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-autowire="constructor"&gt; &lt;bean id="autoWiringService" class="com.imooc.autowiring.AutoWiringService" &gt;&lt;/bean&gt; &lt;bean class="com.imooc.autowiring.AutoWiringDAO" &gt;&lt;/bean&gt; &lt;/beans&gt;]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP]]></title>
    <url>%2F2018%2F12%2F04%2FSpring%2F7.SpringAOP%2F</url>
    <content type="text"><![CDATA[—-]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC 及bean容器 注入]]></title>
    <url>%2F2018%2F12%2F04%2FSpring%2F1.SpringIOC%2F</url>
    <content type="text"><![CDATA[1.IOC及Bean容器 ​ 2.Spring 注入 &lt;必须要有get/set方法&gt; &lt; property name=”” ref=””&gt;⭐️ * name= 当前Bean中class所在的类的注入的属性的 成员变量名 * ref=表示引用 下一个的ID值 ** &lt;必须要有构造器方法&gt; 3.实战–IOC3.1传统的new 方式实现接口编程​ 3.2使用Bean开发 3.2 set注入1.Dao层 2.service层 3.3 构造方法注入]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbit MQ 命令行与管控台]]></title>
    <url>%2F2018%2F12%2F03%2FRabbitMQ%2F2.%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8E%E7%AE%A1%E6%8E%A7%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435rabbitmqctl stop_app：关闭应用rabbitmqctl stop_app：启动应用rabbitmqctlstatus：节点状态rabbitmqctladd_user username password：添加用户rabbitmqctllist_users：列出所有用户rabbitmqctldelete_user username：删除用户rabbitmqctl clear_permissions -p vhostpath username ：清楚用户权限rabbitmqctladd_vhost vhostpath：创建虚拟主机rabbitmqctllist_vhost：列出所有虚拟主机rabbitmqctllist_permissions -p vhostpath：列出虚拟主机所有权限rabbitmqctldelete_vhost vhostpath：删除虚拟主机rabbitmqctllist_queues：查看所有队列信息rabbitmqctl -p vhostpath purge_queue blue：清除队列里的消息rabbitmqctlreset：移除所有数据，要在rabbitmqctlstop_app之后使用rabbitmqctl join_cluster [--ram]：组成集群命令rabbitmqctlcluster_status：查看集群状态rabbitmqctlchange_cluster_node_type disc |ram：修改集群节点的存储模式rabbitmqctlforget_cluster_node_ [--offline] ：忘记节点（摘除节点）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux安装RabbitMQ]]></title>
    <url>%2F2018%2F12%2F03%2FRabbitMQ%2F1.RabbitMQ%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在基于RPM的Linux上安装（RHEL，CentOS，Fedora，openSUSE） 1.下载Erlang https://www.erlang-solutions.com/resources/download.html ❌❌❌ http://www.rabbitmq.com/releases/erlang/ ☑️☑️☑️ 2 下载RabbitMQ服务器、 # #方法一：Wget +地址方法二：在终端中输入命令: scp 待上传文件名 linux用户名@服务器IP:存放到服务器的哪个位置 :~ fa 3.安装scoket 123456789101112131415161718192021222324## RabbitMQ 参考资料慕课网老师讲义 准备：yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz下载：wget www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpmwget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpmwget www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm配置文件：vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;&quot;guest&quot;&gt;&gt;,只保留guest服务启动和停止：启动 rabbitmq-server start &amp;停止 rabbitmqctl app_stop管理插件：rabbitmq-plugins enable rabbitmq_management访问地址：http://192.168.11.76:15672/]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识RabbitMQ]]></title>
    <url>%2F2018%2F12%2F03%2FRabbitMQ%2F0.RabbitMQ%2F</url>
    <content type="text"><![CDATA[http://www.rabbitmq.com/#features 安装顺序 ：先是erlang 然后是 socat 然后是rabbitmq Linux安装：]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2F2018%2F12%2F02%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E5%B8%B8%E7%94%A8maven%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;7.0.64&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mybatis.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mybatis.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt;&lt;/dependency&gt;&lt;-- JSON 序列化工具--&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;!--&lt;scope&gt;runtime&lt;/scope&gt;--&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;20.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- id加密解密 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hashids&lt;/groupId&gt; &lt;artifactId&gt;hashids&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- ftpclient --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- file upload --&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis pager --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- alipay 阿里支付--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-configuration&lt;/groupId&gt; &lt;artifactId&gt;commons-configuration&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt;&lt;/dependency&gt;&lt;redis 客户端 jedis&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器linux awd云]]></title>
    <url>%2F2018%2F12%2F02%2FLinux%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[登录Linux云服务器浏览器 WebShell 方式登录 支持复制粘贴、中文输入法，需要开启 SSH 端口（TCP:22） 立即登录 标准登录方式 使用 Windows 系统的电脑 1、下载安装 Windows SSH 和 Telnet 客户端工具 Putty。 下载Putty 2、用户名： root，Host： 94.191.24.33 3、按照 Putty 使用帮助进行登录。 Putty 密码方式使用帮助 使用 Linux/Mac OS X 系统的电脑（使用密码登录） 1、打开 SSH 客户端（Mac可使用系统自带的终端） 2、输入 ssh -q -l root -p 22 94.191.24.33 3、输入 CVM 实例密码进行登录。 使用 Linux/Mac OS X 系统的电脑（使用密钥登录） 1、打开 SSH 客户端（Mac可使用系统自带的终端）。 2、查找您云服务器关联的 SSH 密钥文件本地存放地址。 3、您的密钥必须不公开可见，SSH 才能工作。请使用此命令： chmod 400 [密钥文件路径]。 4、输入命令： ssh [-i 密钥文件路径] root@94.191.24.33。 浏览器 VNC 方式登录 不推荐 暂不支持复制粘贴、中文输入法。 立即登录 提示：采用VNC方式登录，请务必开启 MFA 二次验证提高安全保障级别 git@gitee.com:GoodMrY/mmall_learning.git git@gitee.com:GoodMrY/mmall_learning.gitgit@gitee.com:GoodMrY/mmall_learning.gitgit@gitee.com:GoodMrY/mmall_learning.gitgit@gitee.com:GoodMrY/mmall_learning.git]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F01%2FLinux%2FLinux%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F30%2FLinux%2FLinux%E5%AE%89%E8%A3%85Tomcat%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[linux安装JDK1.7 cento7]]></title>
    <url>%2F2018%2F11%2F30%2FLinux%2FLinux%E5%AE%89%E8%A3%85JDK%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2018%2F11%2F30%2FLinux%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux SSH Mac1.下载 淘宝 用户名dongguakeji 密码dongguakeji2.mac远程访问SSH 不再sudoers文件中此事将被报告 （dongguakeji密码不能使用）–解决 使用root登陆分配权限 3.使用root登陆 远程SSH连接Linux centos7 使用root访问 关闭防火墙 11.你要改用iptables的话，需要安装iptables服务 sudo yum install iptables-services CentOS 7.0默认使用的是firewall作为防火墙，这里改为 iptables防火墙步骤。 firewall-cmd –state. #查看默认防火墙状态 （关闭后显示notrunning，开启后显示running） [root@localhost ~]#firewall-cmd –state not running 关闭防火墙： systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 4.Linux下ip设置 https://blog.csdn.net/qq_34924407/article/details/79967650. Centos7中查看IP命令：IP add https://blog.csdn.net/tuntun1120/article/details/65443757 虚拟机下CentOS7开启SSH连接 4.切换网络模式选择 然后重新编辑⭐️ 虚拟主机–&gt;网络适配器——&gt;侨界模式—&gt;复制物理网络连接转台然后重新编辑IP 变成下面这样 总结：1.先检查SSH 服务开没开 2.检查22 端口的状态 3.看网络互相通过ping看看是不是有64type的回应 4。资料在收藏夹里面 还有慕课的视频Linux]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker上传到腾讯云服务器上]]></title>
    <url>%2F2018%2F11%2F11%2FDocker%2FDocker%E4%B8%8A%E4%BC%A0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[https://cloud.tencent.com/document/product/457/9117 腾讯云 https://study.163.com/course/courseLearn.htm?courseId=1006018194#/learn/video?lessonId=1053398787&amp;courseId=1006018194 小D课堂 先选择容器服务 123sudo docker login --username=[username] ccr.ccs.tencentyun.com sudo docker login --username=100007660104 ccr.ccs.tencentyun.com 100007660104sad username:腾讯云账号，开通时已注册。输入密码后即登录完成。 ##注意 用户名 不是QQ号登陆的密码而是仓库的用户名 第一次自动生成 ####密码输入的时候先输入电脑root密码 z ###再输入密码yhp836143 12$ sudo docker tag [ImageId] ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号]$ sudo docker push ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号] 12$ sudo docker tag 5fc4ede68fcd ccr.ccs.tencentyun.com/freemana2017/atcrod:latest$ sudo docker push ccr.ccs.tencentyun.com/freemana2017/atcrod:latest 密码输入 z 因为是sudo 使用镜像—-下载镜像 小D课堂 第62讲 mac远程登陆腾讯云服务器 然后在腾讯云服务器上使用push命令拉去镜像 然后使用run命令运行镜像 最后改成公网访问镜像 登陆到腾讯云的实验室 安装Docker环境 在本机上登陆SSH 然后搭建Docker环境 ### https://cloud.tencent.com/developer/labs/lab/10054/console 在本机上远程腾讯云 搭建Docker环境 登录到镜像仓库，需输入密码。 1$ sudo docker login --username=[username] ccr.ccs.tencentyun.com 下载镜像。 sudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latest 1$ sudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latest ⭐️Docker：Cannot connect to the Docker daemon. Is the docker daemon running on this host? https://www.w3cschool.cn/kxqhmy/suzagdn1.html 查看是否存在进程： 1$ ps aux |grep docker1 停止进程 1$sudo service docker stop1 重启docker： 1$dockerd Docker在云服务器上的安装 https://www.jianshu.com/p/ea3078dae4fb 简书 1.登陆到服务器上面 通过终端 或者云主机登陆 2.开始操作 3.https://docs.docker.com/install/linux/docker-ce/centos/#uninstall-old-versions 官网 Docker的安装方式—腾讯云服务器上面 好像买的系统是Cents的 安装 CentOS 的安装 Docker：Cannot connect to the Docker daemon. Is the docker daemon running on this host? 1Docker：Cannot connect to the Docker daemon. Is the docker daemon running on this host? docker -d -p 8888：8080 先分配角色。在启动Docker 如果端口播被占用了 先关闭Docker sudo service docker stop 1sudo service docker stop 在启动Doccur service docker start 1service docker start 大佬指教。不是locaohostg 192.168.2.123 是公网ip腾讯公网的ip–118.89.28.213 加镜像名啊 兄die]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot尚硅谷 雷丰阳]]></title>
    <url>%2F2018%2F11%2F11%2FSpringBoot%2FSpring%20Boot%E5%B0%9A%E7%A1%85%E8%B0%B7%2F</url>
    <content type="text"><![CDATA[一、**Spring Boot 入门 1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； ccc 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.atguigu.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; ##4、配置文件占位符 1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ​ ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings("rawtypes")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico ​ 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== ​ Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path="/hello" view-name="success"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = "spring.messages")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="asserts/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="asserts/css/signin.css" th:href="@&#123;/asserts/css/signin.css&#125;" rel="stylesheet"&gt; &lt;/head&gt; &lt;body class="text-center"&gt; &lt;form class="form-signin" action="dashboard.html"&gt; &lt;img class="mb-4" th:src="@&#123;/asserts/img/bootstrap-solid.svg&#125;" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72"&gt; &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#&#123;login.tip&#125;"&gt;Please sign in&lt;/h1&gt; &lt;label class="sr-only" th:text="#&#123;login.username&#125;"&gt;Username&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="Username" th:placeholder="#&#123;login.username&#125;" required="" autofocus=""&gt; &lt;label class="sr-only" th:text="#&#123;login.password&#125;"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#&#123;login.password&#125;" required=""&gt; &lt;div class="checkbox mb-3"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#&#123;login.btn&#125;"&gt;Sign in&lt;/button&gt; &lt;p class="mt-5 mb-3 text-muted"&gt;© 2017-2018&lt;/p&gt; &lt;a class="btn btn-sm"&gt;中文&lt;/a&gt; &lt;a class="btn btn-sm"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = "spring.mvc", name = "locale") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter("l"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split("_"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style="color: red" th:text="$&#123;msg&#125;" th:if="$&#123;not #strings.isEmpty(msg)&#125;"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute("msg","没有权限请先登陆"); request.getRequestDispatcher("/index.html").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); registry.addViewController("/main.html").setViewName("dashboard"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**") .excludePathPatterns("/index.html","/","/user/login"); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"&gt; &lt;div class="sidebar-sticky"&gt; &lt;ul class="nav flex-column"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" th:class="$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;" href="#" th:href="@&#123;/main.html&#125;"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"&gt; &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"&gt;&lt;/path&gt; &lt;polyline points="9 22 9 12 15 12 15 22"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class="sr-only"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace="commons/bar::#sidebar(activeUri='emps')"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type="email" class="form-control" placeholder="zhangsan@atguigu.com"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action="@&#123;/emp&#125;" method="post"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name="_method";值就是我们指定的请求方式--&gt; &lt;input type="hidden" name="_method" value="put" th:if="$&#123;emp!=null&#125;"/&gt; &lt;input type="hidden" name="id" th:if="$&#123;emp!=null&#125;" th:value="$&#123;emp.id&#125;"&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="$&#123;emp!=null&#125;?$&#123;emp.email&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class="form-control" name="department.id"&gt; &lt;option th:selected="$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;" th:value="$&#123;dept.id&#125;" th:each="dept:$&#123;depts&#125;" th:text="$&#123;dept.departmentName&#125;"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" th:text="$&#123;emp!=null&#125;?'修改':'添加'"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each="emp:$&#123;emps&#125;"&gt; &lt;td th:text="$&#123;emp.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text="$&#123;emp.email&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.gender&#125;==0?'女':'男'"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.departmentName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-sm btn-primary" th:href="@&#123;/emp/&#125;+$&#123;emp.id&#125;"&gt;编辑&lt;/a&gt; &lt;button th:attr="del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;" class="btn btn-sm btn-danger deleteBtn"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(".deleteBtn").click(function()&#123; //删除当前员工的 $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put("timestamp", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value("$&#123;error.path:/error&#125;")private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = "error/" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code","user.notexist"); map.put("message",e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute("javax.servlet.error.status_code"); */ request.setAttribute("javax.servlet.error.status_code",500); map.put("code","user.notexist"); map.put("message",e.getMessage()); //转发到/error return "forward:/error"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put("company","atguigu"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir("tomcat")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the " + "configure method or add an @Configuration annotation"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql "docker-entrypoint.sh" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql "docker-entrypoint.sh" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql "docker-entrypoint.sh" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = "spring.datasource.type")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125; 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select("select * from department where id=#&#123;id&#125;") public Department getDeptById(Integer id); @Delete("delete from department where id=#&#123;id&#125;") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = "id") @Insert("insert into department(departmentName) values(#&#123;departmentName&#125;)") public int insertDept(Department department); @Update("update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;") public int updateDept(Department department);&#125; 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = "com.atguigu.springboot.mapper")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = "last_name",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println("ApplicationContextInitializer...initialize..."+applicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println("SpringApplicationRunListener...starting..."); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get("os.name"); System.out.println("SpringApplicationRunListener...environmentPrepared.."+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextPrepared..."); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextLoaded..."); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println("SpringApplicationRunListener...finished..."); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println("ApplicationRunner...run...."); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println("CommandLineRunner...run..."+ Arrays.asList(args)); &#125;&#125; 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = "atguigu.hello")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 123456789101112131415161718package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+"-" +name + helloProperties.getSuffix(); &#125;&#125; 12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker镜像加速]]></title>
    <url>%2F2018%2F11%2F11%2FDocker%2FDocker%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[emmm。。。为什么图片可以使用 网上的地址？ https://www.jianshu.com/p/94c6e44ebd3c 不要使用https前缀， 负责会提示证书错误， Version requires:- Docker for MAC version: docker version STEPS:- Open docker -&gt;preference -&gt;Daemon-&gt;basic-&gt;Registry mirrors 添加： http://registry.docker-cn.com Note：不要使用https前缀， 负责会提示证书错误， “registry-mirrors” : No certs for egitstry.docker.com 导致dockerrestart failed。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot Docker 小D课堂]]></title>
    <url>%2F2018%2F11%2F11%2FSpringBoot%2FSpringBoot-Docker-%E5%B0%8FD%E8%AF%BE%E5%A0%82%2F</url>
    <content type="text"><![CDATA[构建SpringBoot 应用docker镜像1.第1课 高级篇幅之构建SpringBoot应用docker镜像上集 官方文档：https://spring.io/guides/gs/spring-boot-docker/ 1、步骤：maven里面添加配置pom.xml 简介:使用Docker的maven插件，构建springboot应用 &lt;!--在maven最上面的申明的地方--properties--&gt; &lt;properties&gt; &lt;docker.image.prefix&gt;xdclass&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;!--项目打包的名称--&gt; &lt;finalName&gt;docker-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 配置讲解 Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。 ${project.build.finalName} 产出物名称，缺省为${project.artifactId}-${project.version} ⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ https://blog.csdn.net/TMaskBoy/article/details/82562413 高能预警 No plugin found for prefix ‘docker’ in the current project and in the plugin groups在Maven的配置文件 conf/settings.xml中添加com.spotify 12345&lt;pluginGroups&gt; &lt;pluginGroup&gt;com.spotify&lt;/pluginGroup&gt; &lt;/pluginGroups&gt;注意setting配置文件在maven的仓库里面找不到 重新更新idea中maven的插件 然后 更换.m2中conf中setting.xml的内容 #详细错误如下：om.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value (‘swarm’) 起初pom.xml中docker-maven-plugin的版本是1.0.0，使用mvn package docker:build -e构建Image出现如上异常。百般搜索无果，后来看其他的Spring Boot构建Docker镜像有用的是0.4.3，遂修改之。 解决办法 将小D课堂里面的插件 &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; 改为⭐️⭐️ 123&lt;groupId&gt;com.spotify&lt;/groupId&gt;&lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; ⭐️ //这边不是dockerfile-maven-plugin了而是docker-maven-plugin&lt;version&gt;0.4.13&lt;/version&gt; ⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ 第2课 高级篇幅之构建SpringBoot应用docker镜像下集 步骤1创建Dockerfile,默认是根目录，（可以修改为src/main/docker/Dockerfile,如果修则需要制定路径） 简介:打包SpringCloud镜像并上传私有仓库并部署 1、 什么是Dockerfile : 由一系列命令和参数构成的脚本，这些命令应用于基础镜像, 最终创建一个新的镜 像 实战 FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 参数讲解： FROM &lt;image&gt;:&lt;tag&gt; 需要一个基础镜像，可以是公共的或者是私有的， 后续构建会基于此镜像，如果同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令 VOLUME 配置一个具有持久化功能的目录，主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容 器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据 文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录 ARG 设置编译镜像时加入的参数， ENV 是设置容器的环境变量 COPY : 只支持将本地文件复制到容器 ,还有个ADD更强大但复杂点 ENTRYPOINT 容器启动时执行的命令 EXPOSE 8080 暴露镜像端口 第3课构建镜像2、构建镜像 mvn install dockerfile:build 打标签 docker tag a1b9fc71720d registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 推送到镜像仓库 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 应用服务器拉取镜像 docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 docker run -d --name xdclass_docker_demo1 -p 8099:8080 a1b9fc71720d 3、查看启动日志 docker logs -f containerid 实战1.mvn install dockerfile:build。不知道为什么终端没有用idea中终端却有用 😄哈哈 2.docker images 没有名字镜像？？注意在idea中测试的话就要用idea 不要随变改成终端 3.docker run -d –name demo -p 8080:8080 8ef42611e3b0 备注：运行镜像 –name 指定名字 -d 后台运行 8ef42611e3b0：刚刚构建的image的ID name 不会用就别用 4.docker ps 查看一下镜像的进程 ？？？没有程序。测试一下]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小D课堂SpringCloud笔记]]></title>
    <url>%2F2018%2F11%2F10%2FSpringCloud%2Fspringcloud%2F</url>
    <content type="text"><![CDATA[##SpringCloud课程笔记 第一章 课程介绍和学习路线 1、微服务架构SpringCloud课程介绍​ 简介：课程介绍和课程大纲讲解，讲课风格和重点内容理解技巧 2、技术选型和学后水平​ 简介：课程所需基础和技术选型讲解，学完课程可以到达怎样的程度，​​ 1、IDEA JDK8 Maven SpringBoot基础 Linux​​ 2、理解掌握并开发SpringCloud里面主流架构和组件的基础使用，还有部分源码原理的理解​ 3、掌握学习的技巧和解决问题的思路 第二章 架构演进和分布式系统基础知识 1、传统架构演进到分布式架构​ 简介：讲解单机应用和分布式应用架构演进基础知识 (画图) 高可用 LVS+keepalive 1、单体应用： 开发速度慢 启动时间长 依赖庞大 等等 2、微服务 易开发、理解和维护 独立的部署和启动 等 不足： 分布式系统-》分布式事务问题 需要管理多个服务-》服务治理 2、微服务核心基础讲解​ 简介：讲解微服务核心知识 ：网关、服务发现注册、配置中心、链路追踪、负载均衡器、熔断​ 1、网关：路由转发 + 过滤器​ /api/v1/pruduct/ 商品服务​ /api/v1/order/ 订单服务​ /api/v1/user/ 用户服务 2、服务注册发现：调用和被调用方的信息维护 3、配置中心：管理配置，动态更新 application.properties 4、链路追踪：分析调用链路耗时 例子：下单-》查询商品服务获取商品价格-》查询用户信息-》保存数据库 5、负载均衡器：分发负载 6、熔断：保护自己和被调用方 3、常见的微服务框架​ 简介:讲解常用的微服务框架 consumer: 调用方 provider: 被调用方 一个接口一般都会充当两个角色（不是同时充当） 1、dubbo: zookeeper + dubbo + springmvc/springboot 官方地址：http://dubbo.apache.org/#!/?lang=zh-cn 配套 通信方式：rpc 注册中心：zookeper/redis 配置中心：diamond 2、springcloud: 全家桶+轻松嵌入第三方组件(Netflix 奈飞) 官网：http://projects.spring.io/spring-cloud/ 配套 通信方式：http restful 注册中心：eruka/consul 配置中心：config 断路器：hystrix 网关：zuul 分布式追踪系统：sleuth+zipkin 学习资料：https://blog.csdn.net/zhangweiwei2020/article/details/78646252 4、微服务下电商项目基础模块设计​ 简介：微服务下电商项目基础模块设计 分离几个模块，课程围绕这个基础项目进行学习​ 小而精的方式学习微服务 1、用户服务 1）用户信息接口 2）登录接口 2、商品服务 1）商品列表 2）商品详情 3、订单服务 1）我的订单 2）下单接口 =============================================更多干货技术访问小D课堂官网 https://xdclass.net小D老师个人微信：jack794666918 公众号搜索：小D课堂第三章 SpringCloud核心组件注册中心 1、什么是微服务的注册中心​ 简介：讲解什么是注册中心，常用的注册中心有哪些 (画图)​​ 理解注册中心：服务管理,核心是有个服务注册表，心跳机制动态维护​​ 服务提供者provider: 启动的时候向注册中心上报自己的网络信息​ 服务消费者consumer: 启动的时候向注册中心上报自己的网络信息，拉取provider的相关网络信息 为什么要用： 微服务应用和机器越来越多，调用方需要知道接口的网络地址，如果靠配置文件的方式去控制网络地址，对于动态新增机器，维护带来很大问题 主流的注册中心： zookeeper、Eureka、consul、etcd 等 ​ 2、分布式应用知识CAP理论知识​ 简介：讲解分布式核心知识CAP理论 CAP定理： 指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得。 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间的数据完全一致，越多节点，数据同步越耗时） ​​ 可用性（A）：负载过大后，集群整体是否还能响应客户端的读写请求。（服务一直可用，而且是正常响应时间） 分区容错性（P）：分区容忍性，就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好） CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡 ​ 3、分布式系统CAP原理常见面试题和注册中心选择​ 简介:讲解CAP原则在面试中回答和注册中心选择 C A 满足的情况下，P不能满足的原因： 数据同步(C)需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足 CP 满足的情况下，A不能满足的原因： 数据同步(C)需要时间, 机器数量也多(P)，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足 AP 满足的情况下，C不能满足的原因： 机器数量也多(P)，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足 注册中心选择： Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足 Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化 结论：分布式系统中P,肯定要满足，所以只能在CA中二选一 没有最好的选择，最好的选择是根据业务场景来进行架构设计 如果要求一致性，则选择zookeeper，如金融行业 如果要去可用性，则Eureka，如电商系统 4、SpringCloud微服务核心组件Eureka介绍和闭源后影响​ 简介：​ SpringCloud体系介绍​ 官方地址：http://projects.spring.io/spring-cloud/ Eureka的基础知识--&gt;画图讲解交互流程，服务提供者&lt;--&gt;服务消费者 ; Eureka 2.x闭源后选择 参考：https://www.jianshu.com/p/d32ae141f680 https://blog.csdn.net/zjcjava/article/details/78608892 5、服务注册和发现Eureka Server搭建实战​ 简介：使用IDEA搭建Eureka服务中心Server端并启动，项目基本骨架介绍​​ 官方文档：http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-eureka-server​​ 第一步：创建项目​ 第二步: 添加注解 @EnableEurekaServer​ 第三步：增加配置application.yml​ server:​ port: 8761​ eureka: instance: hostname: localhost client: #声明自己是个服务端 registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 第四步：访问注册中心页面 maven地址: https://www.cnblogs.com/sword-successful/p/6408281.html 6、服务注册和发现之Eureka Client搭建商品服务实战​ 简介：搭建用商品服务，并将服务注册到注册中心 1、创建一个SpirngBoot应用，增加服务注册和发现依赖 2、模拟商品信息，存储在内存中 3、开发商品列表接口，商品详情接口 4、配置文件加入注册中心地址 使用eureka客户端 官方文档：http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#netflix-eureka-client-starter 7、Eureka服务注册中心配置控制台问题处理​ 简介：讲解服务注册中心管理后台，（后续还会细讲） 问题：eureka管理后台出现一串红色字体：是警告，说明有服务上线率低 EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. 关闭检查方法：eureka服务端配置文件加入 server: enable-self-preservation: false 注意：自我保护模式禁止关闭，默认是开启状态true ​​ 问题二：为什么只加一个注册中心地址，就可以注册​ By having spring-cloud-starter-netflix-eureka-client on the classpath, your application automatically registers with the Eureka Server. Configuration is required to locate the Eureka server, as shown in the following example: 第四章 服务消费者ribbon和feign实战和注册中心高可用 1、常用的服务间调用方式讲解​ 简介：讲解常用的服务间的调用方式 RPC: 远程过程调用，像调用本地服务(方法)一样调用服务器的服务 支持同步、异步调用 客户端和服务器之间建立TCP连接，可以一次建立一个，也可以多个调用复用一次链接 PRC数据包小 protobuf thrift rpc：编解码，序列化，链接，丢包，协议 Rest(Http): http请求，支持多种协议和功能 开发方便成本低 http数据包大 java开发：HttpClient，URLConnection 2、微服务调用方式之ribbon实战 订单调用商品服务​ 简介：实战电商项目 订单服务 调用商品服务获取商品信息​ 1、创建order_service项目​ 2、开发伪下单接口​ 3、使用ribbon. (类似httpClient,URLConnection) 启动类增加注解 @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } 4、根据名称进行调用商品，获取商品详情 3、高级篇幅之Ribbon负载均衡源码分析实战​ 简介: 讲解ribbon服务间调用负载均衡源码分析​ 1、完善下单接口​ 2、分析@LoadBalanced​ 1）首先从注册中心获取provider的列表​ 2）通过一定的策略选择其中一个节点 3）再返回给restTemplate调用 =============================================更多干货技术访问小D课堂官网 https://xdclass.net小D老师个人微信：jack794666918 公众号搜索：小D课堂4、高级篇幅之服务间调用之负载均衡策略调整实战​ 简介：实战调整默认负载均衡策略实战 自定义负载均衡策略：http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html#_customizing_the_ribbon_client_by_setting_properties 在配置文件yml里面，自定义负载均衡策略 #自定义负载均衡策略 product-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 策略选择： 1、如果每个机器配置一样，则建议不修改策略 (推荐) 2、如果部分机器配置强，则可以改为 WeightedResponseTimeRule 5、微服务调用方式之feign 实战 订单调用商品服务​ 简介：改造电商项目 订单服务 调用商品服务获取商品信息​ Feign： 伪RPC客户端(本质还是用http)​ 官方文档: https://cloud.spring.io/spring-cloud-openfeign/ 1、使用feign步骤讲解（新旧版本依赖名称不一样） 加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 启动类增加@EnableFeignClients 增加一个接口 并@FeignClient(name=&quot;product-service&quot;) 2、编码实战 3、注意点： 1、路径 2、Http方法必须对应 3、使用requestBody，应该使用@PostMapping 4、多个参数的时候，通过@RequestParam（&quot;id&quot;) int id)方式调用 6、Feign核心源码解读和服务调用方式ribbon和Feign选择​ 简介: 讲解Feign核心源码解读和 服务间的调用方式ribbon、feign选择​​ 1、ribbon和feign两个的区别和选择​ 选择feign​ 默认集成了ribbon​ 写起来更加思路清晰和方便​ 采用注解方式进行配置，配置熔断等方式方便​​ 2、超时配置​ 默认optons readtimeout是60，但是由于hystrix默认是1秒超时​ #修改调用超时时间 feign: client: config: default: connectTimeout: 2000 readTimeout: 2000 模拟接口响应慢，线程睡眠新的方式 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } 第五章 互联网架构服务降级熔断 Hystrix 实战 1、分布式核心知识之熔断、降级讲解​ 简介：系统负载过高，突发流量或者网络等各种异常情况介绍，常用的解决方案 1、熔断： 保险丝，熔断服务，为了防止整个系统故障，包含子和下游服务 下单服务 -》商品服务 -》用户服务 （出现异常-》熔断） 2、降级： 抛弃一些非核心的接口和数据 旅行箱的例子：只带核心的物品，抛弃非核心的，等有条件的时候再去携带这些物品 ​​ 3、熔断和降级互相交集​ 相同点：​ 1）从可用性和可靠性触发，为了防止系统崩溃​ 2）最终让用户体验到的是某些功能暂时不能用​​ 不同点​ 1）服务熔断一般是下游服务故障导致的，而服务降级一般是从整体系统负荷考虑，由调用方控制 2、Netflix开源组件断路器Hystrix介绍​ 简介：介绍Hystrix基础知识和使用场景​​ 文档地址：​ https://github.com/Netflix/Hystrix​ https://github.com/Netflix/Hystrix/wiki​​ 1、什么是Hystrix？​ 1）hystrix对应的中文名字是“豪猪”​ 2）hystrix 英[hɪst’rɪks] 美[hɪst’rɪks] ​​ 2、为什么要用？​ 在一个分布式系统里，一个服务依赖多个服务，可能存在某个服务调用失败，​ 比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败，​ 通过Hystrix就可以解决​​ http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients​ 3、提供了熔断、隔离、Fallback、cache、监控等功能 4、熔断后怎么处理？ 出现错误之后可以 fallback 错误的处理信息 兜底数据 3、Feign结合Hystrix断路器开发实战《上》​ 简介：讲解SpringCloud整合断路器的使用，用户服务异常情况 1、加入依赖 注意：网上新旧版本问题，所以要以官网为主，不然部分注解会丢失 最新版本 2.0 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; 2、增加注解 启动类里面增加注解 @EnableCircuitBreaker 注解越来越多-》 SpringCloudApplication注解 3、API接口编码实战 熔断-》降级 1）最外层api使用，好比异常处理（网络异常，参数或者内部调用问题） api方法上增加 @HystrixCommand(fallbackMethod = &quot;saveOrderFail&quot;) 编写fallback方法实现，方法签名一定要和api方法签名一致（注意点！！！） ​ 补充： 修改maven仓库地址 pom.xml中修改 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;/repositories&gt; 4、Feign结合Hystrix断路器开发实战《下》​ 简介：讲解SpringCloud整合断路器的使用，用户服务异常情况​ 1、feign结合Hystrix​​ 1）开启feign支持hystrix (注意，一定要开启，旧版本默认支持，新版本默认关闭)​ feign:​ hystrix:​ enabled: true​​ 2）FeignClient(name=”xxx”, fallback=xxx.class ), class需要继承当前FeignClient的类 5、熔断降级服务异常报警通知实战​ 简介：完善服务熔断处理，报警机制完善 1、加入redis依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2、配置redis链接信息 redis: database: 0 host: 127.0.0.1 port: 6379 timeout: 2000 3、使用 //监控报警 String saveOrderKye = &quot;save-order&quot;; String sendValue = redisTemplate.opsForValue().get(saveOrderKye); final String ip = request.getRemoteAddr(); new Thread( ()-&gt;{ if (StringUtils.isBlank(sendValue)) { System.out.println(&quot;紧急短信，用户下单失败，请离开查找原因,ip地址是=&quot;+ip); //发送一个http请求，调用短信服务 TODO redisTemplate.opsForValue().set(saveOrderKye, &quot;save-order-fail&quot;, 20, TimeUnit.SECONDS); }else{ System.out.println(&quot;已经发送过短信，20秒内不重复发送&quot;); } }).start(); 6、高级篇幅之深入源码剖析Hystrix降级策略和调整​ 简介：源码分析Hystrix降级策略和调整 1、查看默认讲解策略 HystrixCommandProperties 1）execution.isolation.strategy 隔离策略 THREAD 线程池隔离 （默认） SEMAPHORE 信号量 信号量适用于接口并发量高的情况，如每秒数千次调用的情况，导致的线程开销过高，通常只适用于非网络调用，执行速度快 2）execution.isolation.thread.timeoutInMilliseconds 超时时间 默认 1000毫秒 3）execution.timeout.enabled 是否开启超时限制 （一定不要禁用） 4）execution.isolation.semaphore.maxConcurrentRequests 隔离策略为 信号量的时候，如果达到最大并发数时，后续请求会被拒绝，默认是10 官方文档: https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.strategy 2、调整策略 超时时间调整 hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 4000 7、断路器Dashboard监控仪表盘实战​ 简介：讲解断路器Dashboard基础使用和查看​ 1、加入依赖​ ​ org.springframework.cloud​ spring-cloud-starter-netflix-hystrix-dashboard​ &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 2、启动类增加注解 @EnableHystrixDashboard ​​ 3、配置文件增加endpointmanagement: endpoints:​ web:​ exposure:​ include: “*” 4、访问入口 http://localhost:8781/hystrix Hystrix Dashboard输入： http://localhost:8781/actuator/hystrix.stream ​​ 参考资料​ 默认开启监控配置​ https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-actuator​​ 配置文件类：​ spring-configuration-metadata.json 8、断路器监控仪表参数讲解和模拟熔断​ 简介：讲解 断路器监控仪表盘参数和模拟熔断 1、sse server-send-event推送到前端 资料：https://github.com/Netflix/Hystrix/wiki/Dashboard 第六章 微服务网关zuul开发实战 1、微服务网关介绍和使用场景​ 简介：讲解网关的作用和使用场景 (画图)​​ 1）什么是网关​ API Gateway，是系统的唯一对外的入口，介于客户端和服务器端之间的中间层，处理非业务功能 提供路由请求、鉴权、监控、缓存、限流等功能​​ 统一接入​ 智能路由​ AB测试、灰度测试​ 负载均衡、容灾处理​ 日志埋点（类似Nignx日志）​ 流量监控 限流处理 服务降级 安全防护 鉴权处理 监控 机器网络隔离 2）主流的网关 zuul：是Netflix开源的微服务网关，和Eureka,Ribbon,Hystrix等组件配合使用，Zuul 2.0比1.0的性能提高很多 kong: 由Mashape公司开源的，基于Nginx的API gateway nginx+lua：是一个高性能的HTTP和反向代理服务器,lua是脚本语言，让Nginx执行Lua脚本，并且高并发、非阻塞的处理各种请求 2、SpringCloud的网关组件zuul基本使用​ 简介：讲解zuul网关基本使用 1、加入依赖 2、启动类加入注解 @EnableZuulProxy 默认集成断路器 @EnableCircuitBreaker 默认访问规则 http://gateway:port/service-id/** 例子：默认 /order-service/api/v1/order/save?user_id=2&amp;product_id=1 自定义 /xdclass_order/api/v1/order/save?user_id=2&amp;product_id=1 自定义路由转发： zuul: routes: order-service: /apigateway/** 环境隔离配置： 需求 ：不想让默认的服务对外暴露接口 /order-service/api/v1/order/save 配置： zuul: ignored-patterns: - /*-service/api/v1/order/save 3、高级篇幅之Zuul常用问题分析和网关过滤器原理分析 简介：讲解Zuul网关原理和过滤器生命周期， 1、路由名称定义问题 路由映射重复覆盖问题 2、Http请求头过滤问题 3、过滤器执行顺序问题 ，过滤器的order值越小，越先执行 4、共享RequestContext，上下文对象 4、自定义Zuul过滤器实现登录鉴权实战​ 简介：自定义Zuul过滤器实现登录鉴权实战 1、新建一个filter包 2、新建一个类，实现ZuulFilter，重写里面的方法 3、在类顶部加注解，@Component,让Spring扫描 5、高级篇幅之高并发情况下接口限流特技​ 简介：谷歌guava框架介绍，网关限流使用 1、nginx层限流 2、网关层限流 6、Zuul微服务网关集群搭建​ 简介：微服务网关Zull集群搭建 1、nginx+lvs+keepalive https://www.cnblogs.com/liuyisai/p/5990645.html 第七章 分布式链路追踪系统Sleuth和ZipKin实战​ 1、微服务下的链路追踪讲解和重要性 简介：讲解什么是分布式链路追踪系统，及使用好处 2、SpringCloud的链路追踪组件Sleuth实战 简介：讲解分布式链路追踪组件Sleuth实战 1、官方文档 http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#sleuth-adding-project 2、什么是Sleuth 一个组件，专门用于记录链路数据的开源组件 [order-service,96f95a0dd81fe3ab,852ef4cfcdecabf3,false] 1、第一个值，spring.application.name的值 2、第二个值，96f95a0dd81fe3ab ，sleuth生成的一个ID，叫Trace ID，用来标识一条请求链路，一条请求链路中包含一个Trace ID，多个Span ID 3、第三个值，852ef4cfcdecabf3、spanid 基本的工作单元，获取元数据，如发送一个http 4、第四个值：false，是否要将该信息输出到zipkin服务中来收集和展示。 3、添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt; &lt;/dependency&gt; 3、SpringCloud的链路追踪组件Sleuth常见问题说明 简介：讲解分布式链路追踪组件Sleuth常见问题说明 ​ 4、可视化链路追踪系统Zipkin部署 简介：讲解Zipkin的介绍和部署 1、什么是zipkin 官网：https://zipkin.io/ 大规模分布式系统的APM工具（Application Performance Management）,基于Google Dapper的基础实现，和sleuth结合可以提供可视化web界面分析调用链路耗时情况 2、同类产品 鹰眼（EagleEye） CAT twitter开源zipkin，结合sleuth Pinpoint，运用JavaAgent字节码增强技术 StackDriver Trace (Google) 3、开始使用 https://github.com/openzipkin/zipkin https://zipkin.io/pages/quickstart.html zipkin组成：Collector、Storage、Restful API、Web UI组成 4、知识拓展：OpenTracing OpenTracing 已进入 CNCF，正在为全球的分布式追踪，提供统一的概念和数据标准。 通过提供平台无关、厂商无关的 API，使得开发人员能够方便的添加（或更换）追踪系统的实现。 推荐阅读： http://blog.daocloud.io/cncf-3/ https://www.zhihu.com/question/27994350 https://yq.aliyun.com/articles/514488?utm_content=m_43347 5、高级篇幅之链路追踪组件Zipkin+Sleuth实战 简介：使用Zipkin+Sleuth业务分析调用链路分析实战 1、文档 http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_sleuth_with_zipkin_via_http sleuth收集跟踪信息通过http请求发送给zipkin server，zipkinserver进行跟踪信息的存储以及提供Rest API即可，Zipkin UI调用其API接口进行数据展示 默认存储是内存，可也用mysql、或者elasticsearch等存储 2、加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; 里面包含 spring-cloud-starter-sleuth、spring-cloud-sleuth-zipkin 3、文档说明：http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_features_2 4、配置zipkin.base-url 5、配置采样百分闭spring.sleuth.sampler 推荐资料： https://blog.csdn.net/jrn1012/article/details/77837710 =============================================更多干货技术访问小D课堂官网 https://xdclass.net小D老师个人微信：jack794666918 公众号搜索：小D课堂​第八章 微服务核心知识分布式配置中心Config实战​​ 1、微服务下的分布式配置中心​ 简介：讲解什么是配置中心及使用前后的好处 (画图)​ 什么是配置中心：​ 一句话：统一管理配置, 快速切换各个环境的配置​​ 相关产品：​ 百度的disconf​ 地址:https://github.com/knightliao/disconf​ 阿里的diamand 地址：https://github.com/takeseem/diamond springcloud的configs-server: 地址：http://cloud.spring.io/spring-cloud-config/ 推荐干货文章：http://jm.taobao.org/2016/09/28/an-article-about-config-center/ 2、SpringCloud的配置中心组件config-server实战 简介：讲解SpringCloud配置中心config-server实战 1、新建项目，创建config-server 2、启动类增加注解 @EnableConfigServer 3、使用git服务器结合Config搭建分布式配置中心 简介：讲解使用git服务器结合Config搭建分布式配置中心 1、默认使用git存储配置中心 使用git服务器，可以自己搭建gitlab服务器 或者使用github、开源中国git、阿里云git 794666918@qq.com xdclass.net123 https://gitee.com/waitforxy/config_cloud.git 2、配置文件添加配置 spring: application: name: config-server #git配置 cloud: config: server: git: uri: https://gitee.com/waitforxy/config_cloud username: 794666918@qq.com password: xdclass.net123 #超时时间 timeout: 5 #分支 default-label: master 3、访问方式（一定要注意语法，如果有问题，会出错） 多种访问路径，可以通过启动日志去查看 例子 http://localhost:9100/product-service.yml /{name}-{profiles}.properties /{name}-{profiles}.yml /{name}-{profiles}.json /{label}/{name}-{profiles}.yml name 服务器名称 profile 环境名称，开发、测试、生产 lable 仓库分支、默认master分支 4、分布式配置中心客户端使用实战​ 简介：微服务里面客户端接入配置中心实战​ 官方文档：http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html#_spring_cloud_config_client​​ 1、加入依赖​ ​ org.springframework.cloud​ spring-cloud-config-client​ ​​ 2、修改对应服务的配置文件,把application.yml 改为 bootstrap.yml​ #指定注册中心地址​ eureka:​ client:​ serviceUrl:​ defaultZone: http://localhost:8761/eureka/​ #服务的名称 spring: application: name: product-service #指定从哪个配置中心读取 cloud: config: discovery: service-id: CONFIG-SERVER enabled: true profile: test #建议用lable去区分环境，默认是lable是master分支 #label: test 注意点： 1.配置文件要用bootstrap.yml 2.默认读取文件名是 服务名称 第九章 微服务消息总线Bus结合消息队列RabbitMQ实战 1、消息总线Bus介绍和使用场景 简介：讲解消息总线Bus介绍和使用场景 1、什么是消息 一个事件，需要广播或者单独传递给某个接口 2、为什么使用这个 配置更新了，但是其他系统不知道是否更新 2、消息队列和RabbitMQ基础介绍 简介：消息队列和RabbitMQ基础介绍 1、消息队列介绍 参考：https://www.cnblogs.com/linjiqin/p/5720865.html 2、同类产品 ActiveMQ RocketMQ Kafka 等 3、SpringCloud默认推荐使用RabbitMQ 4、RabbitMQ介绍 官方文档：http://www.rabbitmq.com/getstarted.html 中文文档：http://rabbitmq.mr-ping.com/ 3、实战系列使用Docker搭建RabbitMQ3.7 简介：使用Docker安装RabbitMQ 1、如果对Docker没基础，课程后续有讲解Docker，可以先跳转过去学习Docker 2、安装步骤 1)拉取镜像：docker pull rabbitmq:management 2)查看当前镜像列表：docker images 3)删除指定镜像：docker rmi IMAGE_ID (如果需要强制删除加 -f) 4)创建容器 docker run -d --name=&quot;myrabbitmq&quot; -p 5671:5671 -p 15672:15672 rabbitmq:management 参数讲解: run: 创建一个新的容器并运行一个命令 -d: 后台运行容器，并返回容器ID -p: 端口映射，格式为：主机(宿主)端口:容器端口 --name=&quot;rabbitmq&quot;: 为容器指定一个名称 3、RabbitMQ默认创建了一个 guest 用户，密码也是 guest, 如果访问不了记得查看防火墙，端口或者云服务器的安全组 管理后台：http://127.0.0.1:15672 其他安装方式： Linux安装：https://blog.csdn.net/qq_34021712/article/details/72567786 windows安装：http://www.rabbitmq.com/install-windows.html https://blog.csdn.net/liyuejin/article/details/78410586 4、高级篇幅消息总线整合配置中心架构流程图 简介：讲解消息总线Bus结合config组件搭建配置中心项目架构图和操作流程 启动 rabbitmq： docker run -d -p 5672:5672 -p 15672:15672 rabbitmq:management rabbitmq默认是5672,所以改为5672端口 1、config-client加入依赖 &lt;!--配置中心结合消息队列--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; ​​ 官方文档：http://cloud.spring.io/spring-cloud-bus/single/spring-cloud-bus.html#_bus_refresh_endpoint​ 文档里面 暴露端点 management.endpoints.web.exposure.include=bus-refresh​​ 2、在配置文件中增加关于RabbitMQ的连接(如果是本机，则可以直接启动，采用默认连接配置)​ spring:​ rabbitmq:​ host: localhost​ port: 5672​ username: guest​ password: guest​ #暴露全部的监控信息 management: endpoints: web: exposure: include: &quot;*&quot; 3、需要刷新配置的地方，增加注解 @RefreshScope 4、访问验证 post方式： http://localhost:8773/actuator/bus-refresh 5、动态刷新配置: 在开发和测试环境使用，尽量少在生产环境使用 5、微服务相关项目改造配置中心 简介：把课程项目改造成配置中心讲解 1、git里面新增对应项目的配置文件，都要添加下面的配置 #服务的名称 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest #暴露全部的监控信息 management: endpoints: web: exposure: include: &quot;*&quot; ​​ 2、项目里面添加maven依赖​​ ​ ​ org.springframework.cloud​ spring-cloud-config-client​ ​ &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 3、修改application.properties为bootstrap.yml 并拷贝配置文件 #指定注册中心地址 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ #服务的名称 spring: application: name: order-service #指定从哪个配置中心读取 cloud: config: discovery: service-id: CONFIG-SERVER enabled: true profile: test 4、各个项目启动顺序 1）注册中心 2）配置中心 3）对应的服务：商品服务、订单服务。。。 4）启动网关 第十章、SpringCloud课程内容上半部分总结​ 1、微服务核心知识内容回顾 简介：回顾SpringCloud前面10章的基础内容 1)介绍微服务的基础知识，核心组件，CAP原理 2）SpringCloud注册中心 Eureka 3）product-service / order-service 4) 伪RPC Ribbon / feign 5) hystrix熔断 6) 服务网关介绍，zuul 7）配置中心config-server ​ 2、微服务下半部分知识 云服务器和Docker容器 简介：讲解云服务器和容器知识 ​ 第十一章 阿里云ECS服务器介绍和网络知识讲解 1、云服务器介绍和阿里云服务器ECS服务器选购 简介：什么是云服务器及目前主要的几个厂商介绍 1、阿里云、腾讯云、亚马逊云 阿里云：https://www.aliyun.com/ 腾讯云：https://cloud.tencent.com/ 亚马逊云：https://aws.amazon.com/ ​​ 2、阿里云服务器远程登录和常用工具​ 简介：讲解阿里云服务器登录使用和常见终端工具​ 1、windows工具 putty，xshell, security​ 参考资料：​ https://jingyan.baidu.com/article/e75057f210c6dcebc91a89dd.html​ https://www.jb51.net/softjc/88235.html​​ 2、苹果系统MAC： 通过终端登录​ ssh root@ip 回车后输入密码​ ssh root@120.25.1.38​ 3、可以尝试自己通过百度进行找文档， 安装mysql jdk nginx maven git redis elk 3、互联网架构知识之网站部署上线基础准备​ 简介：讲解应用部署到可以公网访问需要步骤 1、一个http请求的故事 2、什么是cname和a记录 A记录和CNAME只可以同时生效一个，A记录优先 3、域名和ip的关系，DNS作用 参考资料： https://blog.csdn.net/benbenzhuhwp/article/details/44704319 https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;ch=1&amp;tn=98050039_dg&amp;wd=%E4%B8%80%E4%B8%AAhttp%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B&amp;rsv_pq=80a65c5f00005961&amp;rsv_t=a5fcWreuJzILdSwr4gI8pFqlO7HSu5BlhjwalyVzPiV9w2L%2BKEj78pPi1Qn6Vx4wXxI&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=8&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;sug=%25E4%25B8%2580%25E4%25B8%25AAhttp%25E8%25AF%25B7%25E6%25B1%2582%25E7%259A%2584%25E8%25AF%25A6%25E7%25BB%2586%25E8%25BF%2587%25E7%25A8%258B&amp;rsv_n=1 4、域名购买和配置解析实战​ 简介：域名购买和配置解析实战 1、购买域名，备案 阿里云 备案地址：https://beian.aliyun.com/ 2、购买服务器，阿里云，腾讯云，亚马逊云aws 3、配置域名解析到服务器 ​ ​第十二章 微服务必备技能Docker容器基础篇幅​​ 1、微服务下的Docker介绍和使用场景​ 简介：Docker介绍和使用场景​​ 1、什么是Dokcer​ 百科:一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口；​ 使用go语言编写，在LCX（linux容器）基础上进行的封装 简单来说： 1）就是可以快速部署启动应用 2）实现虚拟化，完整资源隔离 3）一次编写，四处运行（有一定的限制，比如Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用） 2、为什么要用 1、提供一次性的环境，假如需要安装Mysql，则需要安装很多依赖库、版本等，如果使用Docker则通过镜像就可以直接启动运行 2、快速动态扩容，使用docker部署了一个应用，可以制作成镜像，然后通过Dokcer快速启动 3、组建微服务架构，可以在一个机器上模拟出多个微服务，启动多个应用 4、更好的资源隔离和共享 一句话：开箱即用，快速部署，可移植性强，环境隔离 2、Linux云服务器Centos7安装Docker实战 简介：讲解阿里云ECS服务安装Docker实战 Linux Standard Base的缩写，lsb_release命令用来显示LSB和特定版本的相关信息 命令： lsb_release -a 阿里云安装手册： https://help.aliyun.com/document_detail/51853.html?spm=a2c4g.11186623.6.820.RaToNY 常见问题： https://blog.csdn.net/daluguishou/article/details/52080250 3、Docker仓库、镜像、容器核心知识讲解 简介：快速掌握Dokcer基础知识， 1、概念： Docker 镜像 - Docker images： 容器运行时的只读模板，操作系统+软件运行环境+用户程序 class User{ private String userName; private int age; } Docker 容器 - Docker containers： 容器包含了某个应用运行所需要的全部环境 User user = new User() Docker 仓库 - Docker registeries： 用来保存镜像，有公有和私有仓库，好比Maven的中央仓库和本地私服 镜像仓库： （参考）配置国内镜像仓库：https://blog.csdn.net/zzy1078689276/article/details/77371782 对比面向对象的方式 Dokcer 里面的镜像 : Java里面的类 Class Docker 里面的容器 : Java里面的对象 Object 通过类创建对象，通过镜像创建容器 4、Docker容器常见命令实战 简介：讲解Docker在云服务上的实际应用 1、 常用命令（安装部署好Dokcer后，执行的命令是docker开头）,xxx是镜像名称 搜索镜像：docker search xxx 列出当前系统存在的镜像：docker images 拉取镜像：docker pull xxx xxx是具体某个镜像名称(格式 REPOSITORY:TAG) REPOSITORY：表示镜像的仓库源,TAG：镜像的标签 运行一个容器：docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 rabbitmq:management docker run - 运行一个容器 -d 后台运行 -p 端口映射 rabbitmq:management (格式 REPOSITORY:TAG)，如果不指定tag，默认使用最新的 --name &quot;xxx&quot; 列举当前运行的容器：docker ps 检查容器内部信息：docker inspect 容器名称 删除镜像：docker rmi IMAGE_NAME 强制移除镜像不管是否有容器使用该镜像 增加 -f 参数， 停止某个容器：docker stop 容器名称 启动某个容器：docker start 容器名称 移除某个容器： docker rm 容器名称 （容器必须是停止状态） 文档： https://blog.csdn.net/permike/article/details/51879578 5、实战应用之使用Docker部署Nginx服务器 简介：讲解使用Docker部署Nginx服务器实战 1、获取镜像 docker run (首先会从本地找镜像，如果有则直接启动，没有的话，从镜像仓库拉起，再启动) docker search nignx 2、列举 docker images 3、拉取 docker pull nignx 3、启动 docker run -d --name &quot;xdclass_nginx&quot; -p 8088:80 nginx docker run -d --name &quot;xdclass_nginx2&quot; -p 8089:80 nginx docker run -d --name &quot;xdclass_nginx3&quot; -p 8090:80 nginx 4、访问 如果是阿里云服务，记得配置安全组，腾讯云也需要配置，这个就是一个防火墙 6、公司中Docker镜像仓库使用讲解 简介：讲解一般公司中镜像仓库在的使用 1、为啥要用镜像仓库 2、官方公共镜像仓库和私有镜像仓库 公共镜像仓库： 官方：https://hub.docker.com/，基于各个软件开发或者有软件提供商开发的 非官方：其他组织或者公司开发的镜像，供大家免费试用 私有镜像仓库： 用于存放公司内部的镜像，不提供给外部试用； SpringCloud 开发了一个支付系统 -》做成一个镜像 （操作系统+软件运行环境+用户程序） 7、高级篇幅之构建自己的镜像仓库 简介：使用阿里云搭建自己的镜像仓库 1、阿里云镜像仓库：https://dev.aliyun.com/search.html 点击管理控制台-》初次使用会提示开通，然后设置密码 xdclass.net123 2、使用阿里云私有镜像仓库 1)登录： docker login --username=794666918@qq.com registry.cn-shenzhen.aliyuncs.com 2) 推送本地镜像： docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:[镜像版本号] 例子： docker tag 2f415b0e9a6e registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:xd_rabbitmq-v1.0.2 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:xd_rabbitmq-v1.0.2 3)拉取镜像 线上服务器拉取镜像： docker login --username=794666918@qq.com registry.cn-shenzhen.aliyuncs.com docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:xd_rabbitmq-v1.0.2 启动容器： docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 2f415b0e9a6e 第十三章 微服务高级篇幅SpringCloud和Docker整合部署​​ 第1课 高级篇幅之构建SpringBoot应用docker镜像上集​​ 简介:使用Docker的maven插件，构建springboot应用​ 官方文档：https://spring.io/guides/gs/spring-boot-docker/ 1、步骤：maven里面添加配置pom.xml &lt;properties&gt; &lt;docker.image.prefix&gt;xdclass&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;finalName&gt;docker-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 配置讲解 Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。 ${project.build.finalName} 产出物名称，缺省为${project.artifactId}-${project.version} =============================================更多干货技术访问小D课堂官网 https://xdclass.net小D老师个人微信：jack794666918 公众号搜索：小D课堂第2课 高级篇幅之构建SpringBoot应用docker镜像下集 简介:打包SpringCloud镜像并上传私有仓库并部署 1、创建Dockerfile,默认是根目录，（可以修改为src/main/docker/Dockerfile,如果修则需要制定路径） 什么是Dockerfile : 由一系列命令和参数构成的脚本，这些命令应用于基础镜像, 最终创建一个新的镜像 FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 参数讲解： FROM &lt;image&gt;:&lt;tag&gt; 需要一个基础镜像，可以是公共的或者是私有的， 后续构建会基于此镜像，如果同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令 VOLUME 配置一个具有持久化功能的目录，主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录 ARG 设置编译镜像时加入的参数， ENV 是设置容器的环境变量 COPY : 只支持将本地文件复制到容器 ,还有个ADD更强大但复杂点 ENTRYPOINT 容器启动时执行的命令 EXPOSE 8080 暴露镜像端口 2、构建镜像 mvn install dockerfile:build 打标签 docker tag a1b9fc71720d registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 推送到镜像仓库 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 应用服务器拉取镜像 docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 docker run -d --name xdclass_docker_demo1 -p 8099:8080 a1b9fc71720d 3、查看启动日志 docker logs -f containerid 文档：https://yeasy.gitbooks.io/docker_practice/image/dockerfile/ 第3课 实战系列之注册中心打包Docker镜像 简介：讲解使用Docker打包注册中心，上传私有镜像仓库并部署 1、新增maven插件 &lt;properties&gt; &lt;docker.image.prefix&gt;xdclass&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;finalName&gt;docker-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2、新建Dockerfile FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 3、打包： mvn install dockerfile:build 4、推送阿里云镜像仓库 阿里云镜像仓库：https://dev.aliyun.com/search.html docker tag 062d2ddf272a registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:eureka-v20180825docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:eureka-v20180825docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:eureka-v20180825 5、查看日志 docker logs -f containerid 第4课 实战系列之部署RabbitMQ和配置中心打包Docker镜像 简介：讲解使用Docker打包配置中心，和部署RabbitMQ 1、服务地址 ssh root@47.106.120.173 部署 rabbitmq： docker run -d -p 5672:5672 -p 15672:15672 rabbitmq:management 2、推送镜像 docker tag 0f636543904e registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180825 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180825 docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180825 5、常见问题处理之升级云服务器 简介：处理上节课出现的问题，升级服务器注意事项 1、升级云服务器配置（购买配置后需要重启机器才生效） 2、启动完成后，需要开启docker 指令： systemctl start docker 3、所有对外的都要经过网关才可以对外，应用间通信(除非跨机房)都用内网通信 6、实战系列之Docker部署Redis 简介：使用Docker安装redis 1、搜索镜像 docker search redis 2、拉取 docker pull docker.io/redis 3、启动 docker run --name &quot;xd_redis&quot; -p 6379:6379 -d 4e8db158f18d 参考： docker run --name &quot;xd_redis&quot; -p 6379:6379 -d 4e8db158f18d --requirepass &quot;123456&quot; -v $PWD/data:/data 4、访问redis容器里面，进行操作 docker exec -it 295058d2b92e redis-cli 7、生产环境常见问题之配置中心访问 简介：讲解生产环境部署常见问题，配置中心访问路径变化 1、配置中心访问出错，路径不对 解决：修改所有的注册中心，增加下面配置 instance: instance-id: ${spring.cloud.client.ip-address}:${server.port} prefer-ip-address: true docker tag 50a12cd66210 registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180826 8、实战系列之打包Docker镜像打包商品服务和订单服务、网关 简介:打包Docker镜像部署商品服务和订单服务、网关 注意： 1、maven打包构建，会触发单元测试，部分情况可以跳过， mvn install -Dmaven.test.skip=true dockerfile:build 2、生产环境不能用localhost 或者 127.0.0.1, 一定要用内网通信ip (虚拟主机映射 hosts) 9、实战系列云服务器部署网关、订单、商品服务 简介：云服务部署商品服务、订单服务、网关服务 1、拉取镜像、启动 访问路径 http://47.106.120.173:8781/api/v1/order/save?product_id=5&amp;user_id=5 http://47.106.120.173:9000/apigateway/order/api/v1/order/save?user_id=5&amp;product_id=3&amp;token=232serer 第十四章 课程总结和常见问题处理 1、SpringCloud微服务常见问题和解决思路 简介：讲解SpringCloud开发实战常见问题，及解决思路 1、技术选择：SpringCloud全家桶，每个组件又有多个替代，改怎么选择 1）选择的时候根据公司里面团队人员熟悉程度，降低学习成本 2）选择社区活跃的并且文档相对较多的，怎么判断活跃，可以看github上代码提交和start数 2、云服务选择： 腾讯云，阿里云 ，遇到问题可以提交工单，有专人跟进 ​​ 3、部署了应用，但是访问不了​ 解决思路：​ 1)查看应用启动是否正常，如果有错误日志，复制错误日志去百度搜索！！！！！！！特别重要​​ 2）启动正常，则先在本机使用 CURL “http://lcoalhost:8080/api/v1/user/find&quot; 访问对应的接口，看是否有响应​ 3）启动正常，且curl有响应，则检查是否有关闭防火墙，或者开放对应的访问端口，开放端口才可以访问 4）腾讯云和阿里云都是有安全组，类似外层防火墙，一定要去web控制台检查是否有开启端口 4、内网和外网访问，鉴权问题安全问题 1）所有应用只能通过网关提供对外访问的入口 2）应用程序之间通讯，采用内网 5、程序出错或者异常: 复制错误日志去百度搜索，网上有很多人会遇到类似的错误，多积累，特别强调 2、课程总结和后续技术规划 简介：总结SpringCloud课程和微服务后续课程规划 1、springCloud全家桶，技术选择和知识点特别多，一定要学会记笔记，微服务更多关注的是里面架构和数据流转，而不是具体的业务。 2、SpringCloud架构这些配置，一般使用一次后就不会多次修改了，进入公司主要还是开发业务，业务开发一般都用springboot，比较少让新人搭建SpringCloud的架构 3、开发业务，无非就是CRUD，增删改查，只不过是初级和高级的区别，封装成通用和不通用的区别 ​​ 4、微服务和容器盛行的情况下，容器编排和自动缩扩容越来越重要​​ 可以关注：k8s / service mesh /server less 等技术 ​​ 总结：​ 1）后续会推出对应的课程，还有项目实战系列，大家记得关注 小D课堂，官网 ：https://xdclass.net,​​ 2）也可以加我微信交流： jack794666918​ 3）购买对应的课程后，记得进我们小D课堂官方的交流群，我会在里面分享主流技术和答疑，面试经验等等，还会同步更新资料和还超级干货分享 =============================================]]></content>
  </entry>
  <entry>
    <title><![CDATA[常见问题总结]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前端向后端传值： Button 和form 1234567function goUpdatePage(id) &#123; window.location.href = "$&#123;pageContext.request.contextPath&#125;/user/editcontroller?id=" + id;&#125; &lt;button type="button" onclick="goUpdatePage($&#123;user.id&#125;)" class="btn btn-primary btn-xs"&gt; &lt;i class=" glyphicon glyphicon-pencil"&gt;&lt;/i&gt;&lt;/button&gt; 开发中service层 必须要写 @service注解 ⚠️service中不要加@service。在service的实现serviceiml中加@service注解 开发的顺序 从前端传值到Controller 再到 service 再到serviceimpl 再到userdao 再到mybatis.xml再到数据库 数据库返回前端页面 引入mybatis 的多个mapper的配置文件 mapper.xml Spring Boot 的方式 12mybatis.mapper-locations=classpath:mybatis/mapper/*.xml ###idea警告：Field injection is not recommended ####Springboot开发 Dao中UserDao RoleDao中要加 @Mapper注解 # import和open项目是不一样的 出现上面的情况要import一下啊 兄ide Caused by: org.apache.ibatis.type.TypeException: Could not resolve type alias ‘BaseResultMap’ Cause: org.apache.ibatis.builder.BuilderException: Error resolving class. Ca 看到那个resultType了么，就是它惹的祸，这里把resultType改为resultMap就OK啦，重启tomcat，木有异常啦 跳转视图 用字符串哈 开发中前端的img要放到和框架的同一目录及下面哈。兄die 1Connection connection = ConnectionUtils.getConnection(); 用类.方法（）.var 可以直接返回该对象的返回对象 Sting s=”test” 1System.out.println(s);===s.sout]]></content>
  </entry>
  <entry>
    <title><![CDATA[ITerm2的配置]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2FIterm2%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ITerm2的配置问题每次vim的时候一定要source一下 啊 xiong die 学习资源 https://www.jianshu.com/p/9c3439cc3bdb 简书 https://github.com/sirius1024/iterm2-with-oh-my-zsh Github https://www.cnblogs.com/xishuai/p/mac-iterm2.html 博客园 https://blog.csdn.net/z3512498/article/details/51245853 CSDN 改变用户名 必须要使用vim的命令修改配置 常见的命令1234vi ~/.zshrcsource ~/.zshrc （soucre配置文件 让配置文件生效）文件放在itermgit下面 必须要在主题可以使用的情况下 进行以上的配置快捷键冲突 取词 copy失效 常见问题 安装完成后，在/bin目录下会多出一个zsh的文件。 Mac系统默认使用dash作为终端，可以使用命令修改默认使用zsh： 1chsh -s /bin/zsh 如果想修改回默认dash，同样使用chsh命令即可： 1chsh -s /bin/bash export MAVEN_HOME=/Java/apache-maven-3.5.4 export PATH=${PATH}:${MAVEN_HOME}/bin]]></content>
      <tags>
        <tag>Iterm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-web]]></title>
    <url>%2F2018%2F11%2F08%2FDocker%2FDocker-web%2F</url>
    <content type="text"><![CDATA[学习地址* https://www.imooc.com/video/14624（慕课网）-6⃣刘果国 #第一个 java web项目 （SpringBoot 项目打包成一个war包的方式） 一制作自己的景象 Dockerfile docker build 首先需要一个war文件 拷贝在桌面上 Docker images 1.建立一个Dockerfile vim Dockerfile 2. 下载Tomcat镜像 网易镜像中心 找Tomcat的镜像 https://c.163yun.com/hub#/m/home/ （包括JDK Tomcat） 1docker pull hub.c.163.com/library/tomcat:latest 站在巨人的肩上 3.编辑Dockerfile1234567在Mac终端中使用vim编辑文件步骤1. cd 文件所在的文件夹路径 &lt;回車&gt;2. 輸入 vim 文件名 &lt;回車&gt;3. 按下 i 鍵來编辑文本文字4. 退出vim編輯器： 不保存并退出 &lt;ESC&gt; :q! &lt;回車&gt; 保存并退出 &lt;ESC&gt; :wq &lt;回車&gt; from hub.c.163.com/library/tomcat MAINTAINER Freemana2017 1047629166@qq.com 1234cd /Users/apple/Desktop/Dockerwebls&gt; mv atcrodfunding3_ssm-0.0.1-SNAPSHOT.war atcrod.warmv atcrodfunding3_ssm-0.0.1-SNAPSHOT.war atcrod.war (用MV 重新命名一下) 进入文件夹里面 编写Dockerfile 学会看镜像的说明 1234567891011121314151617How to use this image.Run the default Tomcat server (CMD [\&quot;catalina.sh\&quot;, \&quot;run\&quot;]):$ docker run -it --rm tomcat:8.0You can test it by visiting http://container-ip:8080 in a browser or, if you need access outside the host, on port 8888:$ docker run -it --rm -p 8888:8080 tomcat:8.0You can then go to http://localhost:8888 or http://host-ip:8888 in a browser.The default Tomcat environment in the image for versions 7 and 8 is:⭐️CATALINA_BASE: /usr/local/tomcat⭐️CATALINA_HOME: /usr/local/tomcatCATALINA_TMPDIR: /usr/local/tomcat/tempJRE_HOME: /usrCLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar 1。编写Dockerfile 文件–Dockerfile12345from hub.c.163.com/library/tomcatMAINTAINER Freemana2017 1047629166@qq.comCOPY atcrod.war /usr/local/tomcat/webapps 2.创建镜像 –docker build 3.查看镜像–docker images 4.给镜像写名字 docker build -t atcrod:latest . 5.再次查看镜像 docker images ###二运行自己的容器1.docker run -d -p 8888:8080 atcrod 8888本机的端口号。8080Tomcat的端口号 去163.com查询 atcrod镜像的名字 2.docker ps 查看Tomcat的进程 检查容器是不是启动啦 3.netstat -na|grep 8888 检查端口是不是存在了 输入localhost:8888测试Tomcat是否启动啦 ⚠️ 以上只是web项目在Docker中的部署项目3.Docker 部署SpringBoot web项目 学习资源汇总 http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html https://blog.csdn.net/weixin_39800144/article/details/79214978 https://blog.csdn.net/weixin_39800144/article/details/79213276 https://bingohuang.com/spring-boot-docker/ FROM java:8 VOLUME /tmp COPY target/tran4spd-1.0-SNAPSHOT.jar resource.jar. #这边放的是Docker部署的jar包的位置 绝对路径 RUN bash -c “touch /resource.jar” EXPOSE 8080 ENTRYPOINT [“java”,”-jar”,”resource.jar”] # docker run -d -p 18080:8099 –name docker-resource leesia/resource:1.0 注意java-jar无法运行Tomcat要外置 1234567&lt;!-- https://mvnrepository.com/artifact/javax.servlet/servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; ##文件路径不要用中文！！！]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker SpringBoot]]></title>
    <url>%2F2018%2F11%2F07%2FDocker%2FDocker-SpringBoot%2F</url>
    <content type="text"><![CDATA[DockerMachine应用注意整个过程要等待一下 参考https://study.163.com/course/courseLearn.htm?courseId=1002892012#/learn/video?lessonId=1003309140&amp;courseId=1002892012 网易云课堂 动手玩Docker 安装DockerMachine docker-machine ls tcp://192.168.99.100:2376 name：cloudcomb docker-machine create –driver virtualbox cloudcomb Docker-machine env cloudcomb ⚠️第四个变量eval说的是当前Dockermachine的名字是—cloudcomb eval $(docker-machine env cloudcomb) 拷贝放到底下 使用网易蜂巢 Docker run hub.c163.com/library/busybox:latest echon hello world （unable。。这个过程要等待啊）⭐️ docker-machine rm cloudcomb 删除docker-machine SpringBoot整合Docker Emmmm.等我有钱了 把Xnip去掉哈哈 下载源码https://github.com/bingohuang/spring-boot-docker Git 通过命令行下载文件 先cd一下指定一下下载的路径 导入项目到Idea 然后查看一下源码 运行一下项目（访问一下 测试一下） Docker SpringBoot部署项目 ⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ 1.install项目 找到这两个文件 放到桌面上 2.将这两个项目放到一个文件下，不知道为什么好像要把jar改名成gs-spring-boot-docker-0.0.1.jar 3.cd到文件下 ls一下4.执行 ˛docker version 5.执行 docker-machine env 6.执行eval $(docker-machine env)（复制后面的第四条） tcp://192.168.99.100:2376192.168.99.100 tcp://127.0.0.1:2376 tcp://127.0.0.1:2376 ###7.docker version（没有-） 8.ls一下目录 9.docker build -t cloudcomb/sun:1.0 . （桌面上要有jar包和dockerfilede 文件） 此时报错 没有gs-spring-boot-docker.jar文件 其实ls的时候就应该是gs-spring-boot-docker.jar 这儿是个bug。 解决办法 改jar包名 添加gs前缀 1https://docker.mirrors.ustc.edu.cn 10。docker build -t cloudcomb/sun:1.0 .（大佬说这一步是拉取镜像。用加速器 改名后重新执行命令）我们可以用大佬网易云的Dokcer镜像 11. docker images -a 12.docker run -p 1024:8080 -t cloudcomb/sun:1.0 . 注意 cloudcomb和前面的cloudcomb要一一对应 1024 与8080是一一对应的关系 Error: Unable to access jarfile /app.jar ⭐️ ADD user-server-0.0.1-SNAPSHOT.jar app.jar 要和pom的user-server 保持名字一样，不然maven打出来的包，docker找不到。 最终的结局办法 好像是将copy去掉了 注意看控制台打印的信息 兄dei DockerFile： Docker就是给一名字 gs-spring-bbot 贴一个Dockerfilr。 1234567891011121314151617181920212223242526272829303132333435FROM hub.c.163.com/xbingo/jdk8:latestfrom hub.c.163.com/library/tomcatMAINTAINER Freemana2017 1047629166@qq.comADD atcrodfunding3_ssm-0.0.1-SNAPSHOT.jar app.jarENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]COPY atcrod.war /usr/local/tomcat/webapps #FROM openjdk:8-jdk-alpine#VOLUME /tmp#ADD atcrodfunding3_ssm-0.0.1-SNAPSHOT.jar app.jar#ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]# #FROM hub.c.163.com/xbingo/jdk8:latest##ADD gs-spring-boot-docker-0.1.0.jar app.jar##ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] #这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:##FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载#VOLUME ，VOLUME 指向了一个/tmp的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/tmp作为工作目录。这个命令的效果是：#在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/tmp目录#ADD ，拷贝文件并且重命名#ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT#这样 Spring Boot 项目添加 Docker 依赖就完成了。 Dockerfile 用的war要有Tomcat 自己理解吧 多看一些视频笔记什么的 反正很难,,, 以上的文件是从github上拉的 现在自己构建SpringBoot -jar的应用 通过群里的指导 估计jar打包和war打包区别不大吧 下面通过SpringBoot构建Docker部署一下试试 https://waylau.com/docker-spring-boot/ http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html https://lw900925.github.io/docker/docker-springboot.html https://www.tianmaying.com/tutorial/spring-boot-docker https://bingohuang.com/spring-boot-docker/ https://www.imooc.com/search/?words=docker http://www.ityouknow.com/docker/2018/03/30/docker-machine.html https://spring.io/guides/gs/spring-boot-docker/ SpringBoot Docker https://lw900925.github.io/docker/docker-springboot.html http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html 主要环节 $ sudo docker tag [ImageId] ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号]$ sudo docker push ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号] ⭐️ sudo docker tag 5fc4ede68fcd ccr.ccs.tencentyun.com/atcrod/latest sudo docker push ccr.ccs.tencentyun.com/atcrod/latest]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-Idea]]></title>
    <url>%2F2018%2F11%2F07%2FDocker%2FDocker-Idea%2F</url>
    <content type="text"><![CDATA[###1.Docker 在Intellij中的使用 Machine的安装 compose的安装 Docker的配置 首先学习什么东西都要用官网的东西 安装Docker的插件-看网上教程 看Docker插件的官网 hrer 学习英文。任何东西官网都用详细说明的 学习Docker 学习SpringBoot整合Docker 学习运维 下面开始Docker的学习 1.现在插件 2.看网址的教程 3.安装machin和compose machine和compose的安装参考 1.Gitbook书 https://yeasy.gitbooks.io/docker_practice/content/compose/install.html 2。官方文档（为主） https://docs.docker.com/machine/install-machine/ ⭐️ （为什么每次都要重新下载dockermachine） Docker-machine env 不能执行二进制文件 首先要 重新下载Dockermachihe 123base=https://github.com/docker/machine/releases/download/v0.14.0 &amp;&amp; curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/usr/local/bin/docker-machine &amp;&amp; chmod +x /usr/local/bin/docker-machine 3.Github https://github.com/docker/machine/releases https://github.com/docker/machine 2.有些东西放在了云收藏里面Docker的用户名是2018112#####安装Docker插件要开VPN 还有访问Gitbub也要开VPN wiredes的 安装Docker要安装DookerToolBox 3.Docker ！！Docker真是一个恐怖的东西 ######Docker的学习资源GitBook里面的Docker的附录部分 https://blog.lab99.org/post/docker-2016-07-14-faq.html 1.无独有偶通过Docker-SpirngBoot的学习了解了TCP socker Engine API URL的填写 Docker开启远程访问这是过程中产生的问题 安装了socket 以后想办法删除 PS：Docker服务中进程间通信通过/var/run/docker.sock实现，默认服务不提供监听端口，因此使用docker remote api 需要手动绑定端口。方法： 12&gt; `# service docker stop``# docker -d -H unix:``///var/run/docker.sock -H tcp://0.0.0.0:2375`&gt; ###2.点击+号添加一个docker配置，输入Name和Engine API URL，URL是docker服务地址，需要docker开启远程连接功能。CentOS中在docker启动参数里添加如下配置即可开启远程连接。 -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 下面是docker在idea中的安装 clouds里面没有Docker。在Docker中配置 TCP：tcp：//127.0.0.1:2376 注意这个是通过终端命令得到的 1234567docker-machine env cloudcombexport DOCKER_TLS_VERIFY=&quot;1&quot;export DOCKER_HOST=&quot;tcp://192.168.99.101:2376&quot;export DOCKER_CERT_PATH=&quot;/Users/apple/.docker/machine/machines/cloudcomb&quot;export DOCKER_MACHINE_NAME=&quot;cloudcomb&quot;# Run this command to configure your shell:# eval $(docker-machine env cloudcomb) 将前面的端口换成本地的 tcp:127.0.0.1:2376 emm睡一觉起来VPN打开要等一会 在终端输入dockerversion docker-machine env—Host is not running #学习资源：通过Github的搜索功能🔍 发现一些学习资料https://www.jetbrains.com/help/idea/docker.html alip1sudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latest 1234567891011FROM java:8VOLUME /tmpsudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latestCOPY target/tran4spd-1.0-SNAPSHOT.jar resource.jarRUN bash -c &quot;touch /resource.jar&quot;EXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;resource.jar&quot;]# docker run -d -p 18080:8099 --name docker-resource leesia/resource:1.0]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的使用教程]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2FHexo%2F</url>
    <content type="text"><![CDATA[主题copy一份在apple中不需要终端new 或者 标题title直接复制也是可以的有时候有延迟下面就是图片的问题啦 用图床ipic解决问题 https://www.jianshu.com/p/dbc945b05d55 PIC https://sspai.com/post/39965 少数派 ### https://hexo.io/zh-cn/docs/front-matter 学习Hexo按照这个网站里面有教程 学习任何东西都要使用官方文档 其余学习的东西在safair收藏➕随笔 hexo里面 真的好累 搭建这个环境 总之就是照着官网的例子 然后使用这个模版 然后yml文件要写全 坑太多了 能出一本书 先这样]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
