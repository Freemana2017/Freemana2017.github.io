<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM圣思源]]></title>
    <url>%2F2019%2F03%2F26%2FJVM%2FJVM%E5%9C%A3%E6%80%9D%E6%BA%90%2F</url>
    <content type="text"><![CDATA[学习方法论 理解 输入输出]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx慕课网]]></title>
    <url>%2F2019%2F03%2F21%2FNginx%2FNginx%20%E6%85%95%E8%AF%BE%E7%BD%91%20%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8新特性]]></title>
    <url>%2F2019%2F03%2F20%2FJava%208%209%2011%E6%96%B0%E7%89%B9%E6%80%A7%2Fjava8%E5%B0%9A%E7%A1%85%E8%B0%B7%2F</url>
    <content type="text"><![CDATA[1.Lambda表达式 12345678List&lt;Employee&gt; employees = Arrays.asList( new Employee("w1", 213, 1), new Employee("w2", 2142, 3), new Employee("w3", 212, 2), new Employee("w4", 2123, 21), new Employee("w5", 214, 2132421), new Employee("w6", 212, 2123421) ); 12345678910111213//需求获取当前公司员工年龄大于35的员工信息 public List&lt;Employee&gt; filterEmployees(List&lt;Employee&gt; list) &#123; //申明一个list集合存放东西 List&lt;Employee&gt; emps = new ArrayList&lt;&gt;(); //2 遍历 for (Employee emp : list) &#123; if (emp.getAge() &gt;= 35) &#123; emps.add(emp); &#125; &#125; //返回回去 return emps; &#125; 1234567@Test public void test() &#123; List&lt;Employee&gt; employ = filterEmployees(employees); for (Employee employee : employ) &#123; System.out.println(employee); &#125; &#125; 123456789public List&lt;Employee&gt; filterEmployee(List&lt;Employee&gt; list, Mypredicate&lt;Employee&gt; mp) &#123; List&lt;Employee&gt; employ = new ArrayList&lt;&gt;(); for (Employee employee : list) &#123; if (mp.test(employee)) &#123; employ.add(employee); &#125; &#125; return employ; &#125; 1234public interface Mypredicate&lt;T&gt; &#123; public boolean test(T t);&#125; 12345678910111213 // 方法2 匿名内部类@Test public void teste() &#123; List&lt;Employee&gt; list = filterEmployee(employees, new Mypredicate&lt;Employee&gt;() &#123; @Override public boolean test(Employee o) &#123; return o.getSalary() &lt;= 90; &#125; &#125;); for (Employee employee : list) &#123; System.out.println(employee); &#125; &#125; 12345678//3 方法3 Lambda表达式 @Test public void t2est() &#123; List&lt;Employee&gt; employees = filterEmployee(this.employees, (e) -&gt; e.getSalary() &lt;= 90); employees.forEach(System.out::println); System.out.println("============================"); System.out.println(employees); &#125; 12345678910//优化方式4 所有的都没有 只有集合有 @Test public void test7() &#123; employees.stream().filter((e) -&gt; e.getSalary() &gt;= 90) .limit(2) .forEach(System.out::println); employees.stream().map(Employee::getName).forEach(System.out::println); &#125; 2.Labbda 表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* * 一、Lambda 表达式的基础语法：Java8中引入了一个新的操作符 "-&gt;" 该操作符称为箭头操作符或 Lambda 操作符 * 箭头操作符将 Lambda 表达式拆分成两部分： * * 左侧：Lambda 表达式的参数列表 * 右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体 * * 语法格式一：无参数，无返回值 * () -&gt; System.out.println("Hello Lambda!"); * * 语法格式二：有一个参数，并且无返回值 * (x) -&gt; System.out.println(x) * * 语法格式三：若只有一个参数，小括号可以省略不写 * x -&gt; System.out.println(x) * * 语法格式四：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句 * Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123; * System.out.println("函数式接口"); * return Integer.compare(x, y); * &#125;; * * 语法格式五：若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写 * Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y); * * 语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断” * (Integer x, Integer y) -&gt; Integer.compare(x, y); * * 上联：左右遇一括号省 * 下联：左侧推断类型省 * 横批：能省则省 * * 二、Lambda 表达式需要“函数式接口”的支持 * 函数式接口：接口中只有一个抽象方法的接口，称为函数式接口。 可以使用注解 @FunctionalInterface 修饰 * 可以检查是否是函数式接口 */public class TestLambda2 &#123; @Test public void test1()&#123; int num = 0;//jdk 1.7 前，必须是 final Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println("Hello World!" + num); &#125; &#125;; r.run(); System.out.println("-------------------------------"); Runnable r1 = () -&gt; System.out.println("Hello Lambda!"); r1.run(); &#125; @Test public void test2()&#123; Consumer&lt;String&gt; con = x -&gt; System.out.println(x); con.accept("我大尚硅谷威武！"); &#125; @Test public void test3()&#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123; System.out.println("函数式接口"); return Integer.compare(x, y); &#125;; &#125; @Test public void test4()&#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y); &#125; @Test public void test5()&#123;// String[] strs;// strs = &#123;"aaa", "bbb", "ccc"&#125;; List&lt;String&gt; list = new ArrayList&lt;&gt;(); show(new HashMap&lt;&gt;()); &#125; public void show(Map&lt;String, Integer&gt; map)&#123; &#125; //需求：对一个数进行运算 @Test public void test6()&#123; Integer num = operation(100, (x) -&gt; x * x); System.out.println(num); System.out.println(operation(200, (y) -&gt; y + 200)); &#125; public Integer operation(Integer num, MyFun mf)&#123; return mf.getValue(num); &#125;&#125; Lambda 练习12345678910111213141516171819202122232425262728293031//Lambda 表达式 练习 @Test public void test1() &#123; Collections.sort(emps, new Comparator&lt;Employee&gt;() &#123; @Override public int compare(Employee o1, Employee o2) &#123; if (o1.getAge() == o2.getAge()) &#123; return o1.getName().compareTo(o2.getName()); &#125; else &#123; return Integer.compare(o1.getAge(), o2.getAge()); &#125; &#125; &#125;); for (Employee employee : emps) &#123; System.out.println(employee + "Hello world"); &#125; &#125; @Test public void test11() &#123; Collections.sort(emps, (e1, e2) -&gt; &#123; if (e1.getAge() == e2.getAge()) &#123; return e1.getName().compareTo(e2.getName()); &#125; else &#123; return Integer.compare(e1.getAge(), e2.getAge()); &#125; &#125;); for (Employee emp : emps) &#123; System.out.println(emp); &#125; &#125; 1234567891011121314151617181920@FunctionalInterfacepublic interface MyFunction &#123; public String getValue(String str);&#125; //用于处理字符串 public String strHandler(String str, MyFunction myFunction) &#123; return myFunction.getValue(str); &#125; @Test public void testMyFunction() &#123; String s = strHandler("Hello World", (str) -&gt; str.toUpperCase()); System.out.println(s); &#125; #3.java 8四大核心内置函数式接口 https://blog.csdn.net/qq_38958113/article/details/82909615 Consumer 消费型接口12345678910//Consumer&lt;T&gt; 消费型接口 @Test public void test1() &#123; happy(20, (m) -&gt; System.out.println("消费" + m)); &#125; public void happy(double money, Consumer&lt;Double&gt; con) &#123; con.accept(money); &#125; 笔记1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * Java8 内置的四大核心函数式接口 * * Consumer&lt;T&gt; : 消费型接口 * void accept(T t); * * Supplier&lt;T&gt; : 供给型接口 * T get(); * * Function&lt;T, R&gt; : 函数型接口 * R apply(T t); * * Predicate&lt;T&gt; : 断言型接口 * boolean test(T t); * */public class TestLambda3 &#123; //Predicate&lt;T&gt; 断言型接口： @Test public void test4()&#123; List&lt;String&gt; list = Arrays.asList("Hello", "atguigu", "Lambda", "www", "ok"); List&lt;String&gt; strList = filterStr(list, (s) -&gt; s.length() &gt; 3); for (String str : strList) &#123; System.out.println(str); &#125; &#125; //需求：将满足条件的字符串，放入集合中 public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String str : list) &#123; if(pre.test(str))&#123; strList.add(str); &#125; &#125; return strList; &#125; //Function&lt;T, R&gt; 函数型接口： @Test public void test3()&#123; String newStr = strHandler("\t\t\t 我大尚硅谷威武 ", (str) -&gt; str.trim()); System.out.println(newStr); String subStr = strHandler("我大尚硅谷威武", (str) -&gt; str.substring(2, 5)); System.out.println(subStr); &#125; //需求：用于处理字符串 public String strHandler(String str, Function&lt;String, String&gt; fun)&#123; return fun.apply(str); &#125; //Supplier&lt;T&gt; 供给型接口 : @Test public void test2()&#123; List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int)(Math.random() * 100)); for (Integer num : numList) &#123; System.out.println(num); &#125; &#125; //需求：产生指定个数的整数，并放入集合中 public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; Integer n = sup.get(); list.add(n); &#125; return list; &#125; //Consumer&lt;T&gt; 消费型接口 : @Test public void test1()&#123; happy(10000, (m) -&gt; System.out.println("你们刚哥喜欢大宝剑，每次消费：" + m + "元")); &#125; public void happy(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money); &#125;&#125; 4.方法引用与构造起引用]]></content>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产者 服务端 消费者客户端]]></title>
    <url>%2F2019%2F03%2F15%2FSpringCloud%2F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Client消费端 消费端 12consumer: 调用方 消费者 客户端 client provider: 被调用方 提供者 服务端 service]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsonUtil]]></title>
    <url>%2F2019%2F03%2F15%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%F0%9F%94%A7%2FJsonUtil%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.leyou.httpdemo;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.lang.Nullable;import java.io.IOException;import java.util.List;import java.util.Map;/** * @author: HuYi.Zhang * @create: 2018-04-24 17:20 **/public class JsonUtils &#123; public static final ObjectMapper mapper = new ObjectMapper(); private static final Logger logger = LoggerFactory.getLogger(JsonUtils.class); @Nullable public static String serialize(Object obj) &#123; if (obj == null) &#123; return null; &#125; if (obj.getClass() == String.class) &#123; return (String) obj; &#125; try &#123; return mapper.writeValueAsString(obj); &#125; catch (JsonProcessingException e) &#123; logger.error("json序列化出错：" + obj, e); return null; &#125; &#125; @Nullable public static &lt;T&gt; T parse(String json, Class&lt;T&gt; tClass) &#123; try &#123; return mapper.readValue(json, tClass); &#125; catch (IOException e) &#123; logger.error("json解析出错：" + json, e); return null; &#125; &#125; @Nullable public static &lt;E&gt; List&lt;E&gt; parseList(String json, Class&lt;E&gt; eClass) &#123; try &#123; return mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, eClass)); &#125; catch (IOException e) &#123; logger.error("json解析出错：" + json, e); return null; &#125; &#125; @Nullable public static &lt;K, V&gt; Map&lt;K, V&gt; parseMap(String json, Class&lt;K&gt; kClass, Class&lt;V&gt; vClass) &#123; try &#123; return mapper.readValue(json, mapper.getTypeFactory().constructMapType(Map.class, kClass, vClass)); &#125; catch (IOException e) &#123; logger.error("json解析出错：" + json, e); return null; &#125; &#125; @Nullable public static &lt;T&gt; T nativeRead(String json, TypeReference&lt;T&gt; type) &#123; try &#123; return mapper.readValue(json, type); &#125; catch (IOException e) &#123; logger.error("json解析出错：" + json, e); return null; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HttpClient]]></title>
    <url>%2F2019%2F03%2F15%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%F0%9F%94%A7%2FHttpClient%2F</url>
    <content type="text"><![CDATA[HttpClientpom12345&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt; &lt;/dependency&gt; 123456789public class User implements Serializable &#123; private static final long serialVersionUID = 1L; private Long id; // 用户名 private String userName; // 密码 private String password; // 姓名 private String name; 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123; User user = this.restTemplate.getForObject("http://localhost/hello", User.class); System.out.println(user); &#125;&#125; 12345678910111213141516171819202122232425262728293031public class HttpTests &#123; CloseableHttpClient httpClient; @Before public void init() &#123; httpClient = HttpClients.createDefault(); &#125; @Test public void testGet() throws IOException &#123; HttpGet request = new HttpGet("http://www.baidu.com"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response); &#125; @Test public void testPost() throws IOException &#123; HttpGet request = new HttpGet("http://www.oschina.net/"); request.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response); &#125; @Test public void testGetPojo() throws IOException &#123; HttpGet request = new HttpGet("http://localhost/hello"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response); &#125;&#125; https://www.jianshu.com/p/375be5929bed —- https://www.cnblogs.com/ITtangtang/p/3968093.html https://www.cnblogs.com/bethunebtj/p/8493379.html]]></content>
      <tags>
        <tag>Utils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尚硅谷 Dubbo 雷丰阳讲义]]></title>
    <url>%2F2019%2F03%2F14%2FDubbo%2F%E5%B0%9A%E7%A1%85%E8%B0%B7%20Dubbo%20%E9%9B%B7%E4%B8%B0%E9%98%B3%E8%AE%B2%E4%B9%89%2F</url>
    <content type="text"><![CDATA[尚硅谷 Dubbo 雷丰阳讲义boot-order-service-consumer12345678910111213@Controllerpublic class OrderController &#123; @Autowired OrderService orderService; @ResponseBody @RequestMapping("/initOrder") public List&lt;UserAddress&gt; initOrder(@RequestParam("uid")String userId) &#123; return orderService.initOrder(userId); &#125;&#125; 123456789@EnableDubbo@EnableHystrix@SpringBootApplicationpublic class BootOrderServiceConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(BootOrderServiceConsumerApplication.class, args); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435/** * 1、将服务提供者注册到注册中心（暴露服务） * 1）、导入dubbo依赖（2.6.2）\操作zookeeper的客户端(curator) * 2）、配置服务提供者 * * 2、让服务消费者去注册中心订阅服务提供者的服务地址 * @author lfy * */@Servicepublic class OrderServiceImpl implements OrderService &#123; //@Autowired @Reference(loadbalance="random",timeout=1000) //dubbo直连 UserService userService; @HystrixCommand(fallbackMethod="hello") @Override public List&lt;UserAddress&gt; initOrder(String userId) &#123; // TODO Auto-generated method stub System.out.println("用户id："+userId); //1、查询用户的收货地址 List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId); return addressList; &#125; public List&lt;UserAddress&gt; hello(String userId) &#123; // TODO Auto-generated method stub return Arrays.asList(new UserAddress(10, "测试地址", "1", "测试", "测试", "Y")); &#125; &#125; 12345server.port=8081dubbo.application.name=boot-order-service-consumerdubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.monitor.protocol=registry boot-user-service-provider12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Configurationpublic class MyDubboConfig &#123; @Bean public ApplicationConfig applicationConfig() &#123; ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName("boot-user-service-provider"); return applicationConfig; &#125; //&lt;dubbo:registry protocol="zookeeper" address="127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; @Bean public RegistryConfig registryConfig() &#123; RegistryConfig registryConfig = new RegistryConfig(); registryConfig.setProtocol("zookeeper"); registryConfig.setAddress("127.0.0.1:2181"); return registryConfig; &#125; //&lt;dubbo:protocol name="dubbo" port="20882"&gt;&lt;/dubbo:protocol&gt; @Bean public ProtocolConfig protocolConfig() &#123; ProtocolConfig protocolConfig = new ProtocolConfig(); protocolConfig.setName("dubbo"); protocolConfig.setPort(20882); return protocolConfig; &#125; /** *&lt;dubbo:service interface="com.atguigu.gmall.service.UserService" ref="userServiceImpl01" timeout="1000" version="1.0.0"&gt; &lt;dubbo:method name="getUserAddressList" timeout="1000"&gt;&lt;/dubbo:method&gt; &lt;/dubbo:service&gt; */ @Bean public ServiceConfig&lt;UserService&gt; userServiceConfig(UserService userService)&#123; ServiceConfig&lt;UserService&gt; serviceConfig = new ServiceConfig&lt;&gt;(); serviceConfig.setInterface(UserService.class); serviceConfig.setRef(userService); serviceConfig.setVersion("1.0.0"); //配置每一个method的信息 MethodConfig methodConfig = new MethodConfig(); methodConfig.setName("getUserAddressList"); methodConfig.setTimeout(1000); //将method的设置关联到service配置中 List&lt;MethodConfig&gt; methods = new ArrayList&lt;&gt;(); methods.add(methodConfig); serviceConfig.setMethods(methods); //ProviderConfig //MonitorConfig return serviceConfig; &#125;&#125; 123456789101112131415161718192021222324/** * 1、导入依赖； * 1）、导入dubbo-starter * 2）、导入dubbo的其他依赖 * @author lfy * * SpringBoot与dubbo整合的三种方式： * 1）、导入dubbo-starter，在application.properties配置属性，使用@Service【暴露服务】使用@Reference【引用服务】 * 2）、保留dubbo xml配置文件; * 导入dubbo-starter，使用@ImportResource导入dubbo的配置文件即可 * 3）、使用注解API的方式： * 将每一个组件手动创建到容器中,让dubbo来扫描其他的组件 *///@EnableDubbo //开启基于注解的dubbo功能//@ImportResource(locations="classpath:provider.xml")@EnableDubbo(scanBasePackages="com.atguigu.gmall")@EnableHystrix //开启服务容错@SpringBootApplicationpublic class BootUserServiceProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(BootUserServiceProviderApplication.class, args); &#125;&#125; 1234567891011121314151617181920212223@Service//暴露服务 @Componentpublic class UserServiceImpl implements UserService &#123; @HystrixCommand @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; // TODO Auto-generated method stub System.out.println("UserServiceImpl..3....."); UserAddress address1 = new UserAddress(1, "北京市昌平区宏福科技园综合楼3层", "1", "李老师", "010-56253825", "Y"); UserAddress address2 = new UserAddress(2, "深圳市宝安区西部硅谷大厦B座3层（深圳分校）", "1", "王老师", "010-56253825", "N");// try &#123;// Thread.sleep(2000);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; if(Math.random()&gt;0.5) &#123; throw new RuntimeException(); &#125; return Arrays.asList(address1,address2); &#125;&#125; 1234567#dubbo.application.name=user-service-provider#dubbo.registry.address=127.0.0.1:2181#dubbo.registry.protocol=zookeeper#dubbo.protocol.name=dubbo##dubbo.protocol.port=20881#dubbo.monitor.protocol=registry##dubbo.scan.base-packages=com.atguigu.gmall 1dubbo.protocol.port=20882 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt; &lt;dubbo:application name=&quot;boot-user-service-provider&quot;&gt;&lt;/dubbo:application&gt; &lt;!-- 2、指定注册中心的位置 --&gt; &lt;!-- &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; --&gt; &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; &lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20882&quot;&gt;&lt;/dubbo:protocol&gt; &lt;!-- 4、暴露服务 ref：指向服务的真正的实现对象 --&gt; &lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl01&quot; timeout=&quot;1000&quot; version=&quot;1.0.0&quot;&gt; &lt;dubbo:method name=&quot;getUserAddressList&quot; timeout=&quot;1000&quot;&gt;&lt;/dubbo:method&gt; &lt;/dubbo:service&gt; &lt;!--统一设置服务提供方的规则 --&gt; &lt;dubbo:provider timeout=&quot;1000&quot;&gt;&lt;/dubbo:provider&gt; &lt;!-- 服务的实现 --&gt; &lt;bean id=&quot;userServiceImpl01&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt; &lt;!-- 连接监控中心 --&gt; &lt;dubbo:monitor protocol=&quot;registry&quot;&gt;&lt;/dubbo:monitor&gt; &lt;/beans&gt; gmall-interface12345678public class UserAddress implements Serializable &#123; private Integer id; private String userAddress; //用户地址 private String userId; //用户id private String consignee; //收货人 private String phoneNum; //电话号码 private String isDefault; //是否为默认地址 Y-是 N-否 123456789public interface OrderService &#123; /** * 初始化订单 * @param userId */ public List&lt;UserAddress&gt; initOrder(String userId);&#125; 12345678910111213 /** * 用户服务 */public interface UserService &#123; /** * 按照用户id返回所有的收货地址 * @param userId * @return */ public List&lt;UserAddress&gt; getUserAddressList(String userId);&#125; order-service-consumer1234567891011121314public class MainApplication &#123; @SuppressWarnings(&quot;resource&quot;) public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;consumer.xml&quot;); OrderService orderService = applicationContext.getBean(OrderService.class); orderService.initOrder(&quot;1&quot;); System.out.println(&quot;调用完成....&quot;); System.in.read(); &#125;&#125; 123456789101112131415161718192021222324252627/** * 1、将服务提供者注册到注册中心（暴露服务） * 1）、导入dubbo依赖（2.6.2）\操作zookeeper的客户端(curator) * 2）、配置服务提供者 * * 2、让服务消费者去注册中心订阅服务提供者的服务地址 * @author lfy * */@Servicepublic class OrderServiceImpl implements OrderService &#123; @Autowired UserService userService; @Override public List&lt;UserAddress&gt; initOrder(String userId) &#123; // TODO Auto-generated method stub System.out.println("用户id："+userId); //1、查询用户的收货地址 List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId); for (UserAddress userAddress : addressList) &#123; System.out.println(userAddress.getUserAddress()); &#125; return addressList; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;context:component-scan base-package="com.atguigu.gmall.service.impl"&gt;&lt;/context:component-scan&gt; &lt;dubbo:application name="order-service-consumer"&gt;&lt;/dubbo:application&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; &lt;!-- 配置本地存根--&gt; &lt;!--声明需要调用的远程服务的接口；生成远程服务代理 --&gt; &lt;!-- 1）、精确优先 (方法级优先，接口级次之，全局配置再次之) 2）、消费者设置优先(如果级别一样，则消费方优先，提供方次之) --&gt; &lt;!-- timeout="0" 默认是1000ms--&gt; &lt;!-- retries="":重试次数，不包含第一次调用，0代表不重试--&gt; &lt;!-- 幂等（设置重试次数）【查询、删除、修改】、非幂等（不能设置重试次数）【新增】 --&gt; &lt;dubbo:reference interface="com.atguigu.gmall.service.UserService" id="userService" timeout="5000" retries="3" version="*"&gt; &lt;!-- &lt;dubbo:method name="getUserAddressList" timeout="1000"&gt;&lt;/dubbo:method&gt; --&gt; &lt;/dubbo:reference&gt; &lt;!-- 配置当前消费者的统一规则：所有的服务都不检查 --&gt; &lt;dubbo:consumer check="false" timeout="5000"&gt;&lt;/dubbo:consumer&gt; &lt;dubbo:monitor protocol="registry"&gt;&lt;/dubbo:monitor&gt; &lt;!-- &lt;dubbo:monitor address="127.0.0.1:7070"&gt;&lt;/dubbo:monitor&gt; --&gt; &lt;/beans&gt; user-service-provider12345678910111213141516171819public class UserServiceImpl implements UserService &#123; @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; System.out.println(&quot;UserServiceImpl.....old...&quot;); // TODO Auto-generated method stub UserAddress address1 = new UserAddress(1, &quot;北京市昌平区宏福科技园综合楼3层&quot;, &quot;1&quot;, &quot;李老师&quot;, &quot;010-56253825&quot;, &quot;Y&quot;); UserAddress address2 = new UserAddress(2, &quot;深圳市宝安区西部硅谷大厦B座3层（深圳分校）&quot;, &quot;1&quot;, &quot;王老师&quot;, &quot;010-56253825&quot;, &quot;N&quot;); /*try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;*/ return Arrays.asList(address1,address2); &#125;&#125; 12345678910111213public class UserServiceImpl2 implements UserService &#123; @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; System.out.println(&quot;UserServiceImpl.....new...&quot;); // TODO Auto-generated method stub UserAddress address1 = new UserAddress(1, &quot;北京市昌平区宏福科技园综合楼3层&quot;, &quot;1&quot;, &quot;李老师&quot;, &quot;010-56253825&quot;, &quot;Y&quot;); UserAddress address2 = new UserAddress(2, &quot;深圳市宝安区西部硅谷大厦B座3层（深圳分校）&quot;, &quot;1&quot;, &quot;王老师&quot;, &quot;010-56253825&quot;, &quot;N&quot;); return Arrays.asList(address1,address2); &#125;&#125; 1234567891011121314151617181920212223public class UserServiceStub implements UserService &#123; private final UserService userService&#123; /* * 传入的是userService远程的代理对象 * @param userService */ public UserServiceStub(UserService userService) &#123; super(); this.userService = userService; &#125; @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; // TODO Auto-generated method stub System.out.println(&quot;UserServiceStub.....&quot;); if(!StringUtils.isEmpty(userId)) &#123; return userService.getUserAddressList(userId); &#125; return null; &#125;&#125; 12345678910public class MainApplication &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;); ioc.start(); System.in.read(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt; &lt;dubbo:application name=&quot;user-service-provider&quot;&gt;&lt;/dubbo:application&gt; &lt;!-- 2、指定注册中心的位置 --&gt; &lt;!-- &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; --&gt; &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; &lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20882&quot;&gt;&lt;/dubbo:protocol&gt; &lt;!-- 4、暴露服务 ref：指向服务的真正的实现对象 --&gt; &lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl01&quot; timeout=&quot;1000&quot; version=&quot;1.0.0&quot;&gt; &lt;dubbo:method name=&quot;getUserAddressList&quot; timeout=&quot;1000&quot;&gt;&lt;/dubbo:method&gt; &lt;/dubbo:service&gt; &lt;!--统一设置服务提供方的规则 --&gt; &lt;dubbo:provider timeout=&quot;1000&quot;&gt;&lt;/dubbo:provider&gt; &lt;!-- 服务的实现 --&gt; &lt;bean id=&quot;userServiceImpl01&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt; &lt;dubbo:service interface=&quot;com.atguigu.gmall.service.UserService&quot; ref=&quot;userServiceImpl02&quot; timeout=&quot;1000&quot; version=&quot;2.0.0&quot;&gt; &lt;dubbo:method name=&quot;getUserAddressList&quot; timeout=&quot;1000&quot;&gt;&lt;/dubbo:method&gt; &lt;/dubbo:service&gt; &lt;bean id=&quot;userServiceImpl02&quot; class=&quot;com.atguigu.gmall.service.impl.UserServiceImpl2&quot;&gt;&lt;/bean&gt; &lt;!-- 连接监控中心 --&gt; &lt;dubbo:monitor protocol=&quot;registry&quot;&gt;&lt;/dubbo:monitor&gt; &lt;/beans&gt;]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F14%2FDubbo%2FDubbo%E5%B0%9A%E7%A1%85%E8%B0%B7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%89%8D%E7%AB%AF%2FJson%2F</url>
    <content type="text"><![CDATA[—-]]></content>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F12%2FDubbo%2FSpringBoot-Dubbo%E2%80%94Demo%2F</url>
    <content type="text"><![CDATA[1 Zookeeper的下载 与配置Mac上的安装与配置1 安装JDK配置环境12345export ZOOKEEPER_HOME=/root/zookeeper-3.4.10export CLASSPATH=.:%JAVA_HOME%/lib/dt.jar:%JAVA_HOME%/lib/tools.jarexport JAVA_HOME=/root/jdk1.8.0_201export PATH=$PATH:$JAVA_HOME/binexport PATH=$PATH:$ZOOKEEPER_HOME/bin:$JAVA_HOME/bin 2 安装zookeeper 3.更改配置文件123cp zooxxx.cfg zoo.cfg mkdir dataDir 4启动与暂停 123456789 /zookeeper-3.5.4-beta/bin  ./zkServer.sh start⭐️ ⭐️ ⭐️⭐️ ⭐️ ⭐️ZooKeeper JMX enabled by defaultUsing config: /zookeeper-3.5.4-beta/bin/../conf/zoo.cfgStarting zookeeper ... STARTED /zookeeper-3.5.4-beta/bin  ./zkServer.sh status ⭐️ ⭐️ ⭐️ZooKeeper JMX enabled by defaultUsing config: /zookeeper-3.5.4-beta/bin/../conf/zoo.cfgClient port found: 2181. Client address: localhost.Mode: standalone 2]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot Maven工程搭建]]></title>
    <url>%2F2019%2F03%2F12%2FGit%20Maven%20%2FSpringBoot%20Maven%E8%81%9A%E5%90%88%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SpringBoot 整合Maven聚合工程 springboot-dubbo-parent/pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springboot-dubbo-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; //1 ⭐️⭐️⭐️⭐️⭐️pom⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;springboot-dubbo-parent&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; //2 ⭐️⭐️⭐️⭐️⭐️⭐️&lt;modules&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;modules&gt; &lt;module&gt;springboot-dubbo-server&lt;/module&gt; &lt;module&gt;springboot-dubbo-client&lt;/module&gt; &lt;/modules&gt; //3 ⭐️⭐️⭐️⭐️⭐️⭐️&lt;properties&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- 在properties中统一控制依赖包的版本，更清晰--&gt; &lt;dubbo.version&gt;2.5.3&lt;/dubbo.version&gt; &lt;zk.version&gt;3.4.5&lt;/zk.version&gt; &lt;zkclient.version&gt;0.1&lt;/zkclient.version&gt; &lt;/properties&gt; //4 ⭐️⭐️⭐️⭐️⭐️⭐️&lt;properties&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;dependencyManagement&gt; &lt;!--dependencyManagement用于管理依赖版本号--&gt; &lt;dependencies&gt; &lt;!--删除spring-boot-starter和spring-boot-starter-test，--&gt; &lt;!--因为parent中继承的祖先中已经有了，并且一般dependencyManagement管理的依赖都要写版本号--&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--新增后续dubbo项目中所需依赖，dubbo、zk--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;&lt;!--使用properties中配置的版本号--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;zk.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; springvoot-dubbo-client/pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springboot-dubbo-client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; //1 ⭐️⭐️⭐️⭐️⭐️⭐️jar⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springboot-dubbo-client&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; //2 ⭐️⭐️⭐️⭐️⭐️⭐️&lt;parent&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springboot-dubbo-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; //3 ⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;!--新增后续dubbo项目中所需依赖，dubbo、zk。 父模块pom中使用dependencyManagement来管理依赖版本号，子模块pom中不需要再写版本号，exclusion也不需要--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springboot-dubbo-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F2019%2F03%2F12%2FGit%20Maven%20%2FMaven%2F</url>
    <content type="text"><![CDATA[1parent 为父模块，抽象出来管理子项目的公共依赖，为了项目的正确运行，必须让所有的子项目使用依赖项的统一版本，必须确保应用的各个项目的依赖项和版本一致，才能保证测试的和发布的是相同的结果。 123dependencyManagement在项目的 parent 层，可以通过 dependencyManagement 元素来管理 jar 包的版本，让子项目中引用一个依赖而不用显示的列出版本号。 parent 中 pom.xml 12345678910111213141516171819&lt;properties&gt; &lt;version.framework&gt;1.0-SNAPSHOT&lt;/version.framework&gt; &lt;javaee-api.version&gt;1.0-SNAPSHOT&lt;/javaee-api.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt;//=================framework-cache &lt;groupId&gt;com.zhisheng&lt;/groupId&gt; &lt;artifactId&gt;framework-cache&lt;/artifactId&gt; &lt;version&gt;$&#123;version.framework&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; //===============javax &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javaee-api.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; extendion 中的 pom.xml 123456789101112131415161718192021&lt;parent&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;groupId&gt;com.zhisheng&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt;&lt;!--依赖关系--&gt; &lt;dependencies&gt; &lt;dependency&gt; // =============javax &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;// ===============framework-cache &lt;groupId&gt;com.zhisheng&lt;/groupId&gt; &lt;artifactId&gt;framework-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1234区别dependencies 即使在子项目中不写该依赖项，那么子项目仍然会从父项目中继承该依赖项（全部继承）dependencyManagement 里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且 version 和 scope 都读取自父 pom; 另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。 示例说明， 在父模块中： 123456789&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt;//=====================&gt;mysql &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.44&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 那么在子模块中只需要和即可，如： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 说明：使用dependencyManagement可以统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，不用每个模块项目都弄一个版本号，不利于管理，当需要变更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块dependencies中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。 与dependencies区别： 1)Dependencies相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。2)dependencyManagement里只是声明依赖，并不自动实现引入，因此子项目需要显示的声明需要用的依赖。⭐️⭐️⭐️⭐️如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。 https://www.imooc.com/video/8651 xxxxxxxxxx 1​23 &lt;version.framework&gt;1.0-SNAPSHOT&lt;/version.framework&gt;4 &lt;javaee-api.version&gt;1.0-SNAPSHOT&lt;/javaee-api.version&gt;567 8 //=================framework-cache9 com.zhisheng10 framework-cache11 ${version.framework}12 13 //===============javax14 javax 15 javaee-api 16 ${javaee-api.version} 17 18 19xml Maven聚合和继承即使是长期从事 Maven 工作的开发人员也不能完全掌握聚合（多模块）和 Parent 继承的关系，在使用多模块时，子模块总要指定聚合的 pom 为 。由于在大多数示例中都是这么写的，所以很难让人搞懂这两者的具体作用和关系。 实际上在 Maven 中聚合（多模块）和继承是两回事，两者不存在直接联系 1dependencyManagement2在项目的 parent 层，可以通过 dependencyManagement 元素来管理 jar 包的版本，3让子项目中引用一个依赖而不用显示的列出版本号。]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2小时带你实战Dubbo分布式服务调度]]></title>
    <url>%2F2019%2F03%2F12%2FDubbo%2FDubbo%E6%85%95%E8%AF%BE%E7%BD%91%2F</url>
    <content type="text"><![CDATA[1 Dubbo概念 2 搭建微服务SpringBoot多模块项目1.POMdubboone.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; //==&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;modules&gt; &lt;module&gt;dubboone-api&lt;/module&gt; &lt;module&gt;dubboone-modle&lt;/module&gt; &lt;module&gt;dubboone-server&lt;/module&gt; &lt;/modules&gt; &lt;groupId&gt;com.dubboOne&lt;/groupId&gt; &lt;artifactId&gt;dubboone&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;dubboone&lt;/name&gt; //==&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;packaging&gt;pom&lt;/packaging&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; dubboone-api123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; //==&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;parent&gt; &lt;groupId&gt;com.dubboOne&lt;/groupId&gt; &lt;artifactId&gt;dubboone&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.dubboOne.api&lt;/groupId&gt; &lt;artifactId&gt;dubboone-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; //==&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;dubboone-api&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mybatis-pagehelper.version&gt;4.1.2&lt;/mybatis-pagehelper.version&gt; &lt;lombok.version&gt;1.16.10&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--java校验 跟 hibernate校验--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;1.1.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.3.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!--for page--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-pagehelper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--//SpringBoot的依赖配置--&gt;&lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; dubbo-modle1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; //==&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;parent&gt; &lt;groupId&gt;com.dubboOne&lt;/groupId&gt; &lt;artifactId&gt;dubboone&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.dubboone.modle&lt;/groupId&gt; &lt;artifactId&gt;dubboone-modle&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;dubboone-modle&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mybatis-spring-boot.version&gt;1.1.1&lt;/mybatis-spring-boot.version&gt; &lt;mybatis-pagehelper.version&gt;4.1.2&lt;/mybatis-pagehelper.version&gt; &lt;/properties&gt; &lt;dependencies&gt; //==&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;!--api--&gt; &lt;dependency&gt; &lt;groupId&gt;com.dubboOne.api&lt;/groupId&gt; &lt;artifactId&gt;dubboone-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring-mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring-boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; dubboone-server123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; //==&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;parent&gt; &lt;groupId&gt;com.dubboOne&lt;/groupId&gt; &lt;artifactId&gt;dubboone&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.dubboone.server&lt;/groupId&gt; &lt;artifactId&gt;dubboone-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;dubboone-server&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;start-class&gt;com.debug.mooc.dubbo.one.server.BootMoreApplication&lt;/start-class&gt; &lt;!--&lt;spring-boot.version&gt;1.3.3.RELEASE&lt;/spring-boot.version&gt;--&gt; &lt;spring-boot.version&gt;2.0.5.RELEASE&lt;/spring-boot.version&gt; &lt;spring-session.version&gt;1.2.0.RELEASE&lt;/spring-session.version&gt; &lt;slf4j.version&gt;1.7.13&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.37&lt;/mysql.version&gt; &lt;druid.version&gt;1.0.16&lt;/druid.version&gt; &lt;guava.version&gt;19.0&lt;/guava.version&gt; &lt;joda-time.version&gt;2.9.2&lt;/joda-time.version&gt; &lt;cglib.version&gt;3.1&lt;/cglib.version&gt; &lt;zookeeper.version&gt;3.4.10&lt;/zookeeper.version&gt; &lt;curator.version&gt;2.12.0&lt;/curator.version&gt; &lt;resteasy.version&gt;3.0.7.Final&lt;/resteasy.version&gt; &lt;okhttp.version&gt;3.1.2&lt;/okhttp.version&gt; &lt;gson.version&gt;2.6.1&lt;/gson.version&gt; &lt;httpclient.version&gt;4.3.6&lt;/httpclient.version&gt; &lt;/properties&gt; &lt;!--依赖配置管理--&gt; &lt;!-- 依赖管理 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--maven依赖--&gt; &lt;dependencies&gt; //==&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;!--model--&gt; &lt;dependency&gt; &lt;groupId&gt;com.dubboone.modle&lt;/groupId&gt; &lt;artifactId&gt;dubboone-modle&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--log--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--guava--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;$&#123;guava.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- time --&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;$&#123;joda-time.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jsp 支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; //==&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;!-- dubbo --&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba.boot/dubbo-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;curator-client&lt;/artifactId&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;$&#123;cglib.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; //==&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;!-- zookeeper start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;zookeeper.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;$&#123;curator.version&#125;&lt;/version&gt; &lt;/dependency&gt; //==&gt;⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ &lt;!--dubbo rest--&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt; &lt;artifactId&gt;resteasy-jaxrs&lt;/artifactId&gt; &lt;version&gt;$&#123;resteasy.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt; &lt;artifactId&gt;resteasy-netty&lt;/artifactId&gt; &lt;version&gt;$&#123;resteasy.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt; &lt;artifactId&gt;resteasy-client&lt;/artifactId&gt; &lt;version&gt;$&#123;resteasy.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt; &lt;artifactId&gt;resteasy-jackson-provider&lt;/artifactId&gt; &lt;version&gt;$&#123;resteasy.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--for test--&gt; &lt;!-- gson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;gson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- okhttp --&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;$&#123;okhttp.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.server :spring-dubbo.xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--发布出去的dubbo服务类所在包的注解--&gt; &lt;dubbo:annotation package=&quot;com.debug.mooc.dubbo.one.server.service.dubbo&quot; /&gt; &lt;!--注册中心zookeeper配置信息--&gt; &lt;dubbo:registry address=&quot;$&#123;dubbo.registry.address&#125;&quot; /&gt; &lt;!--支持两种协议的调用：rpc-dubbo协议；http协议-rest api-url调用--&gt; &lt;dubbo:protocol name=&quot;rest&quot; threads=&quot;500&quot; contextpath=&quot;v1&quot; server=&quot;tomcat&quot; accepts=&quot;500&quot;/&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; /&gt; &lt;!--消费方信息配置--&gt; &lt;dubbo:application name=&quot;dubboOne-consume&quot; owner=&quot;debug&quot; organization=&quot;dubbox&quot;/&gt;&lt;/beans&gt; ##3.server :spring-jdbc.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd " &gt; &lt;!--dubboOne --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close" primary="true" &gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name="url" value="$&#123;datasource.url&#125;" /&gt; &lt;property name="username" value="$&#123;datasource.username&#125;" /&gt; &lt;property name="password" value="$&#123;datasource.password&#125;" /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="10" /&gt; &lt;property name="minIdle" value="10" /&gt; &lt;property name="maxActive" value="20" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="60000" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="60000" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="300000" /&gt; &lt;property name="validationQuery" value="SELECT 1 " /&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;property name="testOnReturn" value="false" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name="poolPreparedStatements" value="true" /&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="20" /&gt; &lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt; &lt;property name="filters" value="stat" /&gt; &lt;/bean&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt;&lt;/beans&gt; 4.application.properties12345678910111213141516171819202122232425262728293031323334353637#profile#spring.profiles.active=production#spring.profiles.active=localserver.port=8093#server.context-path=/dubboOneserver.servlet.context-path=/dubboOne#logginglogging.path=E:\\logs\\mooc\\dubboOne\\logslogging.file=dubboOnelogging.level.org.springframework = INFOlogging.level.com.fasterxml.jackson = INFOlogging.level.com.debug.mooc.dubbo.one = debug#json\u5E8F\u5217\u5316\u914D\u7F6Espring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8#spring.datasource.initialize=falsespring.datasource.initialization-mode=neverspring.jmx.enabled=false#\u6570\u636E\u6E90\u914D\u7F6Edatasource.url=jdbc:mysql://127.0.0.1:3306/mooc_one?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNulldatasource.username=rootdatasource.password=linsen#mybatismybatis.config-location=classpath:mybatis-config.xmlmybatis.checkConfigLocation = truemybatis.mapper-locations=classpath:mappers/*.xml#dubbo zookeeper\u914D\u7F6E\u4FE1\u606Fdubbo.registry.address=zookeeper://127.0.0.1:2181 5dubbo.properties12345678910111213141516171819202122232425262728293031### Copyright 1999-2011 Alibaba Group.# # Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at# # http://www.apache.org/licenses/LICENSE-2.0# # Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.##dubbo.container=log4j,springdubbo.reference.check=falsedubbo.registry.client=curatordubbo.application.name=dubboOne-providerdubbo.application.owner=debug#dubbo\u652F\u6301\u7684dubbo\u534F\u8BAE\u914D\u7F6Edubbo.protocol.name=dubbodubbo.protocol.dubbo.port=20903#dubbo\u652F\u6301\u7684http rest api\u7684\u914D\u7F6Edubbo.protocol.name=restdubbo.protocol.rest.port=9013dubbo.protocol.rest.server=tomcatdubbo.service.loadbalance=roundrobin ##6.log4j.xml 123456789101112131415161718192021222324252627282930313233343536373839#Console Loglog4j.rootLogger=INFO,console,debug,info,warn,errorLOG_PATTERN=[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] boot%X&#123;context&#125; - %5p [%t] --- %c&#123;1&#125;: %m%n#A1--Print log to Consolelog4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=$&#123;LOG_PATTERN&#125;log4j.appender.info=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.info.Threshold=INFOlog4j.appender.info.File=$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;_info.loglog4j.appender.info.DatePattern=&apos;.&apos;yyyy-MM-ddlog4j.appender.info.layout = org.apache.log4j.PatternLayoutlog4j.appender.info.layout.ConversionPattern=$&#123;LOG_PATTERN&#125;log4j.appender.error=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.error.Threshold=ERRORlog4j.appender.error.File=$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;_error.loglog4j.appender.error.DatePattern=&apos;.&apos;yyyy-MM-ddlog4j.appender.error.layout = org.apache.log4j.PatternLayoutlog4j.appender.error.layout.ConversionPattern=$&#123;LOG_PATTERN&#125;log4j.appender.debug=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.debug.Threshold=DEBUGlog4j.appender.debug.File=$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;_debug.loglog4j.appender.debug.DatePattern=&apos;.&apos;yyyy-MM-ddlog4j.appender.debug.layout = org.apache.log4j.PatternLayoutlog4j.appender.debug.layout.ConversionPattern=$&#123;LOG_PATTERN&#125;log4j.appender.warn=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.warn.Threshold=WARNlog4j.appender.warn.File=$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;_warn.loglog4j.appender.warn.DatePattern=&apos;.&apos;yyyy-MM-ddlog4j.appender.warn.layout = org.apache.log4j.PatternLayoutlog4j.appender.warn.layout.ConversionPattern=$&#123;LOG_PATTERN&#125; ##7.mybatis-config.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- Globally enables or disables any caches configured in any mapper under this configuration --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!-- Sets the number of seconds the driver will wait for a response from the database --&gt; &lt;setting name="defaultStatementTimeout" value="3000"/&gt; &lt;!-- Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;!-- Allows JDBC support for generated keys. A compatible driver is required. This setting forces generated keys to be used if set to true, as some drivers deny compatibility but still work --&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;!-- 设置控制台打印sql --&gt; &lt;!--&lt;setting name="logImpl" value="stdout_logging" /&gt;--&gt; &lt;/settings&gt; &lt;!-- Continue going here --&gt; &lt;!--&lt;typeAliases&gt;--&gt; &lt;!--&lt;package name="cn.com.countrygarden.ucenter.entity"/&gt;--&gt; &lt;!--&lt;/typeAliases&gt;--&gt; &lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageHelper"&gt; &lt;!-- 4.0.0以后版本可以不设置该参数 --&gt; &lt;property name="dialect" value="mysql"/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt; &lt;!-- 和startPage中的pageNum效果一样--&gt; &lt;property name="offsetAsPageNum" value="true"/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt; &lt;property name="rowBoundsWithCount" value="true"/&gt; &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt; &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）--&gt; &lt;property name="pageSizeZero" value="true"/&gt; &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt; &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt; &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt; &lt;property name="reasonable" value="false"/&gt; &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt; &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt; &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,orderBy,不配置映射的用默认值 --&gt; &lt;!-- 不理解该含义的前提下，不要随便复制该配置 --&gt; &lt;!--&lt;property name="params" value="pageNum=pageHelperStart;pageSize=pageHelperRows;"/&gt;--&gt; &lt;!-- 支持通过Mapper接口参数来传递分页参数 --&gt; &lt;property name="supportMethodsArguments" value="false"/&gt; &lt;!-- always总是返回PageInfo类型,check检查返回类型是否为PageInfo,none返回Page --&gt; &lt;property name="returnPageInfo" value="none"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!--&lt;mappers&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;&lt;package name="cn.com.countrygarden.ucenter.mapper" /&gt;&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;mapper resource="mappers/DiaryMapper.xml"/&gt;--&gt; &lt;!--&lt;mapper resource="mappers/EmpEvaluateMapper.xml"/&gt;--&gt; &lt;!--&lt;mapper resource="mappers/EmployeeMapper.xml"/&gt;--&gt; &lt;!--&lt;mapper resource="mappers/LikesMapper.xml"/&gt;--&gt; &lt;!--&lt;mapper resource="mappers/PicMapper.xml"/&gt;--&gt; &lt;!--&lt;mapper resource="mappers/RepliesMapper.xml"/&gt;--&gt; &lt;!--&lt;mapper resource="mappers/TeamMapper.xml"/&gt;--&gt; &lt;!--&lt;mapper resource="mappers/UserMapper.xml"/&gt;--&gt; &lt;!--&lt;/mappers&gt;--&gt;&lt;/configuration&gt; 3.整合Dubbo和Zookeeper 12345application.properties:dubbo.registry.address=zookeeper://127.0.0.1:2181、#server.context-path=/dubboOneserver.servlet.context-path=/dubboOne 1234567891011121314dubbo.propertiesdubbo.container=log4j,springdubbo.reference.check=falsedubbo.registry.client=curatordubbo.application.name=dubboOne-providerdubbo.application.owner=debug#dubbo\u652F\u6301\u7684dubbo\u534F\u8BAE\u914D\u7F6Edubbo.protocol.name=dubbodubbo.protocol.dubbo.port=20903#dubbo\u652F\u6301\u7684http rest api\u7684\u914D\u7F6Edubbo.protocol.name=restdubbo.protocol.rest.port=9013dubbo.protocol.rest.server=tomcatdubbo.service.loadbalance=roundrobin 123456789101112131415161718192021spring-dubbo&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!--发布出去的dubbo服务类所在包的注解--&gt; &lt;dubbo:annotation package="com.debug.mooc.dubbo.one.server.service.dubbo"/&gt; &lt;!--注册中心zookeeper配置信息--&gt; &lt;dubbo:registry address="$&#123;dubbo.registry.address&#125;"/&gt; &lt;!--支持两种协议的调用：rpc-dubbo协议；http协议-rest api-url调用--&gt; &lt;dubbo:protocol name="rest" threads="500" contextpath="v1" server="tomcat" accepts="500"/&gt; &lt;dubbo:protocol name="dubbo"/&gt; &lt;!--消费方信息配置--&gt; &lt;dubbo:application name="dubboOne-consume" owner="debug" organization="dubbox"/&gt;&lt;/beans&gt; 4 zookeeper的安装1./zkServer.sh]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F12%2F%E5%89%8D%E7%AB%AF%2FAjax%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Jquery基础篇 （三） 事件]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%89%8D%E7%AB%AF%2FJquery%E5%9F%BA%E7%A1%80(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[jQuery鼠标事件之click与dbclick事件用交互操作中，最简单直接的操作就是点击操作。jQuery提供了两个方法一个是click方法用于监听用户单击操作，另一个方法是dbclick方法用于监听用户双击操作。这两个方法的用法是类似的，下面以click()事件为例 使用上非常简单： 方法一：$ele.click() 绑定$ele元素，不带任何参数一般是用来指定触发一个事件，用的比较少 1234567&lt;div id=&quot;test&quot;&gt;点击触发&lt;div&gt;$(&quot;ele&quot;).click(function()&#123; alert(&apos;触发指定事件&apos;)&#125;)$(&quot;#test&quot;).click(function()&#123; $(&quot;ele&quot;).click() //手动指定触发事件 &#125;); 方法二：$ele.click( handler(eventObject) ) 绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数，这样可以针对事件的反馈做很多操作了，方法中的this是指向了绑定事件的元素 1234&lt;div id=&quot;test&quot;&gt;点击触发&lt;div&gt;$(&quot;#test&quot;).click(function() &#123; //this指向 div元素&#125;); 方法三：$ele.click( [eventData ], handler(eventObject) ) 使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题 12345&lt;div id=&quot;test&quot;&gt;点击触发&lt;div&gt;$(&quot;#test&quot;).click(11111,function(e) &#123; //this指向 div元素 //e.data =&gt; 11111 传递数据&#125;); dbclick()的用法和click()的用法是类似的，可以参考以上click()的用法。 dbclick与click事件不同的是： click事件触发需要以下几点： click事件其实是由mousedown与mouseup 2个动作构成，所以点击的动作只有在松手后才触发 PS:mousedown和mouseup下一节会讲到 dbclick**事件触发需要以下几点：** dbclick又是由2个click叠加而来的，所以dbclick事件只有在满足以下条件的情况下才能被触发 鼠标指针在元素里面时点击。 鼠标指针在元素里面时释放。 鼠标指针在元素里面时再次点击，点击间隔时间，是系统而定。 鼠标指针在元素里面时再次释放。 注意：在同一元素上同时绑定 click 和 dbclick 事件是不可取的。各个浏览器事件触发的顺序是不同的，一些浏览器在dbclick之前接受两个 click 事件 ，而一些浏览器只接受一个 click 事件。用户往往可通过不同的操作系统和浏览器配置双击灵敏度 12345678910&lt;h2&gt;.click()方法&lt;/h2&gt;&lt;h4&gt;测试一&lt;/h4&gt;&lt;button&gt;元素绑定事件,弹出回调中的this&lt;/button&gt;&lt;script type="text/javascript"&gt; //this指向button元素 $("button:eq(0)").click(function() &#123; alert(this) &#125;)&lt;/script&gt; 1234567891011121314&lt;h4&gt;测试二&lt;/h4&gt;&lt;div class="test2"&gt; &lt;p&gt;$('button:first').click(function(e) &#123;alert(this)&#125;)&lt;/p&gt;&lt;/div&gt;&lt;button&gt;指定触发事件&lt;/button&gt;&lt;script type="text/javascript"&gt; $('p').click(function(e) &#123; alert(e.target.textContent) &#125;) //this指向button元素 $("button:eq(1)").click(function() &#123; $('p').click() //指定触发绑定的事件 &#125;)&lt;/script&gt; 12345678910111213141516171819&lt;h4&gt;测试三&lt;/h4&gt;&lt;div class="test3"&gt; &lt;p&gt;$('.right').click(1111, set)&lt;/p&gt;&lt;/div&gt;&lt;button&gt;不同函数传递数据&lt;/button&gt;&lt;script type="text/javascript"&gt; //不同函数传递数据 function data(e) &#123; alert(e.data) //1111 &#125; function a() &#123; $("button:eq(2)").click(1111, data) &#125; a();&lt;/script&gt; jQuery鼠标事件之mousedown与mouseup事件 https://www.imooc.com/code/9717]]></content>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery Ajax]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%89%8D%E7%AB%AF%2FJquery%20Ajax%2F</url>
    <content type="text"><![CDATA[使用load()方法异步请求数据使用load()方法通过Ajax请求加载服务器中的数据，并把返回的数据放置到指定的元素中，它的调用格式为： load(url,[data],[callback]) 参数url为加载服务器地址，可选项data参数为请求时发送的数据，callback参数为数据请求成功后，执行的回调函数 例如，点击“加载”按钮时，向服务器请求加载一个指定页面的内容，加载成功后，将数据内容显示在元素中，并将加载按钮变为不可用。如下图所示： 从图中可以看出，当点击“加载”按钮时，通过调用load()方法向服务器请求加载fruit.html文件中的内容，当加载成功后，先显示数据，并将按钮变为不可用。 2 ⭐️使用getJSON()方法异步加载JSON格式数据使用getJSON()方法可以通过Ajax异步请求的方式，获取服务器中的数据，并对获取的数据进行解析，显示在页面中，它的调用格式为： 1**jQuery.getJSON(url,[data],[callback])**`**或**`**$.getJSON(url,[data],[callback])** 其中，url参数为请求加载json格式文件的服务器地址，可选项data参数为请求时发送的数据，callback参数为数据请求成功后，执行的回调函数 例如，点击页面中的“加载”按钮，调用getJSON()方法获取服务器中JSON格式文件中的数据，并遍历数据，将指定的字段名内容显示在页面中。如下图所示： 从图中可以看出，当点击“加载”按钮时，通过getJSON()方法调用服务器中的sport.json文件，获取返回的data文件数据，并遍历该数据对象，以data[“name”]取出数据中指定的内容，显示在页面中。 3 使用getScript()方法异步加载并执行js文件使用getScript()方法异步请求并执行服务器中的JavaScript格式的文件，它的调用格式如下所示： 1jQuery.getScript(url,[callback])`或`$.getScript(url,[callback]) 参数url为服务器请求地址，可选项callback参数为请求成功后执行的回调函数。 例如，点击“加载”按钮，调用getScript()加载并执行服务器中指定名称的JavaScript格式的文件，并在页面中显示加载后的数据内容，如下图所示： 从图中可以看出，当点击“加载”按钮调用getScript()方法加载服务器中的JavaScript格式文件后，自动执行文件代码，将数据内容显示在元素中 使用get()方法以GET方式从服务器获取数据使用get()方法以GET方式从服务器获取数据使用get()方法时，采用GET方式向服务器请求数据，并通过方法中回调函数的参数返回请求的数据，它的调用格式如下： 1$.get(url,[callback]) 参数url为服务器请求地址，可选项callback参数为请求成功后执行的回调函数。 例如，当点击“加载”按钮时，调用get()方法向服务器中的一个.php文件以GET方式请求数据，并将返回的数据内容显示在页面中，如下图所示： 从图中可以看出，通过$.get()方法向服务器成功请求数据后，在回调函数中通过data参数传回请求的数据，并以data.name格式访问数据中各项的内容。 123456789101112&lt;script type="text/javascript"&gt; $(function () &#123; $("#btnShow").bind("click", function () &#123; var $this = $(this); $.get("http://www.imooc.com/data/info_f.php",function(data) &#123; $this.attr("disabled", "true"); $("ul").append("&lt;li&gt;我的名字叫：" + data.name + "&lt;/li&gt;"); $("ul").append("&lt;li&gt;男朋友对我说：" + data.say + "&lt;/li&gt;"); &#125;, "json"); &#125;) &#125;); &lt;/script&gt; 1234&#123;"name": "白富美","say": "咱们结婚吧!"&#125; 使用post()方法以POST方式从服务器发送数据与get()方法相比，post()方法多用于以POST方式向服务器发送数据，服务器接收到数据之后，进行处理，并将处理结果返回页面，调用格式如下： 1$.post(url,[data],[callback]) 参数url为服务器请求地址，可选项data为向服务器请求时发送的数据，可选项callback参数为请求成功后执行的回调函数。 例如，在输入框中录入一个数字，点击“检测”按钮，调用post()方法向服务器以POST方式发送请求，检测输入值的奇偶性，并显示在页面中，如下图所示： 在浏览器中显示的效果： 从图中可以看出，当点击“检测”按钮时，获取输入框中的值，并将该值使用$.post()方法一起发送给服务器，服务器接收该值后并进行处理，最后返回处理结果。 123456789101112&lt;script type="text/javascript"&gt; $(function () &#123; $("#btnCheck").bind("click", function () &#123; $.post("http://www.imooc.com/data/check_f.php",&#123;name:$("#txtNumber").val()&#125;, function (data) &#123; $("ul").append("&lt;li&gt;你输入的&lt;b&gt; " + $("#txtNumber").val() + " &lt;/b&gt;是&lt;b&gt; " + data + " &lt;/b&gt;&lt;/li&gt;"); &#125;); &#125;) &#125;); &lt;/script&gt; 使用serialize()方法序列化表单元素值使用serialize()方法可以将表单中有name属性的元素值进行序列化，生成标准URL编码文本字符串，直接可用于ajax请求，它的调用格式如下： 1**$(selector).serialize()** 其中selector参数是一个或多个表单中的元素或表单元素本身。 例如，在表单中添加多个元素，点击“序列化”按钮后，调用serialize()方法，将表单元素序列化后的标准URL编码文本字符串显示在页面中，如下图所示： 使用ajax()方法加载服务器数据使用ajax()方法是最底层、功能最强大的请求服务器数据的方法，它不仅可以获取服务器返回的数据，还能向服务器发送请求并传递数值，它的调用格式如下： 1**jQuery.ajax([settings])**`**或**`**$.ajax([settings])** 其中参数settings为发送ajax请求时的配置对象，在该对象中，url表示服务器请求的路径，data为请求时传递的数据，dataType为服务器返回的数据类型，success为请求成功的执行的回调函数，type为发送数据请求的方式，默认为get。 例如，点击页面中的“加载”按钮，调用ajax()方法向服务器请求加载一个txt文件，并将返回的文件中的内容显示在页面，如下图所示： 12345678910111213141516&lt;script type="text/javascript"&gt; $(function () &#123; $("#btnCheck").bind("click", function () &#123; $.ajax(&#123; url: "http://www.imooc.com/data/check.php", data: &#123; num: $("#txtNumber").val() &#125;, type: 'POST', success: function (data) &#123; $("ul").append("&lt;li&gt;你输入的&lt;b&gt; " + $("#txtNumber").val() + " &lt;/b&gt;是&lt;b&gt; " + data + " &lt;/b&gt;&lt;/li&gt;"); &#125; &#125;); &#125;) &#125;); &lt;/script&gt;]]></content>
      <tags>
        <tag>Jquery</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电商网站开发 谷粒商城 徐静博]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B%20%E5%B0%9A%E7%A1%85%E8%B0%B7%2F</url>
    <content type="text"></content>
      <tags>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后台服务代码架构：duboo集群部署安装]]></title>
    <url>%2F2019%2F03%2F10%2FDubbo%2Fduboo%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[dubbo集群部署安装依赖于zookeeper，所以我们下面重点安装zookeeper集群。1、**准备三台机器做集群** 服务器 IP地址 端口 服务器1 10.211.55.7 2181/2881/3881 服务器2 10.211.55.8 2181/2881/3881 服务器3 10.211.55.9 2181/2881/3881 12345export ZOOKEEPER_HOME=/root/zookeeper-3.4.10export CLASSPATH=.:%JAVA_HOME%/lib/dt.jar:%JAVA_HOME%/lib/tools.jarexport JAVA_HOME=/root/jdk1.8.0_201export PATH=$PATH:$JAVA_HOME/binexport PATH=$PATH:$ZOOKEEPER_HOME/bin:$JAVA_HOME/bin 2.2 修改操作系统的/etc/hosts文件，添加IP与主机名映射： # zookeeper cluster servers 10.211.55.7 bigdata1 10.211.55.8 bigdata2 10.211.55.9 bigdata3 tar -zxvf zookeeper-3.4.9.tar.gz 2.5 在zookeeper的各个节点下 创建数据和日志目录cd zookeeper mkdir data mkdir logs 12345678910112.6 重命名配置文件 将zookeeper/conf目录下的zoo_sample.cfg文件拷贝一份，命名为zoo.cfg:#cp zoo_sample.cfg zoo.cfg修改zoo.cfg 配置文件clientPort=2181dataDir=/data/program/software/zookeeper/datadataLogDir=/data/program/software/zookeeper/logs server.1=bigdata1:2881:3881server.2=bigdata2:2881:3881server.3=bigdata3:2881:3881 1234567891011121314151617181920参数说明:tickTime=2000tickTime这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔,也就是每个tickTime时间就会发送一个心跳。initLimit=10initLimit这个配置项是用来配置Zookeeper接受客户端（这里所说的客户端不是用户连接Zookeeper服务器的客户端,而是Zookeeper服务器集群中连接到Leader的Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过10个心跳的时间（也就是tickTime）长度后Zookeeper 服务器还没有收到客户端的返回信息,那么表明这个客户端连接失败。总的时间长度就是10*2000=20 秒。syncLimit=5syncLimit这个配置项标识Leader与Follower之间发送消息,请求和应答时间长度,最长不能超过多少个tickTime的时间长度,总的时间长度就是5*2000=10秒。dataDir=/data/program/software/zookeeper/datadataDir顾名思义就是Zookeeper保存数据的目录,默认情况下Zookeeper将写数据的日志文件也保存在这个目录里。clientPort=2181clientPort这个端口就是客户端（应用程序）连接Zookeeper服务器的端口,Zookeeper会监听这个端口接受客户端的访问请求。server.A=B：C：Dserver.1=bigdata1:2881:3881server.2=bigdata2:2881:3881server.3=bigdata3:2881:3881A是一个数字,表示这个是第几号服务器；B是这个服务器的IP地址（或者是与IP地址做了映射的主机名）；C第一个端口用来集群成员的信息交换,表示这个服务器与集群中的Leader服务器交换信息的端口；D是在leader挂掉时专门用来进行选举leader所用的端口。注意：如果是伪集群的配置方式，不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。 12345678910112.8 创建myid文件在dataDir= dataDir=/data/program/software/zookeeper/data 下创建myid文件编辑myid文件，并在对应的IP的机器上输入对应的编号。如在1上，myid文件内容就是1, 2上就是2， 3上就是3：#vi /myid## 值为1#vi /myid## 值为2#vi /myid## 值为32.9 启动测试zookeeper(1)进入/bin目录下执行：# /zkServer.sh start# /zkServer.sh start# /zkServer.sh start —-]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery基础篇（二）-DOM篇章]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%89%8D%E7%AB%AF%2FjQuery%E5%9F%BA%E7%A1%80(%E4%BA%8C)%E2%80%94DOM%E7%AF%87%2F</url>
    <content type="text"><![CDATA[DOM创建节点及节点属性本文向大家介绍一下如何使用JavaScript创建div节点元素，主要包括创建div节点元素的属性和创建div节点元素的样式两大部分内容 创建流程比较简单，大体如下： 创建节点(常见的：元素、属性和文本) 添加节点的一些属性 加入到文档中 流程中涉及的一点方法： 创建元素：document.createElement 设置属性：setAttribute 添加文本：innerHTML 加入文档：appendChild 12345678910111213141516171819202122&lt;script type="text/javascript"&gt; var body = document.querySelector('body'); document.addEventListener('click',function()&#123; //创建2个div元素 var rightdiv = document.createElement('div') var rightaaron = document.createElement("div"); //给2个div设置不同的属性 rightdiv.setAttribute('class', 'right') rightaaron.className = 'aaron' rightaaron.innerHTML = "动态创建DIV元素节点"; //2个div合并成包含关系 rightdiv.appendChild(rightaaron) //绘制到页面body body.appendChild(rightdiv) &#125;,false) &lt;script&gt; 如右边代码所示，写一个最简单的元素创建，我们会发现几个问题： 每一个元素节点都必须单独创建 节点是属性需要单独设置，而且设置的接口不是很统一 添加到指定的元素位置不灵活 最后还有一个最重要的：浏览器兼容问题处理 jQuery节点创建与属性的处理创建元素节点： 1可以有几种方式，后面会慢慢接触。常见的就是直接把这个节点的结构给通过HTML标记字符串描述出来，通过 $()函数处理，$(&quot;html结构&quot;) 1$(&quot;&lt;div&gt;&lt;/div&gt;&quot;) 创建为本节点： 12与创建元素节点类似，可以直接把文本内容一并描述$(&quot;&lt;div&gt;我是文本节点&lt;/div&gt;&quot;) 创建为属性节点 12与创建元素节点同样的方式$(&quot;&lt;div id=&apos;test&apos; class=&apos;aaron&apos;&gt;我是文本节点&lt;/div&gt;&quot;) 我们通过jQuery把上一届的代码改造一下，如右边代码所示 一条一句就搞定了，跟写HTML结构方式是一样的 1$(&quot;&lt;div class=&apos;right&apos;&gt;&lt;div class=&apos;aaron&apos;&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;&quot;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="https://www.imooc.com/static/lib/jquery/1.9.1/jquery.js"&gt;&lt;/script&gt; &lt;style&gt; .left, .right &#123; width: 300px; height: 120px; &#125; .left div, .right div &#123; width: 100px; height: 90px; padding: 5px; margin: 5px; float: left; border: 1px solid #ccc; &#125; .left div &#123; background: #bbffaa; &#125; .right div &#123; background: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;动态创建元素节点&lt;/h2&gt; &lt;button&gt;点击通过jQuery动态创建元素节点&lt;/button&gt; &lt;script type="text/javascript"&gt; var $body = $('body'); $body.on('click', function() &#123; //通过jQuery生成div元素节点 var div = $("&lt;div class='right'&gt;&lt;div class='aaron'&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;") $body.append(div) &#125;) // var body = document.querySelector('body'); // document.addEventListener('click',function()&#123; // //创建2个div元素 // var rightdiv = document.createElement('div') // var rightaaron = document.createElement("div"); // //给2个div设置不同的属性 // rightdiv.setAttribute('class', 'right') // rightaaron.className = 'aaron' // rightaaron.innerHTML = "动态创建DIV元素节点"; // //2个div合并成包含关系 // rightdiv.appendChild(rightaaron) // //绘制到页面body // body.appendChild(rightdiv) // &#125;,false) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678var $body = $('body'); $body.on('click', function() &#123; //通过jQuery生成div元素节点 var div = $("&lt;div class='right'&gt;&lt;div class='aaron'&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;") $body.append(div) &#125;) DOM内部插入append()与appendTo()动态创建的元素是不够的，它只是临时存放在内存中，最终我们需要放到页面文档并呈现出来。那么问题来了，怎么放到文档上？ 这里就涉及到一个位置关系，常见的就是把这个新创建的元素，当作页面某一个元素的子元素放到其内部。针对这样的处理，jQuery就定义2个操作的方法 append：这个操作与对指定的元素执行原生的appendChild方法，将它们添加到文档中的情况类似。 appendTo：实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。 简单的总结就是： .append()和.appendTo()两种方法功能相同，主要的不同是语法——内容和目标的位置不同 12append()前面是被插入的对象，后面是要在对象内插入的元素内容appendTo()前面是要插入的元素内容，而后面是被插入的对象 123456&lt;body&gt; &lt;h2&gt;通过append与appendTo添加元素&lt;/h2&gt; &lt;button id="bt1"&gt;点击通过jQuery的append添加元素&lt;/button&gt; &lt;button id="bt2"&gt;点击通过jQuery的appendTo添加元素&lt;/button&gt; &lt;div class="content"&gt;&lt;/div&gt; 123456789101112131415161718 $("#bt1").on('click', function() &#123; //.append(), 内容在方法的后面， //参数是将要插入的内容。 $(".content").append('&lt;div class="append"&gt;通过append方法添加的元素&lt;/div&gt;') &#125;)&lt;/script&gt;&lt;script type="text/javascript"&gt; $("#bt2").on('click', function() &#123; //.appendTo()刚好相反，内容在方法前面， //无论是一个选择器表达式 或创建作为标记上的标记 //它都将被插入到目标容器的末尾。 $('&lt;div class="appendTo"&gt;通过appendTo方法添加的元素&lt;/div&gt;').appendTo($(".content")) &#125;)&lt;/script&gt; ![image-20190311090109502](https://ws4.sinaimg.cn/large/006tKfTcgy1g0yksicn8fj308r03zjs4.jpg) # DOM外部插入after()与before() 节点与节点之前有各种关系，除了父子，祖辈关系，还可以是兄弟关系。之前我们在处理节点插入的时候，接触到了内部插入的几个方法，这节我们开始讲外部插入的处理，也就是兄弟之间的关系处理，这里jQuery引入了2个方法，可以用来在匹配I的元素前后插入内容 ![image-20190311090216128](https://ws4.sinaimg.cn/large/006tKfTcgy1g0ykto07ttj30hw06q3z9.jpg) - before与after都是用来对相对选中元素外部增加相邻的兄弟节点 - 2个方法都是都可以接收HTML字符串，DOM 元素，元素数组，或者jQuery对象，用来插入到集合中每个匹配元素的前面或者后面 - 2个方法都支持多个参数传递after(div1,div2,....) 可以参考右边案例代码 - after向元素的后边添加html代码，如果元素后面有元素了，那将后面的元素后移，然后将html代码插入 - before向元素的前边添加html代码，如果元素前面有元素了，那将前面的元素前移，然后将html代码插 12345678910&lt;body&gt; &lt;h2&gt;通过before与after添加元素&lt;/h2&gt; &lt;button id="bt1"&gt;点击通过jQuery的before添加元素&lt;/button&gt; &lt;button id="bt2"&gt;点击通过jQuery的after添加元素&lt;/button&gt; &lt;div class="aaron"&gt; &lt;p class="test1"&gt;测试before&lt;/p&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;p class="test2"&gt;测试after&lt;/p&gt; &lt;/div&gt; 123456&lt;script type="text/javascript"&gt; $("#bt1").on('click', function() &#123; //在匹配test1元素集合中的每个元素前面插入p元素 $(".test1").before('&lt;p style="color:red"&gt;before,在匹配元素之前增加&lt;/p&gt;', '&lt;p style="color:red"&gt;多参数&lt;/p&gt;') &#125;)&lt;/script&gt; 1234567&lt;script type="text/javascript"&gt; $("#bt2").on('click', function() &#123; //在匹配test1元素集合中的每个元素后面插入p元素 $(".test2").after('&lt;p style="color:blue"&gt;after,在匹配元素之后增加&lt;/p&gt;', '&lt;p style="color:blue"&gt;多参数&lt;/p&gt;') &#125;) &lt;/script&gt; --- ![image-20190311090518464](https://ws3.sinaimg.cn/large/006tKfTcgy1g0ykwtw3k3j30aw0cd75o.jpg) --- # DOM内部插入prepend()与prependTo() 在元素内部进行操作的方法，除了在被选元素的结尾（仍然在内部）通过append与appendTo插入指定内容外，相应的还可以在被选元素之前插入，jQuery提供的方法是prepend与prependTo ![image-20190311090618510](https://ws1.sinaimg.cn/large/006tKfTcgy1g0ykxvctkkj30h706kmxp.jpg) --- 通过右边代码可以看到prepend与prependTo的使用及区别： - .prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素 (如果要作为最后一个子元素插入用.append()). - .prepend()和.prependTo()实现同样的功能，主要的不同是语法，插入的内容和目标的位置不同 - 对于.prepend() 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数 - 而.prependTo() 正好相反，将要被插入的内容写在方法的前面，可以是选择器表达式或动态创建的标记，待插入内容的容器作为参数。 这里总结下内部操作四个方法的区别： - append()向每个匹配的元素内部追加内容 - prepend()向每个匹配的元素内部前置内容 - appendTo()把所有匹配的元素追加到另一个指定元素的集合中 - prependTo()把所有匹配的元素前置到另一个指定的元素集合中 --- 123456789&lt;h2&gt;通过prepend与prependTo添加元素&lt;/h2&gt; &lt;button id="bt1"&gt;点击通过jQuery的prepend添加元素&lt;/button&gt; &lt;button id="bt2"&gt;点击通过jQuery的prependTo添加元素&lt;/button&gt; &lt;div class="aaron1"&gt; &lt;p&gt;测试prepend&lt;/p&gt; &lt;/div&gt; &lt;div class="aaron2"&gt; &lt;p&gt;测试prependTo&lt;/p&gt; &lt;/div&gt; 123456$("#bt1").on('click', function() &#123; //找到class="aaron1"的div节点 //然后通过prepend在内部的首位置添加一个新的p节点 $('.aaron1') .prepend('&lt;p&gt;prepend增加的p元素&lt;/p&gt;')&#125;) 1234567&lt;script type="text/javascript"&gt; $("#bt2").on('click', function() &#123; //找到class="aaron2"的div节点 //然后通过prependTo内部的首位置添加一个新的p节点 $('&lt;p&gt;prependTo增加的p元素&lt;/p&gt;') .prependTo($('.aaron2')) &#125;) ![image-20190311090917184](https://ws1.sinaimg.cn/large/006tKfTcgy1g0yl0yp2qfj30ci0bmwfy.jpg) --- ![image-20190311093931113](https://ws3.sinaimg.cn/large/006tKfTcgy1g0ylwfmkkij30m60s3dmh.jpg) --- # DOM外部插入insertAfter()与insertBefore() 与内部插入处理一样，jQuery由于内容目标的位置不同，然增加了2个新的方法insertAfter与insertBefore ![image-20190311094156294](https://ws1.sinaimg.cn/large/006tKfTcgy1g0ylyxpozyj30hu08aq3l.jpg) --- - .before()和.insertBefore()实现同样的功能。主要的区别是语法——内容和目标的位置。 对于before()选择表达式在函数前面，内容作为参数，而.insertBefore()刚好相反，内容在方法前面，它将被放在参数里元素的前面 - .after()和.insertAfter() 实现同样的功能。主要的不同是语法——特别是（插入）内容和目标的位置。 对于after()选择表达式在函数的前面，参数是将要插入的内容。对于 .insertAfter(), 刚好相反，内容在方法前面，它将被放在参数里元素的后面 - before、after与insertBefore。insertAfter的除了目标与位置的不同外，后面的不支持多参数处理 123注意事项：insertAfter将JQuery封装好的元素插入到指定元素的后面，如果元素后面有元素了，那将后面的元素后移，然后将JQuery对象插入；insertBefore将JQuery封装好的元素插入到指定元素的前面，如果元素前面有元素了，那将前面的元素前移，然后将JQuery对象插入； 12345678910&lt;h2&gt;通过insertBefore与insertAfter添加元素&lt;/h2&gt; &lt;button id="bt1"&gt;点击通过jQuery的insertBefore添加元素&lt;/button&gt; &lt;button id="bt2"&gt;点击通过jQuery的insertAfter添加元素&lt;/button&gt; &lt;div class="aaron"&gt; &lt;p class="test1"&gt;测试insertBefore,不支持多参数&lt;/p&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;p class="test2"&gt;测试insertAfter,不支持多参数&lt;/p&gt; &lt;/div&gt; --- 12345678&lt;script type="text/javascript"&gt; $("#bt1").on('click', function() &#123; //在test1元素前后插入集合中每个匹配的元素 //不支持多参数 $('&lt;p style="color:red"&gt;测试insertBefore方法增加&lt;/p&gt;', '&lt;p style="color:red"&gt;多参数&lt;/p&gt;').insertBefore($(".test1")) &#125;) &lt;/script&gt; 1234567&lt;script type="text/javascript"&gt; $("#bt2").on('click', function() &#123; //在test2元素前后插入集合中每个匹配的元素 //不支持多参数 $('&lt;p style="color:red"&gt;测试insertAfter方法增加&lt;/p&gt;', '&lt;p style="color:red"&gt;多参数&lt;/p&gt;').insertAfter($(".test2")) &#125;) &lt;/script&gt; --- ![image-20190311094448653](https://ws2.sinaimg.cn/large/006tKfTcgy1g0ym1xg9tjj30cy0aujtf.jpg) --- # DOM节点删除之empty()的基本用法 要移除页面上节点是开发者常见的操作，jQuery提供了几种不同的方法用来处理这个问题，这里我们开仔细了解下empty方法 empty 顾名思义，清空方法，但是与删除又有点不一样，因为它只移除了 指定元素中的所有子节点。 这个方法不仅移除子元素（和其他后代元素），同样移除元素里的文本。因为，根据说明，元素里任何文本字符串都被看做是该元素的子节点。请看下面的HTML： 1&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt; 如果我们通过empty方法移除里面div的所有元素，它只是清空内部的html代码，但是标记仍然留在DOM中 12345//通过empty处理$(&apos;.hello&apos;).empty()//结果：&lt;p&gt;慕课网&lt;/p&gt;被移除&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt; 12通过empty移除了当前div元素下的所有p元素但是本身id=test的div元素没有被删除 123456789101112&lt;h2&gt;通过empty移除元素&lt;/h2&gt;&lt;div id="test"&gt; &lt;p&gt;p元素1&lt;/p&gt; &lt;p&gt;p元素2&lt;/p&gt;&lt;/div&gt;&lt;button&gt;点击通过jQuery的empty移除元素&lt;/button&gt;&lt;script type="text/javascript"&gt;$("button").on('click', function() &#123; //通过empty移除了当前div元素下的所有p元素 //但是本身id=test的div元素没有被删除 $("#test").empty()&#125;) ![image-20190311095432041](https://ws4.sinaimg.cn/large/006tKfTcgy1g0ymc1u2d0j30au05a0t3.jpg) --- ![image-20190311095442913](https://ws2.sinaimg.cn/large/006tKfTcgy1g0ymc8bkjoj308c03d3yo.jpg) --- # DOM节点删除之remove()的有参用法和无参用法 remove与empty一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。 例如一段节点，绑定点击事件 12&lt;div class="hello"&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt;$('.hello').on("click",fn) 如果不通过remove方法删除这个节点其实也很简单，但是同时需要把事件给销毁掉，这里是为了防止"内存泄漏"，所以前端开发者一定要注意，绑了多少事件，不用的时候一定要记得销毁 通过remove方法移除div及其内部所有元素，remove内部会自动操作事件销毁方法，所以使用使用起来非常简单 1234//通过remove处理$(&apos;.hello&apos;).remove()//结果：&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt; 全部被移除//节点不存在了,同事事件也会被销毁 **remove表达式参数：** remove比empty好用的地方就是可以传递一个选择器表达式用来过滤将被移除的匹配元素集合，可以选择性的删除指定的节点 我们可以通过$()选择一组相同的元素，然后通过remove（）传递筛选的规则，从而这样处理 对比右边的代码区域，我们可以通过类似于这样处理 1$(&quot;p&quot;).filter(&quot;:contains(&apos;3&apos;)&quot;).remove() 1234567891011&lt;h2&gt;通过jQuery remove方法移除元素&lt;/h2&gt; &lt;div class="test1"&gt; &lt;p&gt;p元素1&lt;/p&gt; &lt;p&gt;p元素2&lt;/p&gt; &lt;/div&gt; &lt;div class="test2"&gt; &lt;p&gt;p元素3&lt;/p&gt; &lt;p&gt;p元素4&lt;/p&gt; &lt;/div&gt; &lt;button&gt;通过点击jQuery的remove移除元素&lt;/button&gt; &lt;button&gt;通过点击jQuery的remove移除指定元素&lt;/button&gt; 12345&lt;script type="text/javascript"&gt; $("button:first").on('click', function() &#123; //删除整个 class=test1的div节点 $(".test1").remove() &#125;) 12345$("button:last").on('click', function() &#123; //找到所有p元素中，包含了3的元素 //这个也是一个过滤器的处理 $("p").remove(":contains('3')")&#125;) ![image-20190311095903962](https://ws2.sinaimg.cn/large/006tKfTcgy1g0ymgrvd7ej30c90bbdgp.jpg) --- ![image-20190311095915688](https://ws4.sinaimg.cn/large/006tKfTcgy1g0ymgyumsrj30d1077js0.jpg) --- # DOM节点删除之empty和remove区别 1234567891011要用到移除指定元素的时候，jQuery提供了empty()与remove([expr])二个方法，两个都是删除元素，但是两者还是有区别empty方法严格地讲，empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点empty不能删除自己本身这个节点remove方法该节点与该节点所包含的所有后代节点将同时被删除提供传递一个筛选的表达式，删除指定合集中的元素以上就是二者的区别，我们具体通过右边代码部分加深理解 123456789101112131415&lt;h2&gt;通过empty与remove移除元素&lt;/h2&gt; &lt;div class="left"&gt; &lt;button id="bt1"&gt;点击通过jQuery的empty移除内部P元素&lt;/button&gt; &lt;button id="bt2"&gt;点击通过jQuery的remove移除整个节点&lt;/button&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;div id="test1"&gt; &lt;p&gt;p元素1&lt;/p&gt; &lt;p&gt;p元素2&lt;/p&gt; &lt;/div&gt; &lt;div id="test2"&gt; &lt;p&gt;p元素3&lt;/p&gt; &lt;p&gt;p元素4&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 1234567891011&lt;script type="text/javascript"&gt; $("#bt1").on('click', function() &#123; //删除了2个p元素，但是本着没有删除 $("#test1").empty() &#125;) $("#bt2").on('click', function() &#123; //删除整个节点 $("#test2").remove() &#125;) &lt;/script&gt; ![image-20190311100126080](https://ws3.sinaimg.cn/large/006tKfTcgy1g0ymj8dn5nj30cp07oaav.jpg) ![image-20190311100139394](https://ws4.sinaimg.cn/large/006tKfTcgy1g0ymjgtr9bj30c5082wez.jpg) --- # DOM节点删除之保留数据的删除操作detach() 如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用detach方法来处理 detach从字面上就很容易理解。让一个web元素托管。即从当前页面中移除该元素，但保留这个元素的内存模型对象。 来看看jquery官方文档的解释： 12这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。$(&quot;div&quot;).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。 当然这里要特别注意，detach方法是JQuery特有的，所以它只能处理通过JQuery的方法绑定的事件或者数据 参考右边的代码区域，通过 $("p").detach()把所有的P元素删除后，再通过append把删除的p元素放到页面上，通过点击文字，可以证明事件没有丢失 P元素1，默认给绑定一个点击事件 123&lt;p&gt;P元素2，默认给绑定一个点击事件&lt;/p&gt;&lt;button id="bt1"&gt;点击删除 p 元素&lt;/button&gt;&lt;button id="bt2"&gt;点击移动 p 元素&lt;/button&gt; 12345678910111213141516171819&lt;script type="text/javascript"&gt; $('p').click(function(e) &#123; alert(e.target.innerHTML) &#125;) var p; $("#bt1").click(function() &#123; if (!$("p").length) return; //去重 //通过detach方法删除元素 //只是页面不可见，但是这个节点还是保存在内存中 //数据与事件都不会丢失 p = $("p").detach() &#125;); $("#bt2").click(function() &#123; //把p元素在添加到页面中 //事件还是存在 $("body").append(p); &#125;); &lt;/script&gt; --- ![image-20190311101545162](https://ws1.sinaimg.cn/large/006tKfTcgy1g0ymy49xqbj309804l74v.jpg) > 通过 $("p").detach()把所有的P元素删除后 # DOM节点删除之detach()和remove()区别 remove()和detach()可能就是其中的一个，可能remove()我们用得比较多，而detach()就可能会很少了 ![image-20190311101654121](https://ws3.sinaimg.cn/large/006tKfTcgy1g0ymzbdwjhj30jh04gt9y.jpg) **remove****：**移除节点 - 无参数，移除自身整个节点以及该节点的内部的所有节点，包括节点上事件与数据 - 有参数，移除筛选出的节点以及该节点的内部的所有节点，包括节点上事件与数据 **detach****：**移除节点 - 移除的处理与remove一致 - 与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来 - 例如：$("p").detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。 12345678910111213141516171819202122232425 &lt;h3&gt;给页面2个p元素节点绑定点击事件,点击后弹出自己本身的节点内容&lt;/h3&gt; &lt;p&gt;元素p1，同时绑定点击事件&lt;/p&gt; &lt;p&gt;元素p2，同时绑定点击事件&lt;/p&gt; &lt;h3&gt;通过点击2个按钮后观察方法处理的区别&lt;/h3&gt; &lt;button&gt;点击通过remove处理元素p1&lt;/button&gt; &lt;button&gt;点击通过detach处理元素p2&lt;/button&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; //给页面上2个p元素都绑定时间 $('p').click(function(e) &#123; alert(e.target.innerHTML) &#125;) $("button:first").click(function() &#123; var p = $("p:first").remove(); p.css('color','red').text('p1通过remove处理后,点击该元素,事件丢失') $("body").append(p); &#125;); $("button:last").click(function() &#123; var p = $("p:first").detach(); p.css('color','blue').text('p2通过detach处理后,点击该元素事件存在') $("body").append(p); &#125;);&lt;/script&gt; # DOM拷贝clone() 克隆节点是DOM的常见操作，jQuery提供一个clone方法，专门用于处理dom的克隆 1.clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。 clone方法比较简单就是克隆节点，但是需要注意，如果节点有事件或者数据之类的其他处理，我们需要通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了 1234567891011HTML部分&lt;div&gt;&lt;/div&gt;JavaScript部分$("div").on('click', function() &#123;//执行操作&#125;)//clone处理一$("div").clone() //只克隆了结构，事件丢失//clone处理二$("div").clone(true) //结构、事件与数据都克隆 使用上就是这样简单，使用克隆的我们需要额外知道的细节： - clone()方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如右边代码我 $(this).clone().css('color','red') 增加了一个颜色 - 通过传递true，将所有绑定在原始元素上的事件处理函数复制到克隆元素上 - clone()方法是jQuery扩展的，只能处理通过jQuery绑定的事件与数据 - 元素数据（data）内对象和数组不会被复制，将继续被克隆元素和原始元素共享。深复制的所有数据，需要手动复制每一个 --- 通过clone克隆元素 1234&lt;div class="left"&gt; &lt;div class="aaron1"&gt;点击,clone浅拷贝&lt;/div&gt; &lt;div class="aaron2"&gt;点击,clone深拷贝,可以继续触发创建&lt;/div&gt;&lt;/div&gt; 1234567&lt;script type="text/javascript"&gt; //只克隆节点 //不克隆事件 $(".aaron1").on('click', function() &#123; $(".left").append( $(this).clone().css('color','red') ) &#125;) &lt;/script&gt; ![image-20190311102443530](https://ws4.sinaimg.cn/large/006tKfTcgy1g0yn7ggedej304307jaab.jpg) --- 12345678&lt;script type="text/javascript"&gt; //克隆节点 //克隆事件 $(".aaron2").on('click', function() &#123; console.log(1) $(".left").append( $(this).clone(true).css('color','blue') ) &#125;) &lt;/script&gt; ![image-20190311102510959](https://ws3.sinaimg.cn/large/006tKfTcgy1g0yn7xtr2sj307u0f5jtm.jpg) --- #DOM替换replaceWith()和replaceAll() **.replaceWith( newContent )**：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合 简单来说：用$()选择节点A，调用replaceWith方法，传入一个新的内容B（HTML字符串，DOM元素，或者jQuery对象）用来替换选中的节点A 看个简单的例子：一段HTML代码 12345&lt;div&gt; &lt;p&gt;第一段&lt;/p&gt; &lt;p&gt;第二段&lt;/p&gt; &lt;p&gt;第三段&lt;/p&gt;&lt;/div&gt; 替换第二段的节点与内容 1$(&quot;p:eq(1)&quot;).replaceWith(&apos;&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;&apos;) 通过jQuery筛选出第二个p元素，调用replaceWith进行替换，结果如下 12345&lt;div&gt; &lt;p&gt;第一段&lt;/p&gt; &lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;&apos; &lt;p&gt;第三段&lt;/p&gt;&lt;/div&gt; **.replaceAll( target )** **：**用集合的匹配元素替换每个目标元素 .replaceAll()和.replaceWith()功能类似，但是目标和源相反，用上述的HTML结构，我们用replaceAll处理 1$(&apos;&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;&apos;).replaceAll(&apos;p:eq(1)&apos;) 总结： - .replaceAll()和.replaceWith()功能类似，主要是目标和源的位置区别 - .replaceWith()与.replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序 - .replaceWith()方法，和大部分其他jQuery方法一样，返回jQuery对象，所以可以和其他方法链接使用 - .replaceWith()方法返回的jQuery对象引用的是替换前的节点，而不是通过replaceWith/replaceAll方法替换后的节点 1234567891011121314151617&lt;h2&gt;replaceWith()和replaceAll()&lt;/h2&gt; &lt;div class="left"&gt; &lt;button class="bt1"&gt;点击,通过replaceWith替换内容&lt;/button&gt; &lt;button class="bt2"&gt;点击,通过rreplaceAll替换内容&lt;/button&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;div&gt; &lt;p&gt;第一段&lt;/p&gt; &lt;p&gt;第二段&lt;/p&gt; &lt;p&gt;第三段&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;第四段&lt;/p&gt; &lt;p&gt;第五段&lt;/p&gt; &lt;p&gt;第六段&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 12345678&lt;script type="text/javascript"&gt; //只克隆节点 //不克隆事件 $(".bt1").on('click', function() &#123; //找到内容为第二段的p元素 //通过replaceWith删除并替换这个节点 $(".right &gt; div:first p:eq(1)").replaceWith('&lt;a style="color:red"&gt;replaceWith替换第二段的内容&lt;/a&gt;') &#125;) 1234567&lt;script type="text/javascript"&gt; //找到内容为第六段的p元素 //通过replaceAll删除并替换这个节点 $(".bt2").on('click', function() &#123; $('&lt;a style="color:red"&gt;replaceAll替换第六段的内容&lt;/a&gt;').replaceAll('.right &gt; div:last p:last'); &#125;) &lt;/script&gt; # DOM包裹wrap()方法 如果要将元素用其他元素包裹起来，也就是给它增加一个父元素，针对这样的处理，JQuery提供了一个wrap方法 **.wrap( wrappingElement )****：**在集合中匹配的每个元素周围包裹一个HTML结构 简单的看一段代码： 1&lt;p&gt;p元素&lt;/p&gt; 给p元素增加一个div包裹 1$(&apos;p&apos;).wrap(&apos;&lt;div&gt;&lt;/div&gt;&apos;) 最后的结构，p元素增加了一个父div的结构 123&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; **.wrap( function )** **：**一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象 使用后的效果与直接传递参数是一样，只不过可以把代码写在函数体内部，写法不同而已 以第一个案例为例： 123$(&apos;p&apos;).wrap(function() &#123; return &apos;&lt;div&gt;&lt;/div&gt;&apos;; //与第一种类似，只是写法不一样&#125;) .wrap()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套了好几层深，但应该只包含一个核心的元素。每个匹配的元素都会被这种结构包裹。该方法返回原始的元素集，以便之后使用链式方法。 DOM包裹wrap()方法 123456789101112&lt;div class="left"&gt; &lt;button class="aaron1"&gt;点击,通过wrap方法给p元素增加父容器div&lt;/button&gt; &lt;button class="aaron2"&gt;点击,通过wrap的回调方法给a元素增加父容器div&lt;/div&gt;&lt;/div&gt;&lt;div class="right"&gt; &lt;p&gt;p元素&lt;/p&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt;&lt;div class="left"&gt; &lt;a&gt;a元素&lt;/a&gt; &lt;a&gt;a元素&lt;/a&gt;&lt;/div&gt; 12345678910111213&lt;script type="text/javascript"&gt; $(".aaron1").on('click', function() &#123; //给所有p元素，增加父容器div $('p').wrap('&lt;div&gt;&lt;/div&gt;') &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $(".aaron2").on('click', function() &#123; $('a').wrap(function() &#123; return '&lt;div class="' + $(this).text() + '" /&gt;'; &#125;) &#125;) &lt;/script&gt; ![image-20190311103309520](https://ws4.sinaimg.cn/large/006tKfTcgy1g0yng8jw6uj309j06rq3h.jpg) --- # DOM包裹unwrap()方法 我们可以通过wrap方法给选中元素增加一个包裹的父元素。相反，如果删除选中元素的父元素要如何处理 ? jQuery提供了一个unwrap()方法 ，作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。 看一段简单案例： 123&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; 我要删除这段代码中的div，一般常规的方法会直接通过remove或者empty方法 1$(&apos;div&apos;).remove(); 但是如果我还要保留内部元素p，这样就意味着需要多做很多处理，步骤相对要麻烦很多，为了更便捷，jQuery提供了unwrap方法很方便的处理了这个问题 1$(&apos;p&apos;).unwrap(); 找到p元素，然后调用unwrap方法，这样只会删除父辈div元素了 结果： 1&lt;p&gt;p元素&lt;/p&gt; 这个方法比较简单，也不接受任何参数，注意参考下案例的使用即可 123456789101112131415161718192021&lt;h2&gt;DOM包裹unwrap()方法&lt;/h2&gt; &lt;div class="left"&gt; &lt;div class="aaron1"&gt;点击,通过unwrap方法给p元素删除父容器div&lt;/div&gt; &lt;div class="aaron2"&gt;点击,通过unwrap的回调方法给a元素删除父容器div&lt;/div&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;div&gt; &lt;p&gt;p元素&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;p元素&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt; &lt;div&gt; &lt;a&gt;a元素&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a&gt;a元素&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; --- 1234567891011121314&lt;script type="text/javascript"&gt; $(".aaron1").on('click', function() &#123; //找到所有p元素，删除父容器div $('p').unwrap('&lt;div&gt;&lt;/div&gt;') &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $(".aaron2").on('click', function() &#123; //找到所有p元素，删除父容器div $('a').unwrap(function() &#123; return '&lt;div&gt;&lt;/div&gt;'; &#125;) &#125;) &lt;/script&gt; ![image-20190311103603895](https://ws4.sinaimg.cn/large/006tKfTcgy1g0ynj96ichj309s0dbabi.jpg) --- # DOM包裹wrapAll()方法 wrap是针对单个dom元素处理，如果要将**集****合中**的元素用其他元素包裹起来，也就是给他们增加一个父元素，针对这样的处理，JQuery提供了一个wrapAll方法 **.wrapAll( wrappingElement )****：**给集合中匹配的元素增加一个外面包裹HTML结构 简单的看一段代码： 12&lt;p&gt;p元素&lt;/p&gt;&lt;p&gt;p元素&lt;/p&gt; 给所有p元素增加一个div包裹 1$(&apos;p&apos;).wrapAll(&apos;&lt;div&gt;&lt;/div&gt;&apos;) 最后的结构，2个P元素都增加了一个父div的结构 1234&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; **.wrapAll( function )** **：**一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象 通过回调的方式可以单独处理每一个元素 以上面案例为例， 123$(&apos;p&apos;).wrapAll(function() &#123; return &apos;&lt;div&gt;&lt;div/&gt;&apos;; &#125;) 以上的写法的结果如下，等同于warp的处理了 123456&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; --- 注意： .wrapAll()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套多层，但是最内层只能有一个元素。所有匹配元素将会被当作是一个整体，在这个整体的外部用指定的 HTML 结构进行包裹。 --- DOM包裹wrapAll()方法 点击,通过wrapAll方法给所有P元素增加父容器div 点击,通过wrapAll的回调方法给每个a元素增加父容器div p元素 p元素 a元素 a元素 123456789101112131415&lt;script type="text/javascript"&gt; $(".aaron1").on('click', function() &#123; //给所有p元素，增加父容器div $('p').wrapAll('&lt;div&gt;&lt;/div&gt;'); &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $(".aaron2").on('click', function() &#123; //wrapAll接受一个回调函数 //每一次遍历this都指向了合集中每一个a元素 $('a').wrapAll(function() &#123; return '&lt;div&gt;&lt;/div&gt;' &#125;) &#125;) &lt;/script&gt; ![image-20190311103935500](https://ws3.sinaimg.cn/large/006tKfTcgy1g0ynmxu671j30bj0hi0uq.jpg) --- # DOM包裹wrapInner()方法 12345678910111213&lt;h2&gt;DOM包裹wrapInner()方法&lt;/h2&gt; &lt;div class="left"&gt; &lt;div class="aaron1"&gt;点击,通过wrapInner方法给所有div元素增加内部父容器p&lt;/div&gt; &lt;div class="aaron2"&gt;点击,通过wrapInner的回调方法给每个div元素增加内部父容器a&lt;/div&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;div class="right1"&gt;p元素&lt;/div&gt; &lt;div class="right1"&gt;p元素&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt; &lt;div class="left1"&gt;a元素&lt;/div&gt; &lt;div class="left1"&gt;a元素&lt;/div&gt; &lt;/div&gt; 123456789101112131415&lt;script type="text/javascript"&gt; $(".aaron1").on('click', function() &#123; //给所有class=right1的div元素，增加内部包裹父容器p $('.right1').wrapInner('&lt;p&gt;&lt;/p&gt;'); &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $(".aaron2").on('click', function() &#123; //wrapInner接受一个回调函数 //每一次遍历this都指向了合集中每一个class=left1的div元素 $('.left1').wrapInner(function() &#123; return '&lt;a&gt;&lt;/a&gt;' &#125;) &#125;) &lt;/script&gt; ![image-20190311104323744](https://ws2.sinaimg.cn/large/006tKfTcgy1g0ynqw1onpj30a10hx76c.jpg) ---- # jQuery遍历之children()方法 jQuery是一个合集对象，如果想快速查找合集里面的第一级子元素，此时可以用children()方法。这里需要注意：.children(selector) 方法是返回匹配元素集合中每个元素的所有子元素（仅儿子辈，这里可以理解为就是父亲-儿子的关系） **理解节点查找关系：** 12345&lt;div class=&quot;div&quot;&gt; &lt;ul class=&quot;son&quot;&gt; &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 代码如果是$("div").children()，那么意味着只能找到ul，因为div与ul是父子关系，li与div是祖辈关系，因此无法找到。 **children()****无参数** 允许我们通过在DOM树中对这些元素的直接子元素进行搜索，并且构造一个新的匹配元素的jQuery对象 1注意：jQuery是一个合集对象，所以通过children是匹配合集中每一给元素的第一级子元素 .**children()****方法选择性地接受同一类型选择器表达式** 1$(&quot;div&quot;).children(&quot;.selected&quot;) 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 12345678910111213&lt;script type="text/javascript"&gt; $("#bt1").click(function() &#123; $('div').children(); &#125;)f &lt;/script&gt; &lt;script type="text/javascript"&gt; $("#bt2").click(function() &#123; //找到所有class=div的元素 //找到其对应的子元素ul，然后筛选出最后一个，给边宽加上颜色 $('.div').children(':last').css('border', '3px solid blue') &#125;) &lt;/script&gt; # jQuery遍历之find()方法 jQuery是一个合集对象，如果想快速查找DOM树中的这些元素的后代元素，此时可以用find()方法，这也是开发使用频率很高的方法。这里要注意 children与find方法的区别，children是父子关系查找，find是后代关系（包含父子关系) **理解节点查找关系：** 12345&lt;div class=&quot;div&quot;&gt; &lt;ul class=&quot;son&quot;&gt; &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 代码如果是$("div").find("li")，此时，li与div是祖辈关系，通过find方法就可以快速的查找到了 **.find()方法要注意的知识点：** - find是遍历当前元素集合中每个元素的后代。只要符合，不管是儿子辈，孙子辈都可以。 - 与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 '*'。 - find只在后代中遍历，不包括自己。 - 选择器 context 是由 .find() 方法实现的；因此，$('.item-ii').find('li') 等价于 $('li', '.item-ii')(找到类名为item-ii的标签下的li标签)。 **注意重点：** 123.find()和.children()方法是相似的1.children只查找第一级的子节点2.find查找范围包括子节点的所有后代节点 --- 12345678910111213&lt;script type="text/javascript"&gt; $("button:first").click(function() &#123; $('.left').find('li:last').css('border', '1px solid red') &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $("button:last").click(function() &#123; //找到所有p元素，然后筛选出子元素是span标签的节点 //改变其字体颜色 var $spans = $('span'); $("p").find($spans).css('color', 'red'); &#125;) &lt;/script&gt; --- # jQuery遍历之parent()方法 jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的父元素（这里可以理解为就是父亲-儿子的关系），此时可以用parent()方法 因为是父元素，这个方法只会向上查找一级 **理解节点查找关系：** 12345&lt;div class=&quot;div&quot;&gt; &lt;ul class=&quot;son&quot;&gt; &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 查找ul的父元素div, $(ul).parent()，就是这样简单的表达 **parent()****无参数** parent()方法允许我们能够在DOM树中搜索到这些元素的父级元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象 1注意：jQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素 **parent()****方法选择性地接受同一型选择器表达式** 1同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 12345678910111213&lt;script type="text/javascript"&gt; $("button:first").click(function() &#123; $('.level-3').parent().css('border', '1px solid red') &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $("button:last").click(function() &#123; //找到所有class=item-a的父元素 //然后给每个ul,然后筛选出最后一个，加上蓝色的边 $('.item-a').parent(':last').css('border', '1px solid blue') &#125;) &lt;/script&gt; --- #jQuery遍历之closest()方法 以选定的元素为中心，往内查找可以通过find、children方法。如果往上查找，也就是查找当前元素的父辈祖辈元素，jQuery提供了closest()方法，这个方法类似parents但是又有一些细微的区别，属于使用频率很高的方法 **closest()****方法接受一个匹配元素的选择器字符串** 从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素 例如：在div元素中，往上查找所有的li元素，可以这样表达 1$(&quot;div&quot;).closet(&quot;li&apos;) **注意：jQuery是一个合集对象，所以通过closest是匹配合集中每一个元素的祖先元素** **closest()****方法给定的****jQuery****集合或元素来过滤元素** 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个jQuery的对象 **注意事项：**在使用的时候需要特别注意下 粗看.parents()和.closest()是有点相似的，都是往上遍历祖辈元素，但是两者还是有区别的，否则就没有存在的意义了 1. 起始位置不同：.closest开始于当前元素 .parents开始于父元素 2. 遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合 3. 结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象 --- 123456789101112131415&lt;script type="text/javascript"&gt; $("button:first").click(function() &#123; $('li.item-1') .closest('.level-2') .css('border', '1px solid red') &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $("button:last").click(function() &#123; var itemB = $('.item-b') $('li.item-1') .closest(itemB) .css('border', '1px solid blue'); &#125;) &lt;/script&gt; ## jQuery遍历之next()方法 jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合，此时可以用next()方法 **理解节点查找关系：** 如下class="item-1"元素就是红色部分，那蓝色的class="item-2"就是它的兄弟元素 12345&lt;ul class=&quot;level-3&quot;&gt; &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;&lt;/ul&gt; **next****()****无参数** 允许我们找遍元素集合中紧跟着这些元素的直接兄弟元素，并根据匹配的元素创建一个新的 jQuery 对象。 1注意：jQuery是一个合集对象，所以通过next匹配合集中每一个元素的下一个兄弟元素 **next****()****方法选择性地接受同一类型选择器表达式** 1同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 12345678910111213&lt;script type="text/javascript"&gt; $("button:first").click(function() &#123; $('.item-1').next().css('border', '1px solid red') &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $("button:last").click(function() &#123; //找到所有class=item-3的li //然后筛选出第一个li，加上蓝色的边 $('.item-2').next(':first').css('border', '1px solid blue') &#125;) &lt;/script&gt; # jQuery遍历之prev()方法 jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合，此时可以用prev()方法 **理解节点查找关系：** 如下蓝色的class="item-2"的li元素，红色的节点就是它的prev兄弟节点 12345&lt;ul class=&quot;level-3&quot;&gt; &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;&lt;/ul&gt; **prev()****无参数** 取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合 1注意：jQuery是一个合集对象，所以通过prev是匹配合集中每一个元素的上一个兄弟元素 **prev()****方法选择性地接受同一类型选择器表达式** 1同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 --- 123456789101112131415&lt;button&gt;点击：prev无参数&lt;/button&gt; &lt;button&gt;点击：prev传递选择器&lt;/button&gt; &lt;script type="text/javascript"&gt; $("button:first").click(function() &#123; $('.item-2').prev().css('border', '1px solid red') &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $("button:last").click(function() &#123; //找到所有class=item-2的li //然后筛选出最后一个，加上蓝色的边 $('.item-3').prev(':last').css('border', '1px solid blue') &#125;) &lt;/script&gt; --- # jQuery遍历之siblings() Query是一个合集对象，如果想快速查找指定元素集合中每一个元素的同辈元素，此时可以用siblings()方法 **理解节点查找关系：** 如下蓝色的class="item-2"的li元素，红色的节点就是它的siblings兄弟节点 12345&lt;ul class=&quot;level-3&quot;&gt; &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;&lt;/ul&gt; **siblings()****无参数** 取得一个包含匹配的元素集合中每一个元素的同辈元素的元素集合 1注意：jQuery是一个合集对象，所以通过siblings是匹配合集中每一个元素的同辈元素 **siblings()****方法选择性地接受同一类型选择器表达式** 1同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 --- 123456789101112131415&lt;button&gt;点击：siblingsv无参数&lt;/button&gt; &lt;button&gt;点击：siblings传递选择器&lt;/button&gt; &lt;script type="text/javascript"&gt; $("button:first").click(function() &#123; $('.item-2').siblings().css('border', '2px solid red') &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $("button:last").click(function() &#123; //找到class=item-2的所有兄弟节点 //然后筛选出最后一个，加上蓝色的边 $('.item-2').siblings(':last').css('border', '2px solid blue') &#125;) &lt;/script&gt; # jQuery遍历之add()方法 jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。$()之后就意味着这个合集对象已经是确定的，如果后期需要再往这个合集中添加一新的元素要如何处理？jQuery为此提供add方法，用来创建一个新的jQuery对象 ，元素添加到匹配的元素集合中 1.add()的参数可以几乎接受任何的$()，包括一个jQuery选择器表达式，DOM元素，或HTML片段引用。 简单的看一个案例： 操作：选择所有的li元素，之后把p元素也加入到li的合集中 12345&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;新的p元素&lt;/p&gt; 处理一：传递选择器 1$(&apos;li&apos;).add(&apos;p&apos;) 处理二：传递dom元素 1$(&apos;li&apos;).add(document.getElementsByTagName(&apos;p&apos;)[0]) 还有一种方式，就是动态创建P标签加入到合集，然后插入到指定的位置，但是这样就改变元素的本身的排列了 1$(&apos;li&apos;).add(&apos;&lt;p&gt;新的p元素&lt;/p&gt;&apos;).appendTo(目标位置) $("button:last").click(function() { //把html结构'新的p元素' //加入到li的合集中，为了能够在页面上显示 //需要再重新appendTo到指定的节点处 //值得注意：整个结构位置都改变了 $('li').add('新的p元素').appendTo($('.right')) }) jQuery遍历之each()jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。比如我们操作$(“li”).css(‘’) 给所有的li设置style值，因为jQuery是一个合集对象，所以css方法内部就必须封装一个遍历的方法，被称为隐式迭代的过程。要一个一个给合集中每一个li设置颜色，这里方法就是each .each() 方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数 所以大体上了解3个重点： 123each是一个for循环的包装迭代器each通过回调的方式处理，并且会有2个固定的实参，索引与元素each回调方法中的this指向当前迭代的dom元素 12345$(&quot;li&quot;).each(function(index, element) &#123; index 索引 0,1 element是对应的li节点 li,li this 指向的是li&#125;) 这样可以在循环体会做一些逻辑操作了，如果需要提前退出，可以以通过返回 false以便在回调函数内中止循 1234567891011121314151617&lt;h2&gt;each方法&lt;/h2&gt; &lt;div class="left first-div"&gt; &lt;div class="div"&gt; &lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;ul&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt; &lt;li&gt;list item 6&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; 1234567891011121314151617181920212223&lt;button&gt;点击：each方法遍历元素&lt;/button&gt; &lt;button&gt;点击：each方法回调判断&lt;/button&gt; &lt;script type="text/javascript"&gt; $("button:first").click(function() &#123; //遍历所有的li //修改每个li内的字体颜色 $("li").each(function(index, element) &#123; $(this).css('color','red') &#125;) &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $("button:last").click(function() &#123; //遍历所有的li //修改偶数li内的字体颜色 $("li").each(function(index, element) &#123; if (index % 2) &#123; $(this).css('color','blue') &#125; &#125;) &#125;) &lt;/script&gt;]]></content>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquer基础 (一)—样式篇]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%89%8D%E7%AB%AF%2FJquery%E5%9F%BA%E7%A1%80%20%E6%85%95%E8%AF%BE%E7%BD%91%2F</url>
    <content type="text"><![CDATA[Jqueryuery基础 (一)—样式篇jQueryHelloWorld体验 HTML代码/文本/值1在一个 HTML 文档中, 我们可以使用 .html() 方法来获取任意一个元素的内容。 如果选择器匹配多于一个的元素，那么只有第一个匹配元素的 HTML 内容会被获取。 12345val 用于设定HTML内容的值function(index, html) 此函数返回一个HTML字符串。接受两个参数，index为元素在集合中的索引位置，html为原先的HTML值 返回p元素的内容。 1$(&apos;p&apos;).html(); 参数val 描述:设置所有 p 元素的内容 1$(&quot;p&quot;).html(&quot;Hello &lt;b&gt;world&lt;/b&gt;!&quot;); 使用函数来设置所有匹配元素的内容。 123$(&quot;p&quot;).html(function(n)&#123; return &quot;这个 p 元素的 index 是：&quot; + n; &#125;); #jQuery对象与DOM对象 123通过jQuery方法包装后的对象，是一个类数组对象。它与DOM对象完全不同，唯一相似的是它们都能操作DOM。通过jQuery处理DOM的操作，可以让开发者更专注业务逻辑的开发，而不需要我们具体知道哪个DOM节点有那些方法，也不需要关心不同浏览器的兼容性问题，我们通过jQuery提供的API进行开发，代码也会更加精短。 12345678910111213141516171819202122232425262728293031 &lt;!-- 使用JS原生语法 --&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; // 通过原生JS语法获取id为imooc1的元素p var p = document.getElementById('imooc1'); // 将元素p在html中内容改变 p.innerHTML = 'P1：您好！通过慕课网学习jQuery才是最佳的途径'; // 将元素p的内容颜色改为红色 p.style.color = 'red'; &#125; &lt;/script&gt; &lt;!-- 使用jQuery语法 --&gt; &lt;script type="text/javascript"&gt; $(document).ready(function() &#123; /** * 通过jQuery语法获取id为imooc2的元素获得一个jQuery对象 * 调用该对象的html()方法进行更改内容 * 调用该对象的css()方法进行更改颜色样式 */ var $p = $('#imooc2'); $p.html('P2：您好！通过慕课网学习jQuery才是最佳的途径').css('color','red'); &#125;); &lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;p id="imooc1"&gt;&lt;/p&gt; &lt;p id="imooc2"&gt;&lt;/p&gt;&lt;/body&gt; jQuery的处理： 12var $p = $(&apos;#imooc&apos;);$p.html(&apos;您好！通过慕课网学习jQuery才是最佳的途径&apos;).css(&apos;color&apos;,&apos;red&apos;); 通过$(‘#imooc’)方法会得到一个​$p的jQuery对象，$p是一个类数组对象。这个对象里面包含了DOM对象的信息，然后封装了很多操作方法，调用自己的方法html与css，得到的效果与标准的JavaScript处理结果是一致的。 jQuery对象转化成DOM对象 jQuery是一个类数组对象，而DOM对象就是一个单独的DOM元素。 如何把jQuery对象转成DOM对象？ 利用数组下标的方式读取到jQuery中的DOM对象 HTML代码 123&lt;div&gt;元素一&lt;/div&gt;&lt;div&gt;元素二&lt;/div&gt;&lt;div&gt;元素三&lt;/div&gt; JavaScript代码 123var $div = $(&apos;div&apos;) //jQuery对象var div = $div[0] //转化成DOM对象div.style.color = &apos;red&apos; //操作dom对象的属性 用jQuery找到所有的div元素（3个），因为jQuery对象也是一个数组结构，可以通过数组下标索引找到第一个div元素，通过返回的div对象，调用它的style属性修改第一个div元素的颜色。这里需要注意的一点是，数组的索引是从0开始的，也就是第一个元素下标是0 通过jQuery自带的get()方法 jQuery对象自身提供一个.get() 方法允许我们直接访问jQuery对象中相关的DOM节点，get方法中提供一个元素的索引： 123var $div = $(&apos;div&apos;) //jQuery对象var div = $div.get(0) //通过get方法，转化成DOM对象div.style.color = &apos;red&apos; //操作dom对象的属性 DOM对象转化成jQuery对象相比较jQuery转化成DOM，开发中更多的情况是把一个dom对象加工成jQuery对象。$(参数)是一个多功能的方法，通过传递不同的参数而产生不同的作用。 1如果传递给$(DOM)函数的参数是一个DOM对象，jQuery方法会把这个DOM对象给包装成一个新的jQuery对象 通过$(dom)方法将普通的dom对象加工成jQuery对象之后，我们就可以调用jQuery的方法了 123&lt;div&gt;元素一&lt;/div&gt;&lt;div&gt;元素二&lt;/div&gt;&lt;div&gt;元素三&lt;/div&gt; 1234567891011&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div'); //dom对象 //将dom节点div转化为$div的jquery对象 $jquery对象=$(dom对象) var $div = $(div);//jquery对象 var $first = $div.first(); //找到第一个div元素 $first.css('color', 'red'); //给第一个元素设置颜色 jQuery选择器之id选择器id选择器：一个用来查找的ID，即元素的id属性 1$( &quot;#id&quot; ) id选择器也是基本的选择器，jQuery内部使用JavaScript函数document.getElementById()来处理ID的获取。原生语法的支持总是非常高效的，所以在操作DOM的获取上，如果能采用id的话尽然考虑用这个选择器 1id是唯一的，每个id值在一个页面中只能使用一次。如果多个元素分配了相同的id，将只匹配该id选择集合的第一个DOM元素。但这种行为不应该发生;有超过一个元素的页面使用相同的id是无效的 1234567891011121314151617181920iv id="imooc"&gt; &lt;p&gt;id="imooc"&lt;/p&gt; &lt;p&gt;jQuery选中&lt;/p&gt; &lt;/div&gt; &lt;div id="imooc"&gt; &lt;p&gt;id="imooc"&lt;/p&gt; &lt;p&gt;jQuery未选中&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; //通过原生方法处理 var div = document.getElementById('aaron'); div.style.border = "3px solid blue"; &lt;/script&gt; &lt;script type="text/javascript"&gt; //通过jQuery直接传入id //id的唯一，只选择到了第一个匹配的id为imooc的div节点 $("imooc").css("border", "3px solid red"); &lt;/script&gt; #jQuery选择器之类选择器 类选择器，顾名思义，通过class样式类名来获取节点 描述： 1$( &quot;.class&quot; ) 类选择器，相对id选择器来说，效率相对会低一点，但是优势就是可以多选 1jQuery除了选择上的简单，而且没有再次使用循环处理 //通过原生方法处理 //样式是可以多选的，所以得到的是一个合集 //需要通过循环给合集中每一个元素修改样式 var divs = document.getElementsByClassName('aaron'); for (var i = 0; i < divs.length; i++) { divs[i].style.border = "3px solid blue"; } --- //通过jQuery直接传入class //class选择器可以选择多个元素 $(".imooc").css("border", "3px solid red"); --- # jQuery的选择器之元素选择器 元素选择器：根据给定（HTML）标记名称选择所有的元素 描述： 1$（“元素”） 搜索指定元素标签名的所有节点，这个是一个合集的操作。同样的也有原生方法的getElementsByTagName（）函数支持 第一组：通过的getElementsByTagName方法得到页面所有的元素 1var divs = document.getElementsByTagName（&apos;div&apos;）; 的div是DOM合集对象，通过循环给每一个合集中的元素赋予新的边界样式 第二组：同样的效果，$（ “P”）选取所有的元素，通过CSS方法直接赋予样式 # jQuery选择器之全选择器（*选择器） 在CSS中，经常会在第一行写下这样一段样式 1* &#123;padding: 0; margin: 0;&#125; 通配符*意味着给所有的元素设置默认的边距。jQuery中我们也可以通过传递*选择器来选中文档页面中的元素 描述： 1$( &quot;*&quot; ) //获取页面中所有的元素 var elements2 = $("*") ; //原生与jQuery方法比较 //===表示数据和类型都相等 if(elements2.length === elements1.length){ elements2.css("border","1px solid red"); } --- # jQuery选择器之层级选择器 文档中的所有的节点之间都是有这样或者那样的关系。我们可以把节点之间的关系可以用传统的家族关系来描述，可以把文档树当作一个家谱，那么节点与节点直接就会存在父子，兄弟，祖孙的关系了。 选择器中的层级选择器就是用来处理这种关系 1子元素 后代元素 兄弟元素 相邻元素 通过一个列表，对比层级选择器的区别 ![image-20190309113655370](https://ws2.sinaimg.cn/large/006tKfTcgy1g0we1zgky9j30l7085tc3.jpg) 仔细观察层级选择器之间还是有很多相似与不同点 1. 层级选择器都有一个参考节点 2. 后代选择器包含子选择器的选择的内容 3. 一般兄弟选择器包含相邻兄弟选择的内容 4. 相邻兄弟选择器和一般兄弟选择器所选择到的元素，必须在同一个父元素下 --- 子选择器与后代选择器 12345678910111213141516171819202122&lt;div class="left"&gt; &lt;div class="aaron"&gt; &lt;p&gt;div下的第一个p元素&lt;/p&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;p&gt;div下的第一个p元素&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="right"&gt; &lt;div class="imooc"&gt; &lt;article&gt; &lt;p&gt;div下的article下的p元素&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="imooc"&gt; &lt;article&gt; &lt;p&gt;div下的article下的p元素&lt;/p&gt; &lt;/article&gt; &lt;/div&gt;&lt;/div&gt; 12345&lt;script type="text/javascript"&gt; //子选择器 //$('div &gt; p') 选择所有div元素里面的子元素P 仅仅只是在&lt;div &gt;下面的元素P 不包括下面的下面的 $('div &gt; p').css("border", "1px groove blue"); &lt;/script&gt; 12345&lt;script type="text/javascript"&gt; //后代选择器 //$('div p') 选择所有div元素里面的p元素 只要是&lt;div&gt;下面的&lt;p&gt;元素 全部选中 $('div p').css("border", "1px groove red"); &lt;/script&gt; 相邻兄弟选择器与一般兄弟选择器 1234567891011&lt;h2&gt;相邻兄弟选择器与一般兄弟选择器&lt;/h2&gt; &lt;div class="bottom"&gt; &lt;div&gt;兄弟节点div, +~选择器不能向前选择&lt;/div&gt; &lt;span class="prev"&gt;选择器span元素&lt;/span&gt; &lt;div&gt;span后第一个兄弟节点div&lt;/div&gt; &lt;div&gt;兄弟节点div &lt;div class="small"&gt;子元素div&lt;/div&gt; &lt;/div&gt; &lt;span&gt;兄弟节点span,不可选&lt;/span&gt; &lt;div&gt;兄弟节点div&lt;/div&gt; &lt;/div&gt; 12345&lt;script type="text/javascript"&gt; //相邻兄弟选择器 //选取prev后面的第一个的div兄弟节点 $(".prev+div") $(".prev+div").css("border", "3px groove blue"); &lt;/script&gt; 12345&lt;script type="text/javascript"&gt; //一般相邻选择器 //选取prev后面的所有的div兄弟节点 $(".prev ~ div") $(".prev ~ div").css("border", "3px groove yellow"); &lt;/script&gt; # jQuery选择器之基本筛选选择器 筛选选择器的用法与CSS中的伪元素相似，选择器用冒号“：”开头，通过一个列表，看看基本筛选器的描述： ![image-20190309115232270](https://ws3.sinaimg.cn/large/006tKfTcgy1g0wei8xec5j30ko0h7jxg.jpg) --- 注意事项： 1. :eq(), :lt(), :gt(), :even, :odd 用来筛选他们前面的匹配表达式的集合元素，根据之前匹配的元素在进一步筛选，注意jQuery合集都是从0开始索引 2. gt是一个段落筛选，从指定索引的下一个开始，gt(1) 实际从2开始 — 12345678910111213141516171819202122232425&lt;body&gt; &lt;h2&gt;基本筛选器&lt;/h2&gt; &lt;h3&gt;:first/:last/:even/:odd&lt;/h3&gt; &lt;div class="left"&gt; &lt;div class="div"&gt; &lt;p&gt;div:first&lt;/p&gt; &lt;p&gt;:even&lt;/p&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;p&gt;:odd&lt;/p&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;p&gt;:even&lt;/p&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;p&gt;:odd&lt;/p&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;p&gt;:even&lt;/p&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;p&gt;div:last&lt;/p&gt; &lt;p&gt;:odd&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; ![image-20190309115721147](https://ws4.sinaimg.cn/large/006tKfTcgy1g0wen80dpjj30ck0araaw.jpg) --- 1234&lt;script type="text/javascript"&gt; //找到第一个div 根据类选择器来选择的 $(".div:first").css("color", "#CD00CE"); &lt;/script&gt; 1234&lt;script type="text/javascript"&gt; //找到最后一个div $(".div:last").css("color", "#CD00CE"); &lt;/script&gt; ![image-20190309120036431](https://ws1.sinaimg.cn/large/006tKfTcgy1g0weqlwwg0j30aj07yaan.jpg) --- ![image-20190309120200550](https://ws1.sinaimg.cn/large/006tKfTcgy1g0wes71c2bj309k06fq3b.jpg) 1234&lt;script type="text/javascript"&gt; //:even 选择所引值为偶数的元素，从 0 开始计数 $(".div:even").css("color", "#CD00CE"); &lt;/script&gt; 1234&lt;script type="text/javascript"&gt; //:odd 选择所引值为奇数的元素，从 0 开始计数 $(".div:odd").css("color", "#CD00CE"); &lt;/script&gt; ## 注意 过滤器都是在div里面过滤的 1234567891011121314151617181920&lt;h3&gt;:eq/:gt/:lt&lt;/h3&gt; &lt;div class="left"&gt; &lt;div class="aaron"&gt; &lt;p&gt;:lt(3)&lt;/p&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;p&gt;:lt(3)&lt;/p&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;p&gt;:eq(2)&lt;/p&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;p&gt;:gt(3)&lt;/p&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;p&gt;:gt(3)&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 12345&lt;script type="text/javascript"&gt; //:eq //选择单个 $(".aaron:eq(2)").css("border", "3px groove blue"); &lt;/script&gt; 1234&lt;script type="text/javascript"&gt; //:gt 选择匹配集合中所有索引值大于给定index参数的元素$(".aaron:gt(2)").css("border", "3px groove blue"); &lt;/script&gt; 12345 &lt;script type="text/javascript"&gt;//:lt 选择匹配集合中所有索引值小于给定index参数的元素//与:gt相反$(".aaron:gt(2)").css("color", "#CD00CD");&lt;/script&gt; 123456 &lt;script type="text/javascript"&gt; //:not 选择所有元素去除不匹配给定的选择器的元素 //选中所有紧接着没有checked属性的input元素后的p元素，赋予颜色 $("input:not(:checked) + p").css("background-color", "#CD00CD");&lt;/script&gt; # jQuery选择器之内容筛选选择器 基本筛选选择器针对的都是元素DOM节点，如果我们要通过内容来过滤，jQuery也提供了一组内容筛选选择器，当然其规则也会体现在它所包含的子元素或者文本内容上 内容过滤器描述如下表： ![image-20190309120754082](https://ws2.sinaimg.cn/large/006tKfTcgy1g0wey8tqrtj30ib07cac8.jpg) --- **注意事项：** 1. :contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素 2. 如果:contains匹配的文本包含在元素的子元素中，同样认为是符合条件的。 3. :parent与:empty是相反的，两者所涉及的子元素，包括文本节点 123456789101112131415161718&lt;h2&gt;内容筛选器&lt;/h2&gt; &lt;h3&gt;:contains/:has&lt;/h3&gt; &lt;div class="left"&gt; &lt;div class="div"&gt; &lt;p&gt;:contains&lt;/p&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;p&gt;:contains&lt;/p&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;p&gt; &lt;span&gt;:has&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;p&gt;:contains&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; ![image-20190309121007202](https://ws2.sinaimg.cn/large/006tKfTcgy1g0wf0i5safj30ae08bwey.jpg) 12345&lt;script type="text/javascript"&gt; //查找所有class='div'中DOM元素中包含"contains"的元素节点文本类容 //并且设置颜色 $(".div:contains(':contains')").css("color", "#CD00CD");&lt;/script&gt; 123456&lt;script type="text/javascript"&gt; //查找所有class='div'中DOM元素中包含"span"的元素节点 //并且设置颜色 $(".div:has(span)").css("color", "blue");&lt;/script&gt; 123456789101112131415&lt;h3&gt;:parent/:empty&lt;/h3&gt; &lt;div class="left"&gt; &lt;div class="aaron"&gt; &lt;a&gt;:parent&lt;/a&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;a&gt;:parent&lt;/a&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;a&gt;:parent&lt;/a&gt; &lt;/div&gt; &lt;div class="aaron"&gt; &lt;a&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; ![image-20190309134925126](https://ws2.sinaimg.cn/large/006tKfTcgy1g0whvu0gkvj309i06c0sw.jpg) //选择所有包含子元素或者文本的a元素 //增加一个蓝色的边框 $("a:parent").css("border", "3px groove blue"); 12345&lt;script type="text/javascript"&gt; //选择所有包含子元素或者文本的a元素 //增加一个蓝色的边框 $("a:parent").css("border", "3px groove blue"); &lt;/script&gt; 12345&lt;script type="text/javascript"&gt; //找到a元素下面的所有空节点(没有子元素) //增加一段文本与边框 $("a:empty").text(":empty").css("border", "3px groove red"); &lt;/script&gt; jQuery选择器之可见性筛选选择器元素有显示状态与隐藏状态，jQuery根据元素的状态扩展了可见性筛选选择器:visible与:hidden 描述如下： 这2个选择器都是 jQuery 延伸出来的，看起来比较简单，但是元素可见性依赖于适用的样式 1:hidden选择器，不仅仅包含样式是display=&quot;none&quot;的元素，还包括隐藏表单、visibility等等 我们有几种方式可以隐藏一个元素： CSS display的值是none。 type=”hidden”的表单元素。 宽度和高度都显式设置为0。 一个祖先元素是隐藏的，该元素是不会在页面上显示 CSS visibility的值是hidden CSS opacity的指是0 123如果元素中占据文档中一定的空间,元素被认为是可见的。可见元素的宽度或高度，是大于零。元素的visibility: hidden 或 opacity: 0被认为是可见的，因为他们仍然占用空间布局。 不在文档中的元素是被认为是不可见的，如果当他们被插入到文档中，jQuery没有办法知道他们是否是可见的，因为元素可见性依赖于适用的样式 1234567891011121314151617181920&lt;h2&gt;可见性筛选选择器&lt;/h2&gt;&lt;h3&gt;:visible/:hidden&lt;/h3&gt;&lt;div class="left"&gt; &lt;div class="div"&gt; &lt;a&gt;display&lt;/a&gt; &lt;p id="div1" style="display:none;"&gt;display&lt;/p&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;a&gt;width&lt;/a&gt; &lt;a&gt;height&lt;/a&gt; &lt;p id="div2" style="width:0;height:0"&gt;width/height&lt;/p&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;a&gt;visibility&lt;/a&gt; &lt;a&gt;opacity&lt;/a&gt; &lt;p id="div3" style="visibility:hidden;opacity:0"&gt;visibility&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;p id="show"&gt;&lt;/p&gt; 123456789&lt;script type="text/javascript"&gt; //查找id = div3的DOM元素,是否可见 show( '#div3:visible' );&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找id = div1的DOM元素,是否隐藏 show( '#div1:hidden; );&lt;/script&gt; jQuery选择器之属性筛选选择器属性选择器让你可以基于属性来定位一个元素。可以只指定该元素的某个属性，这样所有使用该属性而不管它的值，这个元素都将被定位，也可以更加明确并定位在这些属性上使用特定值的元素，这就是属性选择器展示它们的威力的地方。 1234在这么多属性选择器中[attr="value"]和[attr*="value"]是最实用的[attr="value"]能帮我们定位不同类型的元素，特别是表单form元素的操作，比如说input[type="text"],input[type="checkbox"]等[attr*="value"]能在网站中帮助我们匹配不同类型的文件 12345678910111213141516&lt;h2&gt;属性筛选选择器&lt;/h2&gt; &lt;h3&gt;[att=val]、[att]、[att|=val]、[att~=val]&lt;/h3&gt; &lt;div class="left" testattr="true" &gt; &lt;div class="div" testattr="true" name='p1'&gt; &lt;a&gt;[att=val]&lt;/a&gt; &lt;/div&gt; &lt;div class="div" testattr="true" p2&gt; &lt;a&gt;[att]&lt;/a&gt; &lt;/div&gt; &lt;div class="div" testattr="true" name="-"&gt; &lt;a&gt;[att|=val]&lt;/a&gt; &lt;/div&gt; &lt;div class="div" testattr="true" name="a b"&gt; &lt;a&gt;[att~=val]&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; 1234&lt;script type="text/javascript"&gt; //查找所有div中，属性name=p1的div元素 &lt;div class="div" testattr="true" name='p1'&gt; $('div[name=p1]').css("border", "3px groove red"); &lt;/script&gt; 1234&lt;script type="text/javascript"&gt; //查找所有div中，有属性p2的div元素 &lt;div class="div" testattr="true" p2&gt; $('div[p2]').css("border", "3px groove blue"); &lt;/script&gt; 1234&lt;script type="text/javascript"&gt; //查找所有div中，有属性name中的值只包含一个连字符“-”的div元素 'div[name|="-"]" $('div[name|="-"]').css("border", "3px groove #00FF00"); &lt;/script&gt; 1234&lt;script type="text/javascript"&gt; //查找所有div中，有属性name中的值包含一个连字符“空”和“a”的div元素 $('div[name~="a"]').css("border", "3px groove #668B8B"); &lt;/script&gt; 123456789101112131415&lt;h3&gt;[att^=val]、[att*=val]、[att$=val]、[att!=val]&lt;/h3&gt; &lt;div class="left" testattr="true" &gt; &lt;div class="div" testattr="true" name='imooc-aaorn'&gt; &lt;a&gt;[att^=val]&lt;/a&gt; &lt;/div&gt; &lt;div class="div" testattr="true" name='aaorn-imooc'&gt; &lt;a&gt;[att$=val]&lt;/a&gt; &lt;/div&gt; &lt;div class="div" testattr="true" name="attr-test-selector"&gt; &lt;a&gt;[att*=val]&lt;/a&gt; &lt;/div&gt; &lt;div class="div" name="a b"&gt; &lt;a&gt;[att!=val]&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; 123456789&lt;script type="text/javascript"&gt; //查找所有div中，属性name的值是用imooc开头的 $('div[name^=imooc]').css("border", "3px groove red"); &lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有div中，属性name的值是用imooc结尾的 $('div[name$=imooc]').css("border", "3px groove blue"); &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //查找所有div中，有属性name中的值包含一个test字符串的div元素 $(&apos;div*=test&apos;).css(&quot;border&quot;, &quot;3px groove #00FF00&quot;); &lt;/script&gt; 1234&lt;script type=&quot;text/javascript&quot;&gt; //查找所有div中，有属性name中的值包含一个test字符串的div元素 $(&apos;div*=test&apos;).css(&quot;border&quot;, &quot;3px groove #00FF00&quot;); &lt;/script&gt; jQuery选择器之子元素筛选选择器子元素筛选选择器不常使用，其筛选规则比起其它的选择器稍微要复杂点 注意事项： :first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。这相当于:nth-child(1) :last 只匹配一个单独的元素， :last-child 选择器可以匹配多个元素：即，为每个父级元素匹配最后一个子元素 如果子元素只有一个的话，:first-child与:last-child是同一个 :only-child匹配某个元素是父元素中唯一的子元素，就是说当前子元素是父元素中唯一的元素，则匹配 jQuery实现:nth-child(n)是严格来自CSS规范，所以n值是“索引”，也就是说，从1开始计数，:nth-child(index)从1开始的，而eq(index)是从0开始的 nth-child(n) 与 :nth-last-child(n) 的区别前者是从前往后计算，后者从后往前计算 12345&lt;script type=&quot;text/javascript&quot;&gt; //查找class=&quot;first-div&quot;下的第一个a元素 //针对所有父级下的第一个 $(&apos;.first-div a:first-child&apos;).css(&quot;color&quot;, &quot;#CD00CD&quot;); &lt;/script&gt; 123456&lt;script type=&quot;text/javascript&quot;&gt; //查找class=&quot;first-div&quot;下的最后一个a元素 //针对所有父级下的最后一个 //如果只有一个元素的话，last也是第一个元素 $(&apos;.first-div a:last-child&apos;).css(&quot;color&quot;, &quot;red&quot;); &lt;/script&gt; 12345&lt;script type=&quot;text/javascript&quot;&gt; //查找class=&quot;first-div&quot;下的只有一个子元素的a元素 $(&apos;.first-div a:only-child&apos;).css(&quot;color&quot;, &quot;blue&quot;);&lt;/script&gt; 1234&lt;script type=&quot;text/javascript&quot;&gt; //查找class=&quot;last-div&quot;下的第二个a元素 $(&apos;.last-div a:nth-child(2)&apos;).css(&quot;color&quot;, &quot;#CD00CD&quot;);&lt;/script&gt; 1234&lt;script type=&quot;text/javascript&quot;&gt; //查找class=&quot;last-div&quot;下的倒数第二个a元素 $(&apos;.last-div a:nth-last-child(2)&apos;.css(&quot;color&quot;, &quot;red&quot;);&lt;/script&gt; jQuery选择器之表单元素选择器无论是提交还是传递数据，表单元素在动态交互页面的作用是非常重要的。jQuery中专门加入了表单选择器，从而能够极其方便地获取到某个类型的表单元素 表单选择器的具体方法描述： 除了input筛选选择器，几乎每个表单类别筛选器都对应一个input元素的type值。大部分表单类别筛选器可以使用属性筛选器替换。比如 $(‘:password’) == $(‘[type=password]’) 子元素筛选选择器123456789101112131415&lt;h3&gt;input、text、password、radio、checkbox&lt;/h3&gt;&lt;h3&gt;submit、image、reset、button、file&lt;/h3&gt;&lt;div class="left first-div"&gt; &lt;form&gt; &lt;input type="text" value="text类型"/&gt; &lt;input type="password" value="password"/&gt; &lt;input type="radio"/&gt; &lt;input type="checkbox"/&gt; &lt;input type="submit" /&gt; &lt;input type="image" /&gt; &lt;input type="reset" /&gt; &lt;input type="button" value="Button" /&gt; &lt;input type="file" /&gt; &lt;/form&gt;&lt;/div&gt; 12345&lt;script type="text/javascript"&gt; //查找所有 input, textarea, select 和 button 元素 //:input 选择器基本上选择所有表单控件 $(':input').css("border", "1px groove red"); &lt;/script&gt; jQuery选择器之表单对象属性筛选选择器除了表单元素选择器外，表单对象属性筛选选择器也是专门针对表单元素的选择器，可以附加在其他选择器的后面，主要功能是对所选择的表单元素进行筛选 注意事项： 选择器适用于复选框和单选框，对于下拉框元素, 使用 :selected 选择器 在某些浏览器中，选择器:checked可能会错误选取到元素，所以保险起见换用选择器input:checked，确保只会选取元素 12345&lt;form&gt; &lt;input type="text" value="未设置disabled" /&gt; &lt;input type="text" value="设置disabled" disabled="disabled" /&gt; &lt;input type="text" value="未设置disabled" /&gt; &lt;/form&gt; 12345678910&lt;script type="text/javascript"&gt; //查找所有input所有可用的（未被禁用的元素）input元素。 $('input:enabled').css("border", "2px groove red");&lt;/script&gt;&lt;script type="text/javascript"&gt; //查找所有input所有不可用的（被禁用的元素）input元素。 $('input:disabled').css("border", "2px groove blue");&lt;/script&gt; 123456789101112131415&lt;h3&gt;checked、selected&lt;/h3&gt; &lt;form&gt; &lt;input type="checkbox" checked="checked"&gt; &lt;input type="checkbox"&gt; &lt;input type="radio" checked&gt; &lt;input type="radio"&gt; &lt;select name="garden" multiple="multiple"&gt; &lt;option&gt;imooc&lt;/option&gt; &lt;option selected="selected"&gt;慕课网&lt;/option&gt; &lt;option&gt;aaron&lt;/option&gt; &lt;option selected="selected"&gt;博客园&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; 123456&lt;script type="text/javascript"&gt; //查找所有input所有勾选的元素(单选框,复选框) //移除input的checked属性 $('input:checked').removeAttr('checked')&lt;/script&gt; 12345&lt;script type="text/javascript"&gt; //查找所有option元素中,有selected属性被选中的选项 //移除option的selected属性 $('input:selected').removeAttr('selected')&lt;/script&gt; jQuery选择器之特殊选择器this相信很多刚接触jQuery的人，很多都会对$(this)和this的区别模糊不清，那么这两者有什么区别呢 this是JavaScript中的关键字，指的是当前的上下文对象，简单的说就是方法/属性的所有者 12345678var imooc = &#123; name:&quot;慕课网&quot;, getName:function()&#123; //this,就是imooc对象 return this.name; &#125;&#125;imooc.getName(); //慕课网 当然在JavaScript中this是动态的，也就是说这个上下文对象都是可以被动态改变的(可以通过call,apply等方法)，具体的大家可以查阅相关资料 同样的在DOM中this就是指向了这个html元素对象，因为this就是DOM元素本身的一个引用 假如给页面一个P元素绑定一个事件: 123456p.addEventListener(&apos;click&apos;,function()&#123; //this === p //以下两者的修改都是等价的 this.style.color = &quot;red&quot;; p.style.color = &quot;red&quot;;&#125;,false); 通过addEventListener绑定的事件回调中，this指向的是当前的dom对象，所以再次修改这样对象的样式，只需要通过this获取到引用即可 1this.style.color = &quot;red&quot; 但是这样的操作其实还是很不方便的，这里面就要涉及一大堆的样式兼容，如果通过jQuery处理就会简单多了，我们只需要把this加工成jQuery对象 12345$(&apos;p&apos;).click(function()&#123; //把p元素转化成jQuery的对象 var $this= $(this) $this.css(&apos;color&apos;,&apos;red&apos;)&#125;) 通过把$()方法传入当前的元素对象的引用this，把这个this加工成jQuery对象，我们就可以用jQuery提供的快捷方法直接处理样式了 12this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值。 1234567891011121314151617181920&lt;h2&gt;特殊选择器this&lt;/h2&gt;&lt;p id="test1"&gt;点击测试：通过原生DOM处理&lt;/p&gt;&lt;p id="test2"&gt;点击测试：通过原生jQuery处理&lt;/p&gt;&lt;script type="text/javascript"&gt; var p1 = document.getElementById('test1') p1.addEventListener('click',function()&#123; //直接通过dom的方法改变颜色 this.style.color = "red"; &#125;,false);&lt;/script&gt;&lt;script type="text/javascript"&gt; $('#test2').click(function()&#123; //通过包装成jQuery对象改变颜色 $(this).css('color','blue'); &#125;)&lt;/script&gt; jQuery的属性与样式之.attr()与.removeAttr()每个元素都有一个或者多个特性，这些特性的用途就是给出相应元素或者其内容的附加信息。如：在img元素中，src就是元素的特性，用来标记图片的地址。 操作特性的DOM方法主要有3个，getAttribute方法、setAttribute方法和removeAttribute方法，就算如此在实际操作中还是会存在很多问题，这里先不说。而在jQuery中用一个attr()与removeAttr()就可以全部搞定了，包括兼容问题 1jQuery中用attr()方法来获取和设置元素属性,attr是attribute（属性）的缩写，在jQuery DOM操作中会经常用到attr() attr()有4个表达式 attr(传入属性名)：获取属性的值 attr(属性名, 属性值)：设置属性的值 attr(属性名,函数值)：设置属性的函数值 attr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … } removeAttr()删除方法 .removeAttr( attributeName ) : 为匹配的元素集合中的每个元素中移除一个属性（attribute） 优点： attr、removeAttr都是jQuery为了属性操作封装的，直接在一个 jQuery 对象上调用该方法，很容易对属性进行操作，也不需要去特意的理解浏览器的属性名不同的问题 注意的问题： dom中有个概念的区分：Attribute和Property翻译出来都是“属性”，《js高级程序设计》书中翻译为“特性”和“属性”。简单理解，Attribute就是dom节点自带的属性 例如：html中常用的id、class、title、align等： 1&lt;div id=&quot;immooc&quot; title=&quot;慕课网&quot;&gt;&lt;/div&gt; 而Property是这个DOM元素作为对象，其附加的内容，例如,tagName, nodeName, nodeType,, defaultChecked, 和 defaultSelected 使用.prop()方法进行取值或赋值等 1获取Attribute就需要用attr，获取Property就需要用prop 12345678&lt;h2&gt;.attr()与.removeAttr()&lt;/h2&gt; &lt;h3&gt;.attr&lt;/h3&gt; &lt;form&gt; &lt;input type="text" value="设置value" /&gt; &lt;input type="text" value="获取value"/&gt; &lt;input type="text" value="回调拼接value" /&gt; &lt;input type="text" value="删除value" /&gt; &lt;/form&gt; 1234 &lt;script type="text/javascript"&gt;//找到第一个input，通过attr设置属性value的值 value="设置value"改为 value=attributeName，value $("input:first").attr('value','.attr( attributeName, value )') &lt;/script&gt; 12345&lt;script type="text/javascript"&gt; //找到第二个input，通过attr获取属性value的值 var $atr=$('input:eq(1)').attr('value'); alert($atr);&lt;/script&gt; 12345678&lt;script type="text/javascript"&gt; //找到第三个input，通过使用一个函数来设置属性 //可以根据该元素上的其它属性值返回最终所需的属性值 //例如，我们可以把新的值与现有的值联系在一起： $('input:eq(2)').attr('value',function(i, val)&#123; return '通过function设置' + val &#125;) &lt;/script&gt; 1234567 &lt;script type="text/javascript"&gt; //找到第四个input，通过使用removeAttr删除属性 $('input:eq(3)').removeAttr('value') &lt;/script&gt;1:属性名称。2:返回属性值的函数,第一个参数为当前元素的索引值，第二个参数为原先的属性值。 jQuery的属性与样式之html()及.text()读取、修改元素的html结构或者元素的文本内容是常见的DOM操作，jQuery针对这样的处理提供了2个便捷的方法.html()与.text() .html()方法 获取集合中第一个匹配元素的HTML内容 或 设置每一个匹配元素的html内容，具体有3种用法： .html() 不传入值，就是获取集合中第一个匹配元素的HTML内容 .html( htmlString ) 设置每一个匹配元素的html内容 .html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数 1.html()方法内部使用的是DOM的innerHTML属性来处理的，所以在设置与获取上需要注意的一个最重要的问题，这个操作是针对整个HTML内容（不仅仅只是文本内容） .text()方法 得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。，具体有3种用法： .text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代 .text( textString ) 用于设置匹配元素内容的文本 .text( function(index, text) ) 用来返回设置文本内容的一个函数 注意事项： 1.text()结果返回一个字符串，包含所有匹配元素的合并文本 .html与.text的异同: .html与.text的方法操作是一样，只是在具体针对处理对象不同 .html处理的是元素内容，.text处理的是文本内容 .html只能使用在HTML文档中，.text 在XML 和 HTML 文档中都能使用 如果处理的对象只有一个子文本节点，那么html处理的结果与text是一样的 火狐不支持innerText属性，用了类似的textContent属性，.text()方法综合了2个属性的支持，所以可以兼容所有浏览器 12345678910111213141516171819&lt;h3&gt;.html()与.text()&lt;/h3&gt; &lt;div class="left first-div"&gt; &lt;div class="div"&gt; &lt;a&gt;:first-child&lt;/a&gt; &lt;a&gt;第二个元素&lt;/a&gt; &lt;a&gt;:last-child&lt;/a&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;a&gt;:first-child&lt;/a&gt; &lt;a&gt;第二个元素&lt;/a&gt; &lt;a&gt;:last-child&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;h4&gt;显示通过html方法获取到的内容&lt;/h4&gt; &lt;p&gt;&lt;/p&gt; &lt;h4&gt;显示通过text方法获取到的内容&lt;/h4&gt; &lt;p&gt;&lt;/p&gt; 123456&lt;script type="text/javascript"&gt; //显示出html方法获取到的内容 //.html()是整个html文档结构 $('p:first').text( $(".first-div").html()); &lt;/script&gt; 12345&lt;script type="text/javascript"&gt; //显示出text方法获取到的内容 //.text()是文本内容的合集 $('p:last').text( $(".first-div").text() ) &lt;/script&gt; 1234&lt;script type="text/javascript"&gt; //通过.text()方法替换文本内容 $(".left a:first").html('替换第一个a元素的内容') &lt;/script&gt; 123456789101112&lt;script type="text/javascript"&gt; //通过.html()方法替换html结构 $(".left div:first").html('整个div的子节点都被替换了') &lt;/script&gt; &lt;script type="text/javascript"&gt; //通过.text()的回调，获取原本的内容，修改，在重新赋值 $(".left a:first").text(function(idnex,text)&#123; return '增加新的文本内容' + text &#125;) &lt;/script&gt; jQuery的属性与样式之.val()1jQuery中有一个.val()方法主要是用于处理表单元素的值，比如 input, select 和 textarea。 .val()方法 .val()无参数，获取匹配的元素集合中第一个元素的当前值 .val( value )，设置匹配的元素集合中每个元素的值 .val( function ) ，一个用来返回设置值的函数 注意事项： 通过.val()处理select元素， 当没有选择项被选中，它返回null .val()方法多用来设置表单的字段的值 如果select元素有multiple（多选）属性，并且至少一个选择项被选中， .val()方法返回一个数组，这个数组包含每个选中选择项的值 .html(),.text()和.val()的差异总结： .html(),.text(),.val()三种方法都是用来读取选定元素的内容； 只不过.html()是用来读取元素的html内容（包括html标签）， .text()用来读取元素的纯文本内容，包括其后代元素， .val()是用来读取表单元素的”value”值。 其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上； 另外.html()方法使用在多个元素上时，只读取第一个元素； .val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的”value”值， 但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。 .html(htmlString),.text(textString)和.val(value)三种方法都是用来替换选中元素的内容，如果三个方法同时运用在多个元素上时，那么将会替换所有选中元素的内容。 .html(),.text(),.val()都可以使用回调函数的返回值来动态的改变多个元素的内容。 123456789101112131415161718192021222324252627&lt;select id="single"&gt; &lt;option&gt;慕课网&lt;/option&gt; &lt;option&gt;博客园&lt;/option&gt; &lt;/select&gt; &lt;select id="multiple" multiple="multiple"&gt; &lt;option selected="selected"&gt;imocc&lt;/option&gt; &lt;option&gt;慕课网&lt;/option&gt; &lt;option selected="selected"&gt;博客园&lt;/option&gt; &lt;/select&gt; &lt;input type="text" value="click a button" /&gt; &lt;p&gt;&lt;/p&gt; &lt;script type="text/javascript"&gt; //单个select，返回第一个 $("p").text( $("#single").val() ) &lt;/script&gt; &lt;script type="text/javascript"&gt; //多个select被选择，返回["imocc", "博客园"] $("p").text( $("#multiple").val() ) &lt;/script&gt; &lt;script type="text/javascript"&gt; //选择一个表单，修改value的值 $("input[type='text']").val('修改表单的字段') &lt;/script&gt; #jQuery的属性与样式之增加样式.addClass() jQuery的属性与样式之删除样式.removeClass()jQuery的属性与样式之切换样式.toggleClass()#jQuery的属性与样式之样式操作.css() jQuery的属性与样式之.css()与.addClass()设置样式的区别jQuery的属性与样式之元素的数据存储]]></content>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery2]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%89%8D%E7%AB%AF%2FJquery%E5%AD%A6%E4%B9%A03%E6%9D%8E%E6%B1%9F%E5%8D%97%2F</url>
    <content type="text"><![CDATA[01-初识jQuer1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; window.onload = function (ev) &#123; // 1.利用原生的JS查找DOM元素 var div1 = document.getElementsByTagName("div")[0]; var div2 = document.getElementsByClassName("box1")[0]; var div3 = document.getElementById("box2"); // console.log(div1); // console.log(div2); // console.log(div3); // 2.利用原生的JS修改背景颜色 // div1.style.backgroundColor = "red"; // div2.style.backgroundColor = "blue"; // div3.style.backgroundColor = "yellow"; &#125; $(function () &#123; var $div1 = $("div"); var $div2 = $(".box1"); var $div3 = $("#box2"); // console.log($div1); // console.log($div2); // console.log($div3); $div1.css(&#123; background: "red", width: "200px", height: "200px" &#125;); $div2.css(&#123; background: "blue" &#125;); $div3.css(&#123; background: "yellow" &#125;); &#125;); &lt;/script&gt; 02-jQuery-HelloWorld123456789&lt;script&gt; // 1.原生JS的固定写法 window.onload = function (ev) &#123; &#125; // 2.jQuery的固定写法 $(document).ready(function () &#123; alert("hello lnj"); &#125;); &lt;/script&gt; 03-jQuery和JS入口函数的区别12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;script&gt; /* window.onload = function (ev) &#123; // 1.通过原生的JS入口函数可以拿到DOM元素 var images = document.getElementsByTagName("images")[0]; console.log(images); // 2.通过原生的JS入口函数可以拿到DOM元素的宽高 var width = window.getComputedStyle(images).width; console.log("onload", width); &#125; */ /* * 1.原生JS和jQuery入口函数的加载模式不同 * 原生JS会等到DOM元素加载完毕,并且图片也加载完毕才会执行 * jQuery会等到DOM元素加载完毕,但不会等到图片也加载完毕就会执行 * */ /* $(document).ready(function () &#123; // 1.通过jQuery入口函数可以拿到DOM元素 var $images = $("images"); console.log($images); // 2.通过jQuery入口函数不可以拿到DOM元素的宽高 var $width = $images.width(); console.log("ready", $width); &#125;); */ /* 1.原生的JS如果编写了多个入口函数,后面编写的会覆盖前面编写的 2.jQuery中编写多个入口函数,后面的不会覆盖前面的 */ // window.onload = function (ev) &#123; // alert("hello lnj1"); // &#125; // window.onload = function (ev) &#123; // alert("hello lnj2"); // &#125; $(document).ready(function () &#123; alert("hello lnj1"); &#125;); $(document).ready(function () &#123; alert("hello lnj2"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="https://img.alicdn.com/tfs/TB1P_MofwmTBuNjy1XbXXaMrVXa-190-140.gif" alt=""&gt; 04-jQuery入口函数的其它写法123456789101112131415161718192021&lt;script&gt; // 1.第一种写法 $(document).ready(function () &#123; // alert("hello lnj"); &#125;); // 2.第二种写法 jQuery(document).ready(function () &#123; // alert("hello lnj"); &#125;); // 3.第三种写法(推荐) $(function () &#123; // alert("hello lnj"); &#125;); // 4.第四种写法 jQuery(function () &#123; alert("hello lnj"); &#125;); &lt;/script&gt; 05-jQuery冲突问题1234567891011&lt;script&gt; // 1.释放$的使用权 // 注意点: 释放操作必须在编写其它jQuery代码之前编写 // 释放之后就不能再使用$,改为使用jQuery // jQuery原理.noConflict(); // 2.自定义一个访问符号 var nj = jQuery.noConflict(); nj(function () &#123; alert("hello lnj"); &#125;); &lt;/script&gt; 06-jQuery核心函数1234567891011121314151617181920212223242526&lt;script&gt; // $();/jQuery原理();就代表调用jQuery的核心函数 // 1.接收一个函数 $(function () &#123; alert("hello lnj"); // 2.接收一个字符串 // 2.1接收一个字符串选择器 // 返回一个jQuery对象, 对象中保存了找到的DOM元素 var $box1 = $(".box1"); var $box2 = $("#box2"); console.log($box1); console.log($box2); // 2.2接收一个字符串代码片段 // 返回一个jQuery对象, 对象中保存了创建的DOM元素 var $p = $("&lt;p&gt;我是段落&lt;/p&gt;"); console.log($p); $box1.append($p); // 3.接收一个DOM元素 // 会被包装成一个jQuery对象返回给我们 var span = document.getElementsByTagName("span")[0]; console.log(span); var $span = $(span); console.log($span); &#125;); &lt;/script&gt; 07-jQuery对象12345678910111213141516&lt;script&gt; $(function () &#123; /* * 1.什么是jQuery对象 * jQuery对象是一个伪数组 * * 2.什么是伪数组? * 有0到length-1的属性, 并且有length属性 */ var $div = $("div"); console.log($div); var arr = [1, 3, 5]; console.log(arr); &#125;); &lt;/script&gt; 08-静态方法和实例方法12345678910111213141516171819202122&lt;script&gt; // 1.定义一个类 function AClass() &#123; &#125; // 2.给这个类添加一个静态方法 // 直接添加给类的就是静态方法 AClass.staticMethod = function () &#123; alert("staticMethod"); &#125; // 静态方法通过类名调用 AClass.staticMethod(); // 3.给这个类添加一个实例方法 AClass.prototype.instanceMethod = function () &#123; alert("instanceMethod"); &#125; // 实例方法通过类的实例调用 // 创建一个实例(创建一个对象) var a = new AClass(); // 通过实例调用实例方法 a.instanceMethod(); &lt;/script&gt; 09-静态方法each方法123456789101112131415161718192021222324252627282930&lt;script&gt; var arr = [1, 3, 5, 7, 9]; var obj = &#123;0:1, 1:3, 2:5, 3:7, 4:9, length:5&#125;; /* 第一个参数: 遍历到的元素 第二个参数: 当前遍历到的索引 注意点: 原生的forEach方法只能遍历数组, 不能遍历伪数组 */ // arr.forEach(function (value, index) &#123; // console.log(index, value); // &#125;); // obj.forEach(function (value, index) &#123; // console.log(index, value); // &#125;); // 1.利用jQuery的each静态方法遍历数组 /* 第一个参数: 当前遍历到的索引 第二个参数: 遍历到的元素 注意点: jQuery的each方法是可以遍历伪数组的 */ // $.each(arr, function (index, value) &#123; // console.log(index, value); // &#125;); $.each(obj, function (index, value) &#123; console.log(index, value); &#125;); &lt;/script&gt; 10-静态方法map方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script&gt; var arr = [1, 3, 5, 7, 9]; var obj = &#123;0:1, 1:3, 2:5, 3:7, 4:9, length:5&#125;; // 1.利用原生JS的map方法遍历 /* 第一个参数: 当前遍历到的元素 第二个参数: 当前遍历到的索引 第三个参数: 当前被遍历的数组 注意点: 和原生的forEach一样,不能遍历的伪数组 */ // arr.map(function (value, index, array) &#123; // console.log(index, value, array); // &#125;); // obj.map(function (value, index, array) &#123; // console.log(index, value, array); // &#125;); /* 第一个参数: 要遍历的数组 第二个参数: 每遍历一个元素之后执行的回调函数 回调函数的参数: 第一个参数: 遍历到的元素 第二个参数: 遍历到的索引 注意点: 和jQuery中的each静态方法一样, map静态方法也可以遍历伪数组 */ // $.map(arr, function (value, index) &#123; // console.log(index, value); // &#125;); var res = $.map(obj, function (value, index) &#123; console.log(index, value); return value + index; &#125;); var res2 = $.each(obj, function (index, value) &#123; console.log(index, value); return value + index; &#125;); /* jQuery中的each静态方法和map静态方法的区别: each静态方法默认的返回值就是, 遍历谁就返回谁 map静态方法默认的返回值是一个空数组 each静态方法不支持在回调函数中对遍历的数组进行处理 map静态方法可以在回调函数中通过return对遍历的数组进行处理, 然后生成一个新的数组返回 */ console.log(res); console.log(res2); &lt;/script&gt; 11-jQuery中的其它静态方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script&gt; /* $.trim(); 作用: 去除字符串两端的空格 参数: 需要去除空格的字符串 返回值: 去除空格之后的字符串 */ /* var str = " lnj "; var res = $.trim(str); console.log("---"+str+"---"); console.log("---"+res+"---"); */ // 真数组 var arr = [1, 3, 5, 7, 9]; // 伪数组 var arrlike = &#123;0:1, 1:3, 2:5, 3:7, 4:9, length:5&#125;; // 对象 var obj = &#123;"name":"lnj", age:"33"&#125;; // 函数 var fn = function()&#123;&#125;; // window对象 var w = window; /* $.isWindow(); 作用: 判断传入的对象是否是window对象 返回值: true/false */ /* var res = $.isWindow(w); console.log(res); */ /* $.isArray(); 作用: 判断传入的对象是否是真数组 返回值: true/false */ /* var res = $.isArray(w); console.log(res); */ /* $.isArray(); 作用: 判断传入的对象是否是一个函数 返回值: true/false 注意点: jQuery框架本质上是一个函数 (function( window, undefined ) &#123; &#125;)( window ); */ var res = $.isFunction(jQuery); console.log(res); &lt;/script&gt; 12-静态方法holdReady方法12345678910111213141516 &lt;script&gt; // $.holdReady(true); 作用: 暂停ready执行 $.holdReady(true); $(document).ready(function () &#123; alert("ready"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;回复ready事件&lt;/button&gt;&lt;script&gt; var btn = document.getElementsByTagName("button")[0]; btn.onclick = function () &#123; $.holdReady(false); &#125;&lt;/script&gt; 13-通过webstorm简化操作1234567891011&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;13-通过webstorm简化操作&lt;/title&gt; &lt;script src="js/jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 编写jQuery相关代码 alert("hello lnj"); &#125;); &lt;/script&gt;&lt;/head&gt; 14-jQuery内容选择器1234567891011121314151617181920212223242526272829 &lt;script src="js/jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 编写jQuery相关代码 // :empty 作用:找到既没有文本内容也没有子元素的指定元素 var $div = $("div:empty"); console.log($div); // :parent 作用: 找到有文本内容或有子元素的指定元素 var $div = $("div:parent"); console.log($div); // :contains(text) 作用: 找到包含指定文本内容的指定元素 var $div = $("div:contains('我是div')"); console.log($div); // :has(selector) 作用: 找到包含指定子元素的指定元素 var $div = $("div:has('span')"); console.log($div); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;div&gt;他们我是div123&lt;/div&gt;&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; 15-属性和属性节点123456789101112131415161718192021222324252627282930313233343536373839404142434445 &lt;script&gt; $(function () &#123; /* 1.什么是属性? 对象身上保存的变量就是属性 2.如何操作属性? 对象.属性名称 = 值; 对象.属性名称; 对象["属性名称"] = 值; 对象["属性名称"]; 3.什么是属性节点? &lt;span name = "it666"&gt;&lt;/span&gt; 在编写HTML代码时,在HTML标签中添加的属性就是属性节点 在浏览器中找到span这个DOM元素之后, 展开看到的都是属性 在attributes属性中保存的所有内容都是属性节点 4.如何操作属性节点? DOM元素.setAttribute("属性名称", "值"); DOM元素.getAttribute("属性名称"); 5.属性和属性节点有什么区别? 任何对象都有属性, 但是只有DOM对象才有属性节点 */ function Person() &#123; &#125; var p = new Person(); // p.name = "lnj"; p["name"] = "zs"; // console.log(p.name); console.log(p["name"]); var span = document.getElementsByTagName("span")[0]; span.setAttribute("name", "lnj"); console.log(span.getAttribute("name")); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;span name = "it666"&gt;&lt;/span&gt; 16-jQuery的attr方法1234567891011121314151617181920212223242526272829303132 &lt;script&gt; $(function () &#123; /* 1.attr(name|pro|key,val|fn) 作用: 获取或者设置属性节点的值 可以传递一个参数, 也可以传递两个参数 如果传递一个参数, 代表获取属性节点的值 如果传递两个参数, 代表设置属性节点的值 注意点: 如果是获取:无论找到多少个元素, 都只会返回第一个元素指定的属性节点的值 如果是设置:找到多少个元素就会设置多少个元素 如果是设置: 如果设置的属性节点不存在, 那么系统会自动新增 2.removeAttr(name) 删除属性节点 注意点: 会删除所有找到元素指定的属性节点 */ // console.log($("span").attr("class")); $("span").attr("class", "box"); // $("span").attr("abc", "123"); // $("span").removeAttr("class name"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;span class="span1" name="it666"&gt;&lt;/span&gt;&lt;span class="span2" name="lnj"&gt;&lt;/span&gt; 17-jQuery的prop方法1234567891011121314151617181920212223242526272829303132333435 &lt;script&gt; $(function () &#123; /* 1.prop方法 特点和attr方法一致 2.removeProp方法 特点和removeAttr方法一致 */ /* $("span").eq(0).prop("demo", "it666"); $("span").eq(1).prop("demo", "lnj"); console.log($("span").prop("demo")); $("span").removeProp("demo"); */ /* 注意点: prop方法不仅能够操作属性, 他还能操作属性节点 官方推荐在操作属性节点时,具有 true 和 false 两个属性的属性节点，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr() */ // console.log($("span").prop("class")); // $("span").prop("class", "box"); console.log($("input").prop("checked")); // true / false console.log($("input").attr("checked")); // checked / undefined &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;span class="span1" name="it666"&gt;&lt;/span&gt;&lt;span class="span2" name="lnj"&gt;&lt;/span&gt;&lt;input type="checkbox"&gt; 18-attr和prop方法练习1234567891011121314151617181920script&gt; $(function () &#123; // 编写jQuery相关代码 // 1.给按钮添加点击事件 var btn = document.getElementsByTagName("button")[0]; btn.onclick = function () &#123; // 2.获取输入框输入的内容 var input = document.getElementsByTagName("input")[0]; var text = input.value; // 3.修改img的src属性节点的值 $("img").attr("src", text); // $("images").prop("src", text); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text"&gt;&lt;button&gt;切换图片&lt;/button&gt;&lt;br&gt;&lt;img src="https://www.baidu.com/img/bd_logo1.png?where=super" alt=""&gt; 19-jQuery操作类相关的方法1234567891011121314151617181920212223242526272829303132333435 &lt;script&gt; $(function () &#123; /* 1.addClass(class|fn) 作用: 添加一个类 如果要添加多个, 多个类名之间用空格隔开即可 2.removeClass([class|fn]) 作用: 删除一个类 如果想删除多个, 多个类名之间用空格隔开即可 3.toggleClass(class|fn[,sw]) 作用: 切换类 有就删除, 没有就添加 */ var btns = document.getElementsByTagName("button"); btns[0].onclick = function () &#123; // $("div").addClass("class1"); $("div").addClass("class1 class2"); &#125; btns[1].onclick = function () &#123; // $("div").removeClass("class2"); $("div").removeClass("class2 class1"); &#125; btns[2].onclick = function () &#123; $("div").toggleClass("class2 class1"); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加类&lt;/button&gt;&lt;button&gt;删除类&lt;/button&gt;&lt;button&gt;切换类&lt;/button&gt;&lt;div&gt;&lt;/div&gt; 20-jQuery文本值相关的方法12345678910111213141516171819202122232425262728293031323334353637383940 &lt;script&gt; $(function () &#123; /* 1.html([val|fn]) 和原生JS中的innerHTML一模一样 2.text([val|fn]) 和原生JS中的innerText一模一样 3.val([val|fn|arr]) */ var btns = document.getElementsByTagName("button"); btns[0].onclick = function () &#123; $("div").html("&lt;p&gt;我是段落&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;"); &#125; btns[1].onclick = function () &#123; console.log($("div").html()); &#125; btns[2].onclick = function () &#123; $("div").text("&lt;p&gt;我是段落&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;"); &#125; btns[3].onclick = function () &#123; console.log($("div").text()); &#125; btns[4].onclick = function () &#123; $("input").val("请输入内容"); &#125; btns[5].onclick = function () &#123; console.log($("input").val());; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;设置html&lt;/button&gt;&lt;button&gt;获取html&lt;/button&gt;&lt;button&gt;设置text&lt;/button&gt;&lt;button&gt;获取text&lt;/button&gt;&lt;button&gt;设置value&lt;/button&gt;&lt;button&gt;获取value&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;input type="text"&gt; 21-jQuery操作CSS样式的方法1234567891011121314151617181920212223&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 // 1.逐个设置 $("div").css("width", "100px"); $("div").css("height", "100px"); $("div").css("background", "red"); // 2.链式设置 // 注意点: 链式操作如果大于3步, 建议分开 $("div").css("width", "100px").css("height", "100px").css("background", "blue"); // 3.批量设置 $("div").css(&#123; width: "100px", height: "100px", background: "red" &#125;); // 4.获取CSS样式值 console.log($("div").css("background"));; &#125;); &lt;/script&gt; 22-jQuery位置和尺寸操作的方法123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 var btns = document.getElementsByTagName("button"); // 监听获取 btns[0].onclick = function () &#123; // 获取元素的宽度 // console.log($(".father").width()); // offset([coordinates]) // 作用: 获取元素距离窗口的偏移位 // console.log($(".son").offset().left); // position() // 作用: 获取元素距离定位元素的偏移位 console.log($(".son").position().left); &#125; // 监听设置 btns[1].onclick = function () &#123; // 设置元素的宽度 // $(".father").width("500px") // $(".son").offset(&#123; // left: 10 // &#125;); // 注意点: position方法只能获取不能设置 // $(".son").position(&#123; // left: 10 // &#125;); $(".son").css(&#123; left: "10px" &#125;); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt;&lt;button&gt;获取&lt;/button&gt;&lt;button&gt;设置&lt;/button&gt; 23-jQuery的scrollTop方法123456789101112131415161718192021&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 var btns = document.getElementsByTagName("button"); // 监听获取 btns[0].onclick = function () &#123; // 获取滚动的偏移位 // console.log($(".scroll").scrollTop()); // 获取网页滚动的偏移位 // 注意点: 为了保证浏览器的兼容, 获取网页滚动的偏移位需要按照如下写法 console.log($("body").scrollTop()+$("html").scrollTop()); &#125; btns[1].onclick = function () &#123; // 设置滚动的偏移位 $(".scroll").scrollTop(300); // 设置网页滚动偏移位 // 注意点: 为了保证浏览器的兼容, 设置网页滚动偏移位的时候必须按照如下写法 $("html,body").scrollTop(300); &#125; &#125;); &lt;/script&gt; 24-jQuery事件绑定123456789101112131415161718192021222324252627282930313233343536373839&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 /* jQuery中有两种绑定事件方式 1.eventName(fn); 编码效率略高/ 部分事件jQuery没有实现,所以不能添加 2.on(eventName, fn); 编码效率略低/ 所有js事件都可以添加 注意点: 可以添加多个相同或者不同类型的事件,不会覆盖 */ // $("button").click(function () &#123; // alert("hello lnj"); // &#125;); // $("button").click(function () &#123; // alert("hello 123"); // &#125;); // $("button").mouseleave(function () &#123; // alert("hello mouseleave"); // &#125;); // $("button").mouseenter(function () &#123; // alert("hello mouseenter"); // &#125;); $("button").on("click", function () &#123; alert("hello click1"); &#125;); $("button").on("click", function () &#123; alert("hello click2"); &#125;); $("button").on("mouseleave", function () &#123; alert("hello mouseleave"); &#125;); $("button").on("mouseenter", function () &#123; alert("hello mouseenter"); &#125;); &#125;); &lt;/script&gt; 25-jQuery事件移除1234567891011121314151617181920212223242526&lt;script&gt; $(function () &#123; function test1() &#123; alert("hello lnj"); &#125; function test2() &#123; alert("hello 123"); &#125; // 编写jQuery相关代码 $("button").click(test1); $("button").click(test2); $("button").mouseleave(function () &#123; alert("hello mouseleave"); &#125;); $("button").mouseenter(function () &#123; alert("hello mouseenter"); &#125;); // off方法如果不传递参数, 会移除所有的事件 // $("button").off(); // off方法如果传递一个参数, 会移除所有指定类型的事件 // $("button").off("click"); // off方法如果传递两个参数, 会移除所有指定类型的指定事件 $("button").off("click", test1); &#125;); &lt;/script&gt; 26-jQuery事件冒泡和默行为123456789101112131415161718192021222324252627282930313233343536 &lt;script&gt; $(function () &#123; // 编写jQuery相关代码 /* 1.什么是事件冒泡? 2.如何阻止事件冒泡 3.什么是默认行为? 4.如何阻止默认行为 */ /* $(".son").click(function (event) &#123; alert("son"); // return false; event.stopPropagation(); &#125;); $(".father").click(function () &#123; alert("father"); &#125;); */ $("a").click(function (event) &#123; alert("弹出注册框"); // return false; event.preventDefault(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt;&lt;a href="http://www.baidu.com"&gt;注册&lt;/a&gt;&lt;form action="http://www.taobao.com"&gt; &lt;input type="text"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 26-jQuery事件冒泡和默行为12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 $(".son").click(function (event) &#123; alert("son"); &#125;); $(".father").click(function () &#123; alert("father"); &#125;); // $(".father").trigger("click"); // $(".father").triggerHandler("click"); /* trigger: 如果利用trigger自动触发事件,会触发事件冒泡 triggerHandler: 如果利用triggerHandler自动触发事件, 不会触发事件冒泡 */ // $(".son").trigger("click"); // $(".son").triggerHandler("click"); $("input[type='submit']").click(function () &#123; alert("submit"); &#125;); /* trigger: 如果利用trigger自动触发事件,会触发默认行为 triggerHandler: 如果利用triggerHandler自动触发事件, 不会触发默认行为 */ // $("input[type='submit']").trigger("click"); // $("input[type='submit']").triggerHandler("click"); $("span").click(function () &#123; alert("a"); &#125;); // $("a").triggerHandler("click"); $("span").trigger("click"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt;&lt;a href="http://www.baidu.com"&gt;&lt;span&gt;注册&lt;/span&gt;&lt;/a&gt;&lt;form action="http://www.taobao.com"&gt; &lt;input type="text"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 26-jQuery事件冒泡和默行为1234567891011121314151617&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 // $(".son").myClick(function (event) &#123; // alert("son"); // &#125;); /* 想要自定义事件, 必须满足两个条件 1.事件必须是通过on绑定的 2.事件必须通过trigger来触发 */ $(".son").on("myClick", function () &#123; alert("son"); &#125;); $(".son").triggerHandler("myClick"); &#125;); &lt;/script&gt; 26-jQuery事件自动触发123456789101112131415161718192021222324252627282930313233343536373839&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 $(".son").click(function (event) &#123; alert("son"); &#125;); $(".father").click(function () &#123; alert("father"); &#125;); // $(".father").trigger("click"); // $(".father").triggerHandler("click"); /* trigger: 如果利用trigger自动触发事件,会触发事件冒泡 triggerHandler: 如果利用triggerHandler自动触发事件, 不会触发事件冒泡 */ // $(".son").trigger("click"); // $(".son").triggerHandler("click"); $("input[type='submit']").click(function () &#123; alert("submit"); &#125;); /* trigger: 如果利用trigger自动触发事件,会触发默认行为 triggerHandler: 如果利用triggerHandler自动触发事件, 不会触发默认行为 */ // $("input[type='submit']").trigger("click"); // $("input[type='submit']").triggerHandler("click"); $("span").click(function () &#123; alert("a"); &#125;); // $("a").triggerHandler("click"); $("span").trigger("click"); &#125;); &lt;/script&gt; 28 Jquery自定义事件12345678910111213141516171819202122232425262728 &lt;script src="js/jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 编写jQuery相关代码 // $(".son").myClick(function (event) &#123; // alert("son"); // &#125;); /* 想要自定义事件, 必须满足两个条件 1.事件必须是通过on绑定的 2.事件必须通过trigger来触发 */ $(".son").on("myClick", function () &#123; alert("son"); &#125;); $(".son").triggerHandler("myClick"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt;&lt;a href="http://www.baidu.com"&gt;&lt;span&gt;注册&lt;/span&gt;&lt;/a&gt;&lt;form action="http://www.taobao.com"&gt; &lt;input type="text"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 29Jquery事件命名空间123456789101112131415161718&lt;script&gt; $(function () &#123; /* 想要事件的命名空间有效,必须满足两个条件 1.事件是通过on来绑定的 2.通过trigger触发事件 */ $(".son").on("click.zs", function () &#123; alert("click1"); &#125;); $(".son").on("click.ls", function () &#123; alert("click2"); &#125;); // $(".son").trigger("click.zs"); $(".son").trigger("click.ls"); &#125;); &lt;/script&gt; 30Jquery命名空间面试题1234567891011121314151617181920&lt;script&gt; $(function () &#123; $(".father").on("click.ls", function () &#123; alert("father click1"); &#125;); $(".father").on("click", function () &#123; alert("father click2"); &#125;); $(".son").on("click.ls", function () &#123; alert("son click1"); &#125;); /* 利用trigger触发子元素带命名空间的事件, 那么父元素带相同命名空间的事件也会被触发. 而父元素没有命名空间的事件不会被触发 利用trigger触发子元素不带命名空间的事件,那么子元素所有相同类型的事件和父元素所有相同类型的事件都会被触发 */ // $(".son").trigger("click.ls"); $(".son").trigger("click"); &#125;); &lt;/script&gt; 31-jQuery事件委托1234567891011121314151617181920212223242526&lt;script&gt; $(function () &#123; /* 1.什么是事件委托? 请别人帮忙做事情, 然后将做完的结果反馈给我们 */ $("button").click(function () &#123; $("ul").append("&lt;li&gt;我是新增的li&lt;/li&gt;"); &#125;) /* 在jQuery中,如果通过核心函数找到的元素不止一个, 那么在添加事件的时候,jQuery会遍历所有找到的元素,给所有找到的元素添加事件 */ // $("ul&gt;li").click(function () &#123; // console.log($(this).html()); // &#125;); /* 以下代码的含义, 让ul帮li监听click事件 之所以能够监听, 是因为入口函数执行的时候ul就已经存在了, 所以能够添加事件 之所以this是li,是因为我们点击的是li, 而li没有click事件, 所以事件冒泡传递给了ul,ul响应了事件, 既然事件是从li传递过来的,所以ul必然指定this是谁 */ $("ul").delegate("li", "click", function () &#123; console.log($(this).html()); &#125;); &#125;); &lt;/script&gt; 32-jQuery事件委托练习1234567891011121314151617181920&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 $("a").click(function () &#123; var $mask = $("&lt;div class=\"mask\"&gt;\n" + " &lt;div class=\"login\"&gt;\n" + " &lt;img src=\"images/login.png\" alt=\"\"&gt;\n" + " &lt;span&gt;&lt;/span&gt;\n" + " &lt;/div&gt;\n" + "&lt;/div&gt;"); // 添加蒙版 $("body").append($mask); $("body").delegate(".login&gt;span", "click", function () &#123; // 移除蒙版 $mask.remove(); &#125;); return false; &#125;); &#125;); &lt;/script&gt; 33-jQuery移入移出事件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 /* mouseover/mouseout事件, 子元素被移入移出也会触发父元素的事件 */ /* $(".father").mouseover(function () &#123; console.log("father被移入了"); &#125;); $(".father").mouseout(function () &#123; console.log("father被移出了"); &#125;); */ /* mouseenter/mouseleave事件, 子元素被移入移出不会触发父元素的事件 推荐大家使用 */ /* $(".father").mouseenter(function () &#123; console.log("father被移入了"); &#125;); $(".father").mouseleave(function () &#123; console.log("father被移出了"); &#125;); */ /* $(".father").hover(function () &#123; console.log("father被移入了"); &#125;,function () &#123; console.log("father被移出了"); &#125;); */ $(".father").hover(function () &#123; console.log("father被移入移出了"); &#125;); &#125;); &lt;/script&gt; 34-电影排行榜上1234567891011121314151617181920&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 /* // 1.监听li的移入事件 $(&quot;li&quot;).mouseenter(function () &#123; $(this).addClass(&quot;current&quot;); &#125;); // 2.监听li的移出事件 $(&quot;li&quot;).mouseleave(function () &#123; $(this).removeClass(&quot;current&quot;); &#125;); */ $(&quot;li&quot;).hover(function () &#123; $(this).addClass(&quot;current&quot;); &#125;, function () &#123; $(this).removeClass(&quot;current&quot;); &#125;); &#125;); &lt;/script&gt; 36-TAB选项卡上1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;script&gt; $(function () &#123; // 1.监听选项卡的移入事件 $(&quot;.nav&gt;li&quot;).mouseenter(function () &#123; // 1.1修改被移入选项卡的背景颜色 $(this).addClass(&quot;current&quot;); // 1.2获取当前移入选项卡的索引 var index = $(this).index(); // 1.3根据索引找到对应的图片 var $li = $(&quot;.content&gt;li&quot;).eq(index); // 1.4显示找到的图片 $li.addClass(&quot;show&quot;); &#125;); // 1.监听选项卡的移出事件 $(&quot;.nav&gt;li&quot;).mouseleave(function () &#123; // 1.1还原选项卡的背景颜色 $(this).removeClass(&quot;current&quot;); // 1.2获取当前移出选项卡的索引 var index = $(this).index(); // 1.3根据索引找到对应的图片 var $li = $(&quot;.content&gt;li&quot;).eq(index); // 1.4隐藏对应的图片 $li.removeClass(&quot;show&quot;); &#125;); &#125;); &lt;/script&gt; &lt;script&gt; $(function () &#123; /* // 1.监听选项卡的移入事件 $(&quot;.nav&gt;li&quot;).mouseenter(function () &#123; // 1.1修改被移入选项卡的背景颜色 $(this).addClass(&quot;current&quot;); // 1.2获取当前移入选项卡的索引 var index = $(this).index(); // 1.3根据索引找到对应的图片 var $li = $(&quot;.content&gt;li&quot;).eq(index); // 1.4显示找到的图片 $li.addClass(&quot;show&quot;); &#125;); // 1.监听选项卡的移出事件 $(&quot;.nav&gt;li&quot;).mouseleave(function () &#123; // 1.1还原选项卡的背景颜色 $(this).removeClass(&quot;current&quot;); // 1.2获取当前移出选项卡的索引 var index = $(this).index(); // 1.3根据索引找到对应的图片 var $li = $(&quot;.content&gt;li&quot;).eq(index); // 1.4隐藏对应的图片 $li.removeClass(&quot;show&quot;); &#125;); */ // 1.监听选项卡的移入事件 $(&quot;.nav&gt;li&quot;).mouseenter(function () &#123; // 1.1修改被移入选项卡的背景颜色 $(this).addClass(&quot;current&quot;); // 1.2还原其它兄弟选项卡的背景颜色 $(this).siblings().removeClass(&quot;current&quot;); // 1.3获取当前移出选项卡的索引 var index = $(this).index(); // 1.4根据索引找到对应的图片 var $li = $(&quot;.content&gt;li&quot;).eq(index); // 1.5隐藏非当前的其它图片 $li.siblings().removeClass(&quot;show&quot;); // 1.6显示对应的图片 $li.addClass(&quot;show&quot;); &#125;); &#125;); &lt;/script&gt; 39-jQuery显示和隐藏动画123456789101112131415161718192021222324&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 $("button").eq(0).click(function () &#123; // $("div").css("display", "block"); // 注意: 这里的时间是毫秒 $("div").show(1000, function () &#123; // 作用: 动画执行完毕之后调用 alert("显示动画执行完毕"); &#125;); &#125;); $("button").eq(1).click(function () &#123; // $("div").css("display", "none"); $("div").hide(1000, function () &#123; alert("隐藏动画执行完毕"); &#125;); &#125;); $("button").eq(2).click(function () &#123; $("div").toggle(1000, function () &#123; alert("切换动画执行完毕"); &#125;); &#125;); &#125;); &lt;/script&gt; 40-对联广告123456789101112131415161718&lt;script&gt; $(function () &#123; // 1.监听网页的滚动 $(window).scroll(function () &#123; // 1.1获取网页滚动的偏移位 var offset = $("html,body").scrollTop(); // 1.2判断网页是否滚动到了指定的位置 if(offset &gt;= 500)&#123; // 1.3显示广告 $("img").show(1000); &#125;else&#123; // 1.4隐藏广告 $("img").hide(1000); &#125; &#125;); &#125;); &lt;/script&gt; 41-jQuery展开和收起动画1234567891011121314151617181920&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 $("button").eq(0).click(function () &#123; $("div").slideDown(1000, function () &#123; alert("展开完毕"); &#125;); &#125;); $("button").eq(1).click(function () &#123; $("div").slideUp(1000, function () &#123; alert("收起完毕"); &#125;); &#125;); $("button").eq(2).click(function () &#123; $("div").slideToggle(1000, function () &#123; alert("收起完毕"); &#125;); &#125;); &#125;); &lt;/script&gt; 43-折叠菜单下12345678910111213141516171819&lt;script&gt; $(function () &#123; // 1.监听一级菜单的点击事件 $(&quot;.nav&gt;li&quot;).click(function () &#123; // 1.1拿到二级菜单 var $sub = $(this).children(&quot;.sub&quot;); // 1.2让二级菜单展开 $sub.slideDown(1000); // 1.3拿到所有非当前的二级菜单 var otherSub = $(this).siblings().children(&quot;.sub&quot;); // 1.4让所有非当前的二级菜单收起 otherSub.slideUp(1000); // 1.5让被点击的一级菜单箭头旋转 $(this).addClass(&quot;current&quot;); // 1.6让所有非被点击的一级菜单箭头还原 $(this).siblings().removeClass(&quot;current&quot;); &#125;); &#125;); &lt;/script&gt; 44-下拉菜单1234567891011121314151617181920212223242526&lt;script&gt; $(function () &#123; /* 在jQuery中如果需要执行动画, 建议在执行动画之前先调用stop方法,然后再执行动画 */ // 1.监听一级菜单的移入事件 $(&quot;.nav&gt;li&quot;).mouseenter(function () &#123; // 1.1拿到二级菜单 var $sub = $(this).children(&quot;.sub&quot;); // 停止当前正在运行的动画： $sub.stop(); // 1.2让二级菜单展开 $sub.slideDown(1000); &#125;); // 2.监听一级菜单的移出事件 $(&quot;.nav&gt;li&quot;).mouseleave(function () &#123; // 1.1拿到二级菜单 var $sub = $(this).children(&quot;.sub&quot;); // 停止当前正在运行的动画： $sub.stop(); // 1.2让二级菜单收起 $sub.slideUp(1000); &#125;); &#125;); &lt;/script&gt; 45-jQuery淡入淡出动画12345678910111213141516171819202122232425&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 $(&quot;button&quot;).eq(0).click(function () &#123; $(&quot;div&quot;).fadeIn(1000, function () &#123; alert(&quot;淡入完毕&quot;); &#125;); &#125;); $(&quot;button&quot;).eq(1).click(function () &#123; $(&quot;div&quot;).fadeOut(1000, function () &#123; alert(&quot;淡出完毕&quot;); &#125;); &#125;); $(&quot;button&quot;).eq(2).click(function () &#123; $(&quot;div&quot;).fadeToggle(1000, function () &#123; alert(&quot;切换完毕&quot;); &#125;); &#125;); $(&quot;button&quot;).eq(3).click(function () &#123; $(&quot;div&quot;).fadeTo(1000, 0.2, function () &#123; alert(&quot;淡入完毕&quot;); &#125;) &#125;); &#125;); &lt;/script&gt; 46-弹窗广告12345678910111213141516171819&lt;script&gt; $(function () &#123; // 1.监听span的点击事件 $(&quot;span&quot;).click(function () &#123; $(&quot;.ad&quot;).remove(); &#125;); // 2.执行广告动画 /* $(&quot;.ad&quot;).slideDown(1000, function () &#123; $(&quot;.ad&quot;).fadeOut(1000, function () &#123; $(&quot;.ad&quot;).fadeIn(1000); &#125;); &#125;); */ $(&quot;.ad&quot;).stop().slideDown(1000).fadeOut(1000).fadeIn(1000); &#125;); &lt;/script&gt; 47-jQuery自定义动画123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 $(&quot;button&quot;).eq(0).click(function () &#123; /* $(&quot;.one&quot;).animate(&#123; width: 500 &#125;, 1000, function () &#123; alert(&quot;自定义动画执行完毕&quot;); &#125;); */ $(&quot;.one&quot;).animate(&#123; marginLeft: 500 &#125;, 5000, function () &#123; // alert(&quot;自定义动画执行完毕&quot;); &#125;); /* 第一个参数: 接收一个对象, 可以在对象中修改属性 第二个参数: 指定动画时长 第三个参数: 指定动画节奏, 默认就是swing 第四个参数: 动画执行完毕之后的回调函数 */ $(&quot;.two&quot;).animate(&#123; marginLeft: 500 &#125;, 5000, &quot;linear&quot;, function () &#123; // alert(&quot;自定义动画执行完毕&quot;); &#125;); &#125;) $(&quot;button&quot;).eq(1).click(function () &#123; $(&quot;.one&quot;).animate(&#123; width: &quot;+=100&quot; &#125;, 1000, function () &#123; alert(&quot;自定义动画执行完毕&quot;); &#125;); &#125;); $(&quot;button&quot;).eq(2).click(function () &#123; $(&quot;.one&quot;).animate(&#123; // width: &quot;hide&quot; width: &quot;toggle&quot; &#125;, 1000, function () &#123; alert(&quot;自定义动画执行完毕&quot;); &#125;); &#125;) &#125;); &lt;/script&gt; 48-jQuery的stop和delay方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;script&gt; $(function () &#123; // 编写jQuery相关代码 $(&quot;button&quot;).eq(0).click(function () &#123; /* 在jQuery的&#123;&#125;中可以同时修改多个属性, 多个属性的动画也会同时执行 */ /* $(&quot;.one&quot;).animate(&#123; width: 500 // height: 500 &#125;, 1000); $(&quot;.one&quot;).animate(&#123; height: 500 &#125;, 1000); */ /* delay方法的作用就是用于告诉系统延迟时长 */ /* $(&quot;.one&quot;).animate(&#123; width: 500 // height: 500 &#125;, 1000).delay(2000).animate(&#123; height: 500 &#125;, 1000); */ $(&quot;.one&quot;).animate(&#123; width: 500 &#125;, 1000); $(&quot;.one&quot;).animate(&#123; height: 500 &#125;, 1000); $(&quot;.one&quot;).animate(&#123; width: 100 &#125;, 1000); $(&quot;.one&quot;).animate(&#123; height: 100 &#125;, 1000); &#125;); $(&quot;button&quot;).eq(1).click(function () &#123; // 立即停止当前动画, 继续执行后续的动画 // $(&quot;div&quot;).stop(); // $(&quot;div&quot;).stop(false); // $(&quot;div&quot;).stop(false, false); // 立即停止当前和后续所有的动画 // $(&quot;div&quot;).stop(true); // $(&quot;div&quot;).stop(true, false); // 立即完成当前的, 继续执行后续动画 // $(&quot;div&quot;).stop(false, true); // 立即完成当前的, 并且停止后续所有的 $(&quot;div&quot;).stop(true, true); &#125;); &#125;); &lt;/script&gt; 49-图标特效1234567891011121314151617181920212223242526&lt;script&gt; $(function () &#123; // 1.遍历所有的li $(&quot;li&quot;).each(function (index, ele) &#123; // 1.1生成新的图片位置 var $url = &quot;url(\&quot;images/bg.png\&quot;) no-repeat 0 &quot;+(index * -24)+&quot;px&quot; // 1.2设置新的图片位置 $(this).children(&quot;span&quot;).css(&quot;background&quot;, $url); &#125;); // 2.监听li移入事件 $(&quot;li&quot;).mouseenter(function () &#123; // 2.1将图标往上移动 $(this).children(&quot;span&quot;).animate(&#123; top: -50 &#125;, 1000, function () &#123; // 2.2将图片往下移动 $(this).css(&quot;top&quot;, &quot;50px&quot;); // 2.3将图片复位 $(this).animate(&#123; top: 0 &#125;, 1000); &#125;); &#125;); &#125;); &lt;/script&gt; 50-无限循环滚动123456789101112131415161718192021222324252627282930313233&lt;script&gt; $(function () &#123; // 0.定义变量保存偏移位 var offset = 0; // 1.让图片滚动起来 var timer; function autoPlay()&#123; timer = setInterval(function () &#123; offset += -10; if(offset &lt;= -1200)&#123; offset = 0; &#125; $(&quot;ul&quot;).css(&quot;marginLeft&quot;, offset); &#125;, 50); &#125; autoPlay(); // 2.监听li的移入和移出事件 $(&quot;li&quot;).hover(function () &#123; // 停止滚动 clearInterval(timer); // 给非当前选中添加蒙版 $(this).siblings().fadeTo(100, 0.5); // 去除当前选中的蒙版 $(this).fadeTo(100, 1); &#125;, function () &#123; // 继续滚动 autoPlay(); // 去除所有的蒙版 $(&quot;li&quot;).fadeTo(100, 1); &#125;); &#125;); &lt;/script&gt; 51-jQuery添加节点相关方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;script&gt; $(function () &#123; /* 内部插入 append(content|fn) appendTo(content) 会将元素添加到指定元素内部的最后 prepend(content|fn) prependTo(content) 会将元素添加到指定元素内部的最前面 外部插入 after(content|fn) 会将元素添加到指定元素外部的后面 before(content|fn) 会将元素添加到指定元素外部的前面 insertAfter(content) insertBefore(content) */ $("button").click(function () &#123; // 1.创建一个节点 var $li = $("&lt;li&gt;新增的li&lt;/li&gt;"); // 2.添加节点 $("ul").append($li); $("ul").prepend($li); // $li.appendTo("ul"); // $li.prependTo("ul"); // $("ul").after($li); // $("ul").before($li); // $li.insertAfter("ul"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加节点&lt;/button&gt;&lt;ul&gt; &lt;li&gt;我是第1个li&lt;/li&gt; &lt;li&gt;我是第2个li&lt;/li&gt; &lt;li&gt;我是第3个li&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;我是div&lt;/div&gt; 52-jQuery删除节点相关方法12345678910111213141516171819202122232425262728293031323334353637 &lt;script&gt; $(function () &#123; /* 删除 remove([expr]) 删除指定元素 empty() 删除指定元素的内容和子元素, 指定元素自身不会被删除 detach([expr]) */ $("button").click(function () &#123; // $("div").remove(); // $("div").empty(); // $("li").remove(".item"); // 利用remove删除之后再重新添加,原有的事件无法响应 // var $div = $("div").remove(); // 利用detach删除之后再重新添加,原有事件可以响应 var $div = $("div").detach(); // console.log($div); $("body").append($div); &#125;); $("div").click(function () &#123; alert("div被点击了"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;删除节点&lt;/button&gt;&lt;ul&gt; &lt;li class="item"&gt;我是第1个li&lt;/li&gt; &lt;li&gt;我是第2个li&lt;/li&gt; &lt;li class="item"&gt;我是第3个li&lt;/li&gt; &lt;li&gt;我是第4个li&lt;/li&gt; &lt;li class="item"&gt;我是第5个li&lt;/li&gt;&lt;/ul&gt; 53-jQuery替换节点相关方法1234567891011121314151617181920212223 &lt;script&gt; $(function () &#123; /* 替换 replaceWith(content|fn) replaceAll(selector) 替换所有匹配的元素为指定的元素 */ $("button").click(function () &#123; // 1.新建一个元素 var $h6 = $("&lt;h6&gt;我是标题6&lt;/h6&gt;"); // 2.替换元素 // $("h1").replaceWith($h6); $h6.replaceAll("h1"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;替换节点&lt;/button&gt;&lt;h1&gt;我是标题1&lt;/h1&gt;&lt;h1&gt;我是标题1&lt;/h1&gt;&lt;p&gt;我是段落&lt;/p&gt; 54-jQuery复制节点相关方法12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; $(function () &#123; // clone([Even[,deepEven]]) /* 如果传入false就是浅复制, 如果传入true就是深复制 浅复制只会复制元素, 不会复制元素的事件 深复制会复制元素, 而且还会复制元素的事件 */ $("button").eq(0).click(function () &#123; // 1.浅复制一个元素 var $li = $("li:first").clone(false); // 2.将复制的元素添加到ul中 $("ul").append($li); &#125;); $("button").eq(1).click(function () &#123; // 1.深复制一个元素 var $li = $("li:first").clone(true); // 2.将复制的元素添加到ul中 $("ul").append($li); &#125;); $("li").click(function () &#123; alert($(this).html()); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;浅复制节点&lt;/button&gt;&lt;button&gt;深复制节点&lt;/button&gt;&lt;ul&gt; &lt;li&gt;我是第1个li&lt;/li&gt; &lt;li&gt;我是第2个li&lt;/li&gt; &lt;li&gt;我是第3个li&lt;/li&gt; &lt;li&gt;我是第4个li&lt;/li&gt; &lt;li&gt;我是第5个li&lt;/li&gt;&lt;/ul&gt; Ajax12345678910111213141516171819202122232425262728293031323334353637383940&lt;!--1.可以通过form标签的method属性指定发送请求的类型2.如果是get请求会将提交的数据拼接到URL后面?userName=lnj&amp;userPwd=1234563.如果是post请求会将提交的数据放到请求头中4.GET请求和POST请求的异同4.1相同点:都是将数据提交到远程服务器4.2不同点:4.2.1提交数据存储的位置不同GET请求会将数据放到URL后面POST请求会将数据放到请求头中4.2.2提交数据大小限制不同GET请求对数据有大小限制POST请求对数据没有大小限制5.GET/POST请求应用场景GET请求用于提交非敏感数据和小数据POST请求用于提交敏感数据和大数据&lt;--注意:1.上传文件一般使用POST提交2.上传文件必须设置enctype=&quot;multipart/form-data&quot;3.上传的文件在PHP中可以通过$_FILES获取4.PHP中文件默认会上传到一个临时目录, 接收完毕之后会自动删除--&gt;&lt;!--默认情况下服务器对上传文件的大小是有限制的, 如果想修改上传文件的限制可以修改php.ini文件file_uploads = On ; 是否允许上传文件 On/Off 默认是Onupload_max_filesize = 2048M ; 上传文件的最大限制post_max_size = 2048M ; 通过Post提交的最多数据max_execution_time = 30000 ; 脚本最长的执行时间 单位为秒max_input_time = 30000 ; 接收提交的数据的时间限制 单位为秒memory_limit = 2048M ; 最大的内存消耗--&gt; 04-ajax-get12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 1.什么是Ajax? AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 --&gt; &lt;script&gt; window.onload = function (ev) &#123; var oBtn = document.querySelector(&quot;button&quot;); oBtn.onclick = function (ev1) &#123; // 1.创建一个异步对象 var xmlhttp=new XMLHttpRequest(); // 2.设置请求方式和请求地址 /* method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） */ xmlhttp.open(&quot;GET&quot;, &quot;04-ajax-get.php&quot;, true); // 3.发送请求 xmlhttp.send(); // 4.监听状态的变化 xmlhttp.onreadystatechange = function (ev2) &#123; /* 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 */ if(xmlhttp.readyState === 4)&#123; // 判断是否请求成功 if(xmlhttp.status &gt;= 200 &amp;&amp; xmlhttp.status &lt; 300 || xmlhttp.status === 304)&#123; // 5.处理返回的结果 console.log(&quot;接收到服务器返回的数据&quot;); &#125;else&#123; console.log(&quot;没有接收到服务器返回的数据&quot;); &#125; &#125; &#125; &#125; &#125; &lt;/script&gt; 05-ajax-get123456789101112131415161718192021222324252627282930313233343536373839&lt;script&gt; window.onload = function (ev) &#123; var oBtn = document.querySelector(&quot;button&quot;); oBtn.onclick = function (ev1) &#123; var xhr; if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xhr=new XMLHttpRequest(); &#125; else &#123;// code for IE6, IE5 xhr=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; // var xhr = new XMLHttpRequest(); /* 在IE浏览器中, 如果通过Ajax发送GET请求, 那么IE浏览器认为 同一个URL只有一个结果 05-ajax-get.txt === abc console.log(Math.random()); console.log(new Date().getTime()); */ xhr.open(&quot;GET&quot;,&quot;05-ajax-get.txt?t=&quot;+(new Date().getTime()),true); xhr.send(); xhr.onreadystatechange = function (ev2) &#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123; // alert(&quot;请求成功&quot;); alert(xhr.responseText); &#125;else&#123; alert(&quot;请求失败&quot;); &#125; &#125; &#125; &#125; &#125;&lt;/script&gt; 10-ajax-test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 &lt;script src=&quot;myAjax2.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = function (ev) &#123; // 1.获取需要设置的元素 var oTitle = document.querySelector(&quot;#title&quot;); var oDes = document.querySelector(&quot;#des&quot;); var oImg = document.querySelector(&quot;img&quot;); // 2.获取所有按钮 var oBtns = document.querySelectorAll(&quot;button&quot;); // 3.给按钮添加点击事件 oBtns[0].onclick = function () &#123; var self = this; // 4.发送Aajx请求到服务器 ajax(&#123; type:&quot;get&quot;, url:&quot;10-ajax-test.php&quot;, data:&#123;&quot;name&quot;:this.getAttribute(&quot;name&quot;)&#125;, timeout: 3000, success: function (xhr) &#123; /* // alert(xhr.responseText); var res = xhr.responseText.split(&quot;|&quot;); // console.log(res); oTitle.innerHTML = res[0]; oDes.innerHTML = res[1]; oImg.setAttribute(&quot;src&quot;, res[2]); */ /* var name = self.getAttribute(&quot;name&quot;); var res = xhr.responseXML; var title = res.querySelector(name+&quot;&gt;title&quot;).innerHTML; var des = res.querySelector(name+&quot;&gt;des&quot;).innerHTML; var image = res.querySelector(name+&quot;&gt;image&quot;).innerHTML; oTitle.innerHTML = title; oDes.innerHTML = des; oImg.setAttribute(&quot;src&quot;, image); */ var name = self.getAttribute(&quot;name&quot;); var str = xhr.responseText; var obj = JSON.parse(str); // console.log(obj); var subObj = obj[name]; // console.log(subObj); oTitle.innerHTML = subObj.title; oDes.innerHTML = subObj.des; oImg.setAttribute(&quot;src&quot;, subObj.image); &#125;, error: function (xhr) &#123; alert(xhr.status); &#125; &#125;); &#125; oBtns[1].onclick = function () &#123; &#125; oBtns[2].onclick = function () &#123; &#125; &#125; &lt;/script&gt; -------- &lt;script&gt; window.onload = function (ev) &#123; var oBtn = document.querySelector(&quot;button&quot;); oBtn.onclick = function (ev1) &#123; ajax(&#123; type:&quot;get&quot;, url:&quot;11-ajax-xml.php&quot;, success: function (xhr) &#123; // console.log(xhr.responseXML); // console.log(document); var res = xhr.responseXML; console.log(res.querySelector(&quot;name&quot;).innerHTML); console.log(res.querySelector(&quot;age&quot;).innerHTML); &#125;, error: function (xhr) &#123; console.log(xhr.status); &#125; &#125;) &#125; &#125; &lt;/script&gt;&lt;/head&gt;]]></content>
      <tags>
        <tag>Jquery李江南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql主层复制]]></title>
    <url>%2F2019%2F03%2F08%2FMysql%2FMysql%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis]]></title>
    <url>%2F2019%2F03%2F08%2FMybatis%2FresultType%20resultMap%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F07%2F%E9%9D%A2%E8%AF%95%2FUntitled%201%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Jquery2]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%89%8D%E7%AB%AF%2FJquery%E5%AD%A6%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[1 $.getJson()jQuery中的$.getJSON( )方法函数主要用来从服务器加载json编码的数据，它使用的是GET HTTP请求。使用方法如下： 1$.getJSON( url [, data ] [, success(data, textStatus, jqXHR) ] ) url是必选参数，表示json数据的地址；data是可选参数，用于请求数据时发送数据参数；success是可参数，这是一个回调函数，用于处理请求到的数据。 获取json数据举例 12345$.getJson('test.json',function(data)&#123; for(var i=0;i&lt;data.rows.length;i++)&#123; $('#test').append('&lt;p&gt;'+data.rows[i].realName+'&lt;/p&gt;') &#125;&#125;); 在WEB开发中异步请求方式普遍使用，ajax技术减少程序员的工作量，也提升用户交互体验。AJAX的四种异步请求方式都能实现基本需求，闲话不多说，直接切入正题。 .$.getJSON $.getJSON()是专门为ajax获取json数据而设置的，并且支持跨域调用，其语法的格式为： 123451 $.getJSON(2 url, //请求URL3 [data], //传参，可选参数4 [callback] //回调函数，可选参数5 ); 123url：string类型， 发送请求地址 data ：可选参数， 待发送 Key/value 参数 ，同get，post类型的data callback ：可选参数，载入成功时回调函数，同get，post类型的callback 4.$.ajax $.ajax是一种常用的普通封装异步方式。 11 $.ajax(options)； options是一个object类型，它指明了本次ajax调用的具体参数。呈上代码： 123456789101112131415//示例.ajax( url: "/legalconsult/layer/update-info", datatype:"json", type:'post', beforeSend:function()&#123; //函数体，数据发送前执行。 &#125; success：function()&#123; //函数体，数据发送成功回调 &#125; error: function()&#123; //函数体，数据发送错误时执行 &#125; ); https://www.cnblogs.com/dongsh/p/3235487.html 1.服务器返回的Json数据必须严格符合JSIN语法，例如：所有属性名称必须加双引号，所有字符串值必须加双引号（不可以是单引号） 123456789语法： Jquery.getJSON( url [,data][,success]) url: String类型 指定请求的目标URL data:可选 发送请求传递的数据 success: 请求成功时执行的回调函数。 函数有三个参数：一 是请求返回的数据 二 请求状态文本（例如"success","notmodified"）,三 当前jqXHR对象 2 JQuery.getJSON(url,data,success); //等价于 12345678910111213$.ajax(&#123; url:url, type:"GET", data:data, success:success, datatype:"json"&#125;);]]></content>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpServletRequest介绍]]></title>
    <url>%2F2019%2F03%2F03%2FjavaWeb%2FHttpServletRequest%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/xdp-gacl/p/3798347.html javaweb学习总结(十)——HttpServletRequest对象(一)一、HttpServletRequest介绍 HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。 所有信息。 二、Request常用方法2.1、获得客户机信息 getRequestURL方法返回客户端发出请求时的完整URL。 getRequestURI方法返回请求行中的资源名部分。 getQueryString 方法返回请求行中的参数部分。 getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。 getRemoteAddr方法返回发出请求的客户机的IP地址。 范例：通过request对象获取客户端请求信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package gacl.request.study;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 通过request对象获取客户端请求信息 */public class RequestDemo01 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 1.获得客户机信息 */ String requestUrl = request.getRequestURL().toString();//得到请求的URL地址 String requestUri = request.getRequestURI();//得到请求的资源 String queryString = request.getQueryString();//得到请求的URL地址中附带的参数 String remoteAddr = request.getRemoteAddr();//得到来访者的IP地址 String remoteHost = request.getRemoteHost(); int remotePort = request.getRemotePort(); String remoteUser = request.getRemoteUser(); String method = request.getMethod();//得到请求URL地址时使用的方法 String pathInfo = request.getPathInfo(); String localAddr = request.getLocalAddr();//获取WEB服务器的IP地址 String localName = request.getLocalName();//获取WEB服务器的主机名 response.setCharacterEncoding("UTF-8");//设置将字符以"UTF-8"编码输出到客户端浏览器 //通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码 response.setHeader("content-type", "text/html;charset=UTF-8"); PrintWriter out = response.getWriter(); out.write("获取到的客户机信息如下："); out.write("&lt;hr/&gt;"); out.write("请求的URL地址："+requestUrl); out.write("&lt;br/&gt;"); out.write("请求的资源："+requestUri); out.write("&lt;br/&gt;"); out.write("请求的URL地址中附带的参数："+queryString); out.write("&lt;br/&gt;"); out.write("来访者的IP地址："+remoteAddr); out.write("&lt;br/&gt;"); out.write("来访者的主机名："+remoteHost); out.write("&lt;br/&gt;"); out.write("使用的端口号："+remotePort); out.write("&lt;br/&gt;"); out.write("remoteUser："+remoteUser); out.write("&lt;br/&gt;"); out.write("请求使用的方法："+method); out.write("&lt;br/&gt;"); out.write("pathInfo："+pathInfo); out.write("&lt;br/&gt;"); out.write("localAddr："+localAddr); out.write("&lt;br/&gt;"); out.write("localName："+localName); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 2.2、获得客户机请求头 getHeader(string name)方法:String getHeaders(String name)方法:Enumeration getHeaderNames()方法 范例：通过request对象获取客户端请求头信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package gacl.request.study;import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 获取客户端请求头信息 * 客户端请求头： * */public class RequestDemo02 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setCharacterEncoding("UTF-8");//设置将字符以"UTF-8"编码输出到客户端浏览器 //通过设置响应头控制浏览器以UTF-8的编码显示数据 response.setHeader("content-type", "text/html;charset=UTF-8"); PrintWriter out = response.getWriter(); Enumeration&lt;String&gt; reqHeadInfos = request.getHeaderNames();//获取所有的请求头 out.write("获取到的客户端所有的请求头信息如下："); out.write("&lt;hr/&gt;"); while (reqHeadInfos.hasMoreElements()) &#123; String headName = (String) reqHeadInfos.nextElement(); String headValue = request.getHeader(headName);//根据请求头的名字获取对应的请求头的值 out.write(headName+":"+headValue); out.write("&lt;br/&gt;"); &#125; out.write("&lt;br/&gt;"); out.write("获取到的客户端Accept-Encoding请求头的值："); out.write("&lt;hr/&gt;"); String value = request.getHeader("Accept-Encoding");//获取Accept-Encoding请求头对应的值 out.write(value); Enumeration&lt;String&gt; e = request.getHeaders("Accept-Encoding"); while (e.hasMoreElements()) &#123; String string = (String) e.nextElement(); System.out.println(string); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 2.3、获得客户机请求参数(客户端提交的数据) getParameter(String)方法(常用) getParameterValues(String name)方法(常用) getParameterNames()方法(不常用) getParameterMap()方法(编写框架时常用) 比如现在有如下的form表单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Html的Form表单元素&lt;/title&gt;&lt;/head&gt;&lt;fieldset style=&quot;width:500px;&quot;&gt; &lt;legend&gt;Html的Form表单元素&lt;/legend&gt; &lt;!--form表单的action属性规定当提交表单时，向何处发送表单数据，method属性指明表单的提交方式，分为get和post，默认为get--&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/RequestDemo03&quot; method=&quot;post&quot;&gt; &lt;!--输入文本框，SIZE表示显示长度，maxlength表示最多输入长度--&gt; 编&amp;nbsp;&amp;nbsp;号(文本框)： &lt;input type=&quot;text&quot; name=&quot;userid&quot; value=&quot;NO.&quot; size=&quot;2&quot; maxlength=&quot;2&quot;&gt;&lt;br&gt; &lt;!--输入文本框，通过value指定其显示的默认值--&gt; 用户名(文本框)：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot;&gt;&lt;br&gt; &lt;!--密码框，其中所有输入的内容都以密文的形式显示--&gt; 密&amp;nbsp;&amp;nbsp;码(密码框)： &lt;!--&amp;nbsp;表示的是一个空格--&gt; &lt;input type=&quot;password&quot; name=&quot;userpass&quot; value=&quot;请输入密码&quot;&gt;&lt;br&gt; &lt;!--单选按钮，通过checked指定默认选中，名称必须一样，其中value为真正需要的内容--&gt; 性&amp;nbsp;&amp;nbsp;别(单选框)： &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; &lt;!--下拉列表框，通过&lt;option&gt;元素指定下拉的选项--&gt; 部&amp;nbsp;&amp;nbsp;门(下拉框)： &lt;select name=&quot;dept&quot;&gt; &lt;option value=&quot;技术部&quot;&gt;技术部&lt;/option&gt; &lt;option value=&quot;销售部&quot; SELECTED&gt;销售部&lt;/option&gt; &lt;option value=&quot;财务部&quot;&gt;财务部&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;!--复选框，可以同时选择多个选项，名称必须一样，其中value为真正需要的内容--&gt; 兴&amp;nbsp;&amp;nbsp;趣(复选框)： &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;唱歌&quot;&gt;唱歌 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;游泳&quot;&gt;游泳 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;跳舞&quot;&gt;跳舞 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;编程&quot; checked&gt;编程 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;上网&quot;&gt;上网 &lt;br&gt; &lt;!--大文本输入框，宽度为34列，高度为5行--&gt; 说&amp;nbsp;&amp;nbsp;明(文本域)： &lt;textarea name=&quot;note&quot; cols=&quot;34&quot; rows=&quot;5&quot;&gt; &lt;/textarea&gt; &lt;br&gt; &lt;!--隐藏域，在页面上无法看到，专门用来传递参数或者保存参数--&gt; &lt;input type=&quot;hidden&quot; name=&quot;hiddenField&quot; value=&quot;hiddenvalue&quot;/&gt; &lt;!--提交表单按钮，当点击提交后，所有填写的表单内容都会被传输到服务器端--&gt; &lt;input type=&quot;submit&quot; value=&quot;提交(提交按钮)&quot;&gt; &lt;!--重置表单按钮，当点击重置后，所有表单恢复原始显示内容--&gt; &lt;input type=&quot;reset&quot; value=&quot;重置(重置按钮)&quot;&gt;&lt;/form&gt;&lt;!--表单结束--&gt;&lt;/fieldset&gt;&lt;/body&gt;&lt;!--完结标记--&gt;&lt;/html&gt;&lt;!--完结标记--&gt; 在服务器端使用getParameter方法和getParameterValues方法接收表单参数，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package gacl.request.study;import java.io.IOException;import java.text.MessageFormat;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 获取客户端通过Form表单提交上来的参数 */public class RequestDemo03 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //客户端是以UTF-8编码提交表单数据的，所以需要设置服务器端以UTF-8的编码进行接收，否则对于中文数据就会产生乱码 request.setCharacterEncoding("UTF-8"); /** * 编&amp;nbsp;&amp;nbsp;号(文本框)： &lt;input type="text" name="userid" value="NO." size="2" maxlength="2"&gt; */ String userid = request.getParameter("userid");//获取填写的编号，userid是文本框的名字，&lt;input type="text" name="userid"&gt; /** * 用户名(文本框)：&lt;input type="text" name="username" value="请输入用户名"&gt; */ String username = request.getParameter("username");//获取填写的用户名 /** * 密&amp;nbsp;&amp;nbsp;码(密码框)：&lt;input type="password" name="userpass" value="请输入密码"&gt; */ String userpass = request.getParameter("userpass");//获取填写的密码 String sex = request.getParameter("sex");//获取选中的性别 String dept = request.getParameter("dept");//获取选中的部门 //获取选中的兴趣，因为可以选中多个值，所以获取到的值是一个字符串数组，因此需要使用getParameterValues方法来获取 String[] insts = request.getParameterValues("inst"); String note = request.getParameter("note");//获取填写的说明信息 String hiddenField = request.getParameter("hiddenField");//获取隐藏域的内容 String instStr=""; /** * 获取数组数据的技巧，可以避免insts数组为null时引发的空指针异常错误！ */ for (int i = 0; insts!=null &amp;&amp; i &lt; insts.length; i++) &#123; if (i == insts.length-1) &#123; instStr+=insts[i]; &#125;else &#123; instStr+=insts[i]+","; &#125; &#125; String htmlStr = "&lt;table&gt;" + "&lt;tr&gt;&lt;td&gt;填写的编号：&lt;/td&gt;&lt;td&gt;&#123;0&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的用户名：&lt;/td&gt;&lt;td&gt;&#123;1&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的密码：&lt;/td&gt;&lt;td&gt;&#123;2&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的性别：&lt;/td&gt;&lt;td&gt;&#123;3&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的部门：&lt;/td&gt;&lt;td&gt;&#123;4&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的兴趣：&lt;/td&gt;&lt;td&gt;&#123;5&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的说明：&lt;/td&gt;&lt;td&gt;&#123;6&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;隐藏域的内容：&lt;/td&gt;&lt;td&gt;&#123;7&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;/table&gt;"; htmlStr = MessageFormat.format(htmlStr, userid,username,userpass,sex,dept,instStr,note,hiddenField); response.setCharacterEncoding("UTF-8");//设置服务器端以UTF-8编码输出数据到客户端 response.setContentType("text/html;charset=UTF-8");//设置客户端浏览器以UTF-8编码解析数据 response.getWriter().write(htmlStr);//输出htmlStr里面的内容到客户端浏览器显示 &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 12345&lt;form action="login"&gt;账号:&lt;input type="text" name="username"/&gt;&lt;br&gt;账号:&lt;input type="text" name="password"/&gt;&lt;br&gt;&lt;input type="submit" name="登陆"/&gt;&lt;br&gt;&lt;/form&gt; String username = request.getParameter(“username”); String password= request.getParameter(“password”); 使用getParameter方法取出username]]></content>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F02%2F%E9%9D%A2%E8%AF%95%2F%E4%B8%AD%E5%8D%8E%E7%9F%B3%E6%9D%89%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[慕课网SpringBoot+Dubbo打造访猫眼项目]]></title>
    <url>%2F2019%2F03%2F01%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2FDubbo%E6%89%93%E9%80%A0%E7%8C%AB%E7%9C%BC%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1 微服务]]></content>
      <tags>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F28%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2Fjava%E4%BB%BF%E6%85%95%E8%AF%BE%E7%BD%91%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[zookeeper的使用]]></title>
    <url>%2F2019%2F02%2F23%2FDubbo%2FZookeeper%2F</url>
    <content type="text"><![CDATA[Zookeeper的使用 1 安装JDK https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html scp /Users/apple/Downloads/jdk-8u201-linux-x64.tar.gz root@94.191.24.33:vim /etc/profile1234567export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL``export ZOOKEEPER_HOME=/root/zookeeper-3.4.10``export JAVA_HOME=/root/jdk1.8.0_201``export CLASSPATH=.:%JAVA_HOME%/lib/dt.jar:%JAVA_HOME%/lib/tools.jar``export PATH=$PATH:$JAVA_HOME/bin` source /etc/profile java环境配置 1234export JAVA_HOME=/root/jdk1.8.0_201export CLASSPATH=.:%JAVA_HOME%/lib/dt.jar:%JAVA_HOME%/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 2 安装zookeeper12345678910111213# export ZOOKEEPER_HOME=/root/zookeeper-3.4.10` `export CLASSPATH=.:%JAVA_HOME%/lib/dt.jar:%JAVA_HOME%/lib/tools.jar``export JAVA_HOME=/root/jdk1.8.0_201``export ZOOKEEPER_HOME=/root/zookeeper-3.4.10` # `export PATH=$PATH:$JAVA_HOME/bin``export PATH=$PATH:$ZOOKEEPER_HOME/bin:$JAVA_HOME/bin` Bug 12345671. uname -a 上图中i686表明系统安装的是32位的，但是这个结果并不明显，对linux系统不熟的是无法分辨出是32位还是64位的。2. getconf LONG_BIT（推荐使用） 32 bit结果非常直观明显。]]></content>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F22%2FSpring%20Boot%2FSpringBoot%E9%9B%B7%E4%B8%B0%E9%98%B3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Spring注解]]></title>
    <url>%2F2019%2F02%2F19%2FSpring%2F%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[@Component1、@controller 控制器（注入服务） 用于标注控制层，相当于struts中的action层2、@service 服务（注入dao） 用于标注服务层，主要用来进行业务的逻辑处理3、@repository（实现dao访问） 用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件.4、@component （把普通pojo实例化到spring容器中，相当于配置文件中的 ） 泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。案例：&lt;context:component-scan base-package=”com.*”&gt;上面的这个例子是引入Component组件的例子，其中base-package表示为需要扫描的所有子包。 共同点：被@controller 、@service、@repository 、@component 注解的类，都会把这些类纳入进spring容器中进行管理 @RequestParamGET和POST请求传的参数会自动转换赋值到@RequestParam 所注解的变量上\1. @RequestParam（org.springframework.web.bind.annotation.RequestParam）用于将指定的请求参数赋值给方法中的形参。例：(1) get请求： url请求：http://localhost:8080/WxProgram/findAllBookByTag?tagId=1&amp;pageIndex=3 userTest.jsp 123456&lt;form action=&quot;/WxProgram/json/requestParamTest&quot; method=&quot;get&quot;&gt; requestParam Test&lt;br&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 用户昵称：&lt;input type=&quot;text&quot; name=&quot;usernick&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; UserController.java ;) 1234567@RequestMapping(value=&quot;/requestParamTest&quot;, method = RequestMethod.GET)public String requestParamTest(@RequestParam(value=&quot;username&quot;) String userName, @RequestParam(value=&quot;usernick&quot;) String userNick)&#123; System.out.println(&quot;requestParam Test&quot;); System.out.println(&quot;username: &quot; + userName); System.out.println(&quot;usernick: &quot; + userNick); return &quot;hello&quot;;&#125; ;) 上述代码会将请求中的username参数的值赋给username变量。 等价于： ;) 12345678@RequestMapping(value=&quot;/requestParamTest&quot;, method = RequestMethod.GET)public String requestParamTest(String username, HttpServletRequest request)&#123; System.out.println(&quot;requestParam Test&quot;); System.out.println(&quot;username: &quot; + username); String usernick = request.getParameter(&quot;usernick&quot;); System.out.println(&quot;usernick: &quot; + usernick); return &quot;hello&quot;;&#125; ;) 也可以不使用@RequestParam，直接接收，此时要求controller方法中的参数名称要跟form中name名称一致 ;) 1234567@RequestMapping(value=&quot;/requestParamTest&quot;, method = RequestMethod.GET)public String requestParamTest(String username, String usernick)&#123; System.out.println(&quot;requestParam Test&quot;); System.out.println(&quot;username: &quot; + username); System.out.println(&quot;usernick: &quot; + usernick); return &quot;hello&quot;;&#125; ;) 总结： 接收请求参数的方式： 123@RequestParam(value=&quot;username&quot;) String userName, @RequestParam(value=&quot;usernick&quot;) String userNick //value中的参数名称要跟name中参数名称一致String username, String usernick// 此时要参数名称一致HttpServletRequest request //request.getParameter(&quot;usernick&quot;) @ResponseBody呢？ @ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。 举个例子： 前台异步请求： ;) 1234567891011121314151617181920212223242526272829303132333435&gt; function loginAction() &#123;&gt; &gt; // 获取用户输入的账号和密码&gt; var name = $(&apos;#count&apos;).val();&gt; var password = $(&apos;#password&apos;).val();&gt; &gt; $.ajax(&#123;&gt; url : &apos;account/login.do&apos;,&gt; type : &apos;post&apos;,&gt; // data对象中的属性名要和服务端控制器的参数名一致 login(name, password)&gt; data : &#123;&gt; &apos;name&apos; : name,&gt; &apos;password&apos; : password&gt; &#125;,&gt; dataType : &apos;json&apos;,&gt; success : function(result) &#123;&gt; if (result.state == 0) &#123;&gt; // 登录成功，设置cookie并跳转edit.html&gt; addCookie(&apos;userId&apos;, result.data.id);&gt; addCookie(&apos;nick&apos;, result.data.nick);&gt; location.href = &apos;edit.html&apos;;&gt; &#125; else &#123;&gt; // 登录失败&gt; var msg = result.message;&gt; $(&apos;#sig_in&apos;).next().html(msg);&gt; $(&apos;#sig_in&apos;).next().css(&quot;color&quot;, &quot;red&quot;);&gt; &#125;&gt; &#125;,&gt; error : function(e) &#123;&gt; alert(&quot;系统异常&quot;);&gt; &#125;&gt; &#125;);&gt; $(&apos;#password&apos;).val(&quot;&quot;);&gt; &#125;&gt; ;) 后台 Controller类中对应的方法： ;) 12345678&gt; @RequestMapping(&quot;/login.do&quot;)&gt; @ResponseBody&gt; public Object login(String name, String password, HttpSession session) &#123;&gt; user = userService.checkLogin(name, password);&gt; session.setAttribute(&quot;user&quot;, user);&gt; return new JsonResult(user);&gt; &#125;&gt; ;) @RequestBody呢 ​ @RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。 比如上面的登录后台代码可以改为： ;) 12345678&gt; @RequestMapping(&quot;/login.do&quot;)&gt; @ResponseBody&gt; public Object login(@RequestBody User loginUuser, HttpSession session) &#123;&gt; user = userService.checkLogin(loginUser);&gt; session.setAttribute(&quot;user&quot;, user);&gt; return new JsonResult(user);&gt; &#125;&gt;]]></content>
      <tags>
        <tag>SpringBoot注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PathVariabl和@RequestParam用法与区别]]></title>
    <url>%2F2019%2F02%2F13%2FSpring%20MVC%2F%E6%B3%A8%E8%A7%A3%40PathParam%2F</url>
    <content type="text"><![CDATA[【1】paramsparams： 指定request中必须包含某些参数值是，才让该方法处理。 @RequestMapping(value = &quot;testParamsAndHeaders&quot;, params = { &quot;username&quot;,&quot;age!=10&quot; }) public String testParamsAndHeaders() { System.out.println(&quot;testParamsAndHeaders&quot;); return SUCCESS; } params 只是判断url 或者 form data 中的参数是否复合params的定义，并不会直接绑定数据到方法的参数中！2 @PathVariabl绑定路径中的占位符参数到方法参数变量中；只能绑定路径中的占位符参数，且路径中必须有参数。无论是 GET 或者POST 只要 URL中有参数即可！实例如下：GETRequest URL:http://localhost:8080/SpringMVC-1/springmvc/testPathVariable/1 123456&lt;form action=&quot;springmvc/testPathVariable/1&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot;/&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;&quot;/&gt; &lt;input type=&quot;text&quot; name=&quot;sex&quot; value=&quot;&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;/&gt;&lt;/form&gt; 【注意】如果URL中无参数，将会出错；如果URL有参数，但是没有使用@PathVariabl该注解，那么URL的参数不会默认与方法参数绑定！方法里的参数会默认绑定表单里面对应的参数！ 后台code 如果参数名与占位符一致，则可直接使用@PathVariable；如果不一致，则在@PathVariable( )括号内绑定占位符。@RequestMapping(&quot;/testPathVariable/{id}&quot;) public String testPathVariable(@PathVariable(&quot;id&quot;) Integer id2) { System.out.println(&quot;testPathVariable: &quot; + id2); return SUCCESS; } 【3】@RequestParam该注解相关属性如下： value：参数key，可以不写，默认为””； name：和value作用一样； required：默认值为true，可以不写； 获取URL或者 form data 中的参数 前台请求实例如下： GET 1POST &lt;form action=&quot;springmvc/testRequestParam&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userName&quot; value=&quot;&quot;/&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;&quot;/&gt; &lt;input type=&quot;text&quot; name=&quot;sex&quot; value=&quot;&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;/&gt; &lt;/form&gt; 注意 ： GET中的参数形式为：username=tom&amp;age=11&amp;sex=boy POST中的参数形式为：以键值对形式保存在form data 后台代码示例： @RequestMapping(value=&quot;/regist&quot;,produces=&quot;application/json;charset=utf-8&quot;) @ResponseBody public String regist(SysUser sysUser , @RequestParam(required=true,name=&quot;sex&quot;) String sex){ String userName = sysUser.getUserName(); String age = sysUser.getAge(); //... return &quot;regist success&quot;; } 总得来说，均是键值对形式，与@PathVariabl中的占位符形式不同！！！ #@RequestParam注解 @RequestParam注解比较简单，它用于将请求参数区数据映射到功能处理方法的参数上，自SpringMVC4.2之后，@RequestParam注解内部有4个参数： String name String value boolean required String defaultValue 1.name与value属性，其中name和value分别是URL参数的名称，即二者没区别，我个人比较喜欢用name，因为在HTML的表单中我们都是用name属性来设置URL参数名称的，所以在注解上也使用name这个属性的话，会更直观一些。示例： 1234567891011121314151617181920212223package org.zero01.test;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controller@RequestMapping("/test")public class Test &#123; @RequestMapping("test.do") // 指定将username参数的值传递到该方法的name参数上 public void test(@RequestParam(name = "username") String name) &#123; System.out.println(name); &#125; @RequestMapping("user.do") // 指定将username参数的值传递到该方法的user参数上，alias参数的值则传递到该方法的a参数上 public void userAndAlias(@RequestParam(name = "username")String user, @RequestParam(name = "alias")String a) &#123; System.out.println(user); System.out.println(a); &#125;&#125; 2.required属性，该属性用于指定某个参数是否是必须的，默认值为true，表示请求中一定要有相应的参数，否则将报404错误码，示例： 1234567891011121314151617181920212223package org.zero01.test;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controller@RequestMapping("/test")public class Test &#123; @RequestMapping("test.do") // 指定username参数是必须的，如果url上没有的话就会报错 public void test(@RequestParam(name = "username", required = true) String name) &#123; System.out.println(name); &#125; @RequestMapping("user.do") // 指定username与alias参数不是必须的，即便url上没有也不会报错 public void userAndAlias(@RequestParam(name = "username", required = false) String user, @RequestParam(name = "alias", required = false) String a) &#123; System.out.println(user); System.out.println(a); &#125;&#125; 3.defaultValue属性，该属性用于指定参数的默认值，表示如果请求中没有同名参数时的默认值，默认值可以是SpEL表达式，如“#{systemProperties[‘java.vm.version’]}”。示例： 1234567891011121314151617181920212223package org.zero01.test;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controller@RequestMapping("/test")public class Test &#123; @RequestMapping("test.do") // url上没有username参数时，给它设置一个默认值为nothing public void test(@RequestParam(name = "username", defaultValue = "nothing") String name) &#123; System.out.println(name); &#125; @RequestMapping("user.do") // url上没有username以及alias参数时，给它设置一个默认值为nothing public void userAndAlias(@RequestParam(name = "username", defaultValue = "nothing") String user, @RequestParam(name = "alias", defaultValue = "nothing") String a) &#123; System.out.println(user); System.out.println(a); &#125;&#125;]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 前后端分离 开发大众点评项目]]></title>
    <url>%2F2019%2F02%2F12%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84%E6%85%95%E8%AF%BE%E7%BD%91%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[第1章 课程概览 第二章 开发准备1 运行前端项目 12345cd /xxx前端项目npm installnpm run mock]]></content>
      <tags>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F12%2FTest%2F</url>
    <content type="text"><![CDATA[1 常用代码块1$&#123;pageContext.request.contextPath&#125;/xxx/xxx/xx 1mvn test]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F11%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%2F%E8%BE%85%E5%AF%BC%E8%B5%84%E6%96%99%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F11%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%2F%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%983%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F11%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%2F%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%982%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F11%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%2F%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%981%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯 去除重重复因子 不懂]]></title>
    <url>%2F2019%2F02%2F11%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%2F%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%9B%A0%E5%AD%90%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819public class Code2 &#123; public static void main(String[] args) &#123; // 给定一个正整数n，求一个正整数p， // 满足p仅包含n的所有素因子，且每个素因子的次数不大于1 Scanner ci = new Scanner(System.in); long n = ci.nextLong(); long ans = 1; long x = n; for (long i = 2; i &lt;= x; i++) &#123; if (x % i == 0) &#123; ans *= i; &#125; while (x % i == 0) &#123; x /= i; &#125; &#125; System.out.println(ans); &#125;&#125;]]></content>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式session]]></title>
    <url>%2F2019%2F02%2F05%2F%E6%8A%80%E6%9C%AF%E6%A0%88%2F%E5%88%86%E5%B8%83%E5%BC%8Fsession%2F%E5%88%86%E5%B8%83%E5%BC%8FSession%2F</url>
    <content type="text"><![CDATA[分布式session]]></content>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Redis]]></title>
    <url>%2F2019%2F02%2F05%2FRedis%2FSpringBoot%20Redis%2F</url>
    <content type="text"><![CDATA[1 依赖1234567891011121314151617&lt;!--redis纯洁的微笑--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--redis 纯洁的微笑--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-codec&lt;/artifactId&gt; &lt;version&gt;4.1.31.Final&lt;/version&gt; &lt;/dependency&gt; 2 配置文件12345678spring.redis.database=1spring.redis.host=127.0.0.1spring.redis.port=6379spring.redis.password=spring.redis.lettuce.pool.max-active=8spring.redis.lettuce.pool.max-wait=-1spring.redis.lettuce.pool.max-idle=8spring.redis.lettuce.pool.min-idle=0 3.RedisConfig1234567891011121314151617181920212223242526272829303132package com.imooc.miaosha.Redis_new;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;@Configuration@EnableCaching//开启缓存public class RedisConfig extends CachingConfigurerSupport &#123; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; StringRedisTemplate template = new StringRedisTemplate(factory); Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125; 4.Controller123456789101112131415161718192021222324@Controller@RequestMapping("/redis")public class RedisTestController &#123; @Autowired private RedisTemplate&lt;String, String&gt; redisTemplate; @RequestMapping("/string") @ResponseBody public void testString() &#123; redisTemplate.opsForValue().set("neo", "redis"); &#125; @RequestMapping("/get") @ResponseBody public void getString() &#123; redisTemplate.opsForValue().get("neo"); &#125; @RequestMapping("/test") @ResponseBody public void test() &#123; redisTemplate.opsForValue().set("hhh", "hexo"); &#125;&#125; RedisConfig（附录）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.imooc.miaosha.Redis_new;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import java.lang.reflect.Method;import java.time.Duration;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;@Configuration@EnableCaching//开启缓存public class RedisConfig extends CachingConfigurerSupport &#123; @Bean public KeyGenerator keyGenerator() &#123; return new KeyGenerator() &#123; @Override public Object generate(Object target, Method method, Object... params) &#123; StringBuilder sb = new StringBuilder(); sb.append(target.getClass().getName()); sb.append(method.getName()); for (Object obj : params) &#123; sb.append(obj.toString()); &#125; return sb.toString(); &#125; &#125;; &#125; @Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisCacheManager cacheManager = RedisCacheManager.create(factory); return cacheManager; &#125; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; StringRedisTemplate template = new StringRedisTemplate(factory); Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125; @Bean public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory factory) &#123; StringRedisTemplate stringRedisTemplate = new StringRedisTemplate(); stringRedisTemplate.setConnectionFactory(factory); return stringRedisTemplate; &#125;&#125; 参考资料 https://blog.csdn.net/sy793314598/article/details/80719224 https://blog.csdn.net/long290046464/article/details/76596103 https://blog.csdn.net/long290046464/article/details/76596103 https://segmentfault.com/q/1010000015203664/a-1020000015204174]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[范型]]></title>
    <url>%2F2019%2F02%2F05%2Fjava%E5%9F%BA%E7%A1%80%2F%E8%8C%83%E5%9E%8B%2F</url>
    <content type="text"></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[extends关键字]]></title>
    <url>%2F2019%2F02%2F04%2Fjava%E5%9F%BA%E7%A1%80%2Fextends%2F</url>
    <content type="text"></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[abstract关键字]]></title>
    <url>%2F2019%2F02%2F04%2Fjava%E5%9F%BA%E7%A1%80%2Fabstract%2F</url>
    <content type="text"><![CDATA[抽象：不具体，看不明白。 抽象类表象体现。 在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。 抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。 抽象类的特点： 1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。 2：抽象方法只定义方法声明，并不定义方法实现。 3：抽象类不可以被创建对象(实例化)。 4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。 抽象类的细节： 1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。 2：抽象类中是否可以定义非抽象方法？ 可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。 3：抽象关键字abstract和哪些不可以共存？final , private , static 4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this关键字]]></title>
    <url>%2F2019%2F02%2F04%2Fjava%E5%9F%BA%E7%A1%80%2FThis%2F</url>
    <content type="text"><![CDATA[Java中this关键字在构造方法中的使用\1. Java中this关键字代表对象本身。用this关键字可以在类的内部调用属性和方法，这样代码的可读性比较高，因为它明确的指出了这个属性或方法的来源。 \2. 同时在构造函数中也可以使用this关键字调用本类中的其它构造函数，但有几点需要注意： 构造函数调用其它构造函数，需要将this写在构造函数的第一行。 构造函数不可递归，防止死循环。 \3. 一个类的构造函数分为无参和有参构造函数。通常做法是指定写好一个包含所有字段的构造函数，然后其它构造函数可以直接调用该函数，实现代码重用 https://www.cnblogs.com/yougewe/p/9468960.html 说到抽象，想必大家第一个联想到的就是抽象画，基本上看不懂画的是啥，只能说它在表达某个概念。在java中我们中abstract关键字来表达抽象。举个例子：我们说车子都可以跑(run)。但有几个轮子，怎么跑，对于不同的车有不同的结果。自行车需要人踩着跑，汽车发动机推动跑等等，那么我们可以车表达为抽象类。 /** 车子类 */ public abstract class Car { public abstract void run(); } /** 自行车 */ class Bicycle extends Car{ @Override public void run() { System.out.println(&quot;人踩着跑。。。&quot;); } }/*** 汽车 */ class Automobile extends Car{ @Override public void run() { System.out.println(&quot;发动机驱动跑。。。&quot;); } }1234567891011121314151617181920212223242526272829假如后面各种车，倒着跑、悬在空中跑随你怎么跑，只需要继承抽象类实现自己的业务就行了。相信大家对java抽象已有一个初步的印象了。 抽象方法： 1、从上面的例子中我们可以看到抽象方法跟普通方法是有区别的，它没有自己的主体（没有{}包起来的业务逻辑），跟接口中的方法有点类似。所以我们没法直接调用抽象方法 2、抽象方法不能用private修饰，因为抽象方法必须被子类实现（覆写），而private权限对于子类来说是不能访问的，所以就会产生矛盾 3、抽象方法也不能用static修饰，试想一下，如果用static修饰了，那么我们可以直接通过类名调用，而抽象方法压根就没有主体，没有任何业务逻辑，这样就毫无意义了。12345678抽象类： 1、用abstract关键字来表达的类，其表达形式为：（public）abstract class 类名{} 2、抽象类不能被实例化，也就是说我们没法直接new 一个抽象类。抽象类本身就代表了一个类型，无法确定为一个具体的对象，所以不能实例化就合乎情理了，只能有它的继承类实例化。 3、抽象类虽然不能被实例化，但有自己的构造方法（这个后面再讨论） 4、抽象类与接口（interface）有很大的不同之处，接口中不能有实例方法去实现业务逻辑，而抽象类中可以有实例方法，并实现业务逻辑，比如我们可以在抽象类中创建和销毁一个线程池。 5、抽象类不能使用finally关键字修饰，因为finally修饰的类是无法被继承，而对于抽象类来说就是需要通过继承去实现抽象方法，这又会产生矛盾。（后面将写一篇关于finally的文章详细讨论）123456789101112抽象类与抽象方法的关联： 如果一个类中至少有一个抽象方法，那么这个类一定是抽象类，但反之则不然。也就是说一个抽象类中可以没有抽象方法。这样做的目的是为了此类不能被实例化。 如果一个类继承了一个抽象类，那么它必须全部覆写抽象类中的抽象方法，当然也可以不全部覆写，如果不覆写全部抽象方法则这个子类也必须是抽象类（这样做就无意义了）12345public abstract class Car { public void mothod1(){ } public abstract void mothod2(); public abstract void method3(); }class Bicycle extends Car{ @Override public void mothod2() {//需要覆写抽象方法mothod2 } @Override public void method3() {//需要覆写抽象方法mothod3 } }123456789101112131415161718192021抽象类的构造器： 先来看一个例子： public abstract class Car { Car(){ System.out.println(&quot;抽象方法无参构造函数&quot;); } Car(String a){ System.out.println(&quot;抽象有参构造方法&quot;); } public void mothod1(){ System.out.println(this.getClass()); System.out.println(&quot;抽象类的实例方法&quot;); } public abstract void mothod2(); }/** 自行车 */ class Bicycle extends Car{ Bicycle(){ System.out.println(&quot;子类无参构造函数&quot;); } @Override public void mothod2() {//需要覆写抽象方法mothod2 } } /另一个包的测试类/ public class Test { public static void main(String[] args) { Bicycle b = new Bicycle(); b.mothod1(); } } 结果： 抽象方法无参构造函数 子类无参构造函数 class com.shaolin.service.impl.Bicycle 抽象类的实例方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 从上面的例子中可以看出： 1、抽象类是有构造方法的（当然如果我们不写，编译器会自动默认一个无参构造方法）。而且从结果来看，和普通的继承类一样，在new 一个子类对象时会优先调用父类（这里指的是抽象类Car）的构造器初始化，然后再调用子类的构造器。至此相信大家都会有这样一个疑问，为什么抽象方法不能实例化却有构造器呢？ 对于这个问题网上也中说纷纭，没有确定答案。我是这样想的：既然它也属于继承的范畴，那么当子类创建对象时必然要优先初始化父类的属性变量和实例方法，不然子类怎么继承和调用呢？而它本身不能实例化，因为它本身就是不确定的一个对象，如果它能被实例化，那么我们通过它的对象来调用它本身的抽象方法是不是有问题。所以不能实例化有在情理之中。因此大家只要记住这个规定就行。 2、对于抽象类中的非statci(静态)和非abstract(抽象)方法中的this关键字（静态方法中不能有关键字this之前已经讨论过可以参考 关于静态static那些事）代表的是它的继承类，而非抽象类本身，这个好理解，因为抽象类本身不能被实例化。如果有多个继承类，谁调用this就代表谁。 抽象类有什么好处呢？1、由于抽象类不能被实例化，最大的好处就是通过方法的覆盖来实现多态的属性。也就是运行期绑定2、抽象类将事物的共性的东西提取出来，由子类继承去实现，代码易扩展、易维护。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登陆模块的设计]]></title>
    <url>%2F2019%2F02%2F03%2F%E4%BB%A3%E7%A0%81snip%2Fsnip1%2F%E7%99%BB%E9%99%86%E6%A8%A1%E5%9D%97%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1.统一消息处理 前后端分离12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Result&lt;T&gt; &#123; private int code; private String msg; private T data;//失败的时候调用 private Result(CodeMsg cm) &#123; if(cm=null) &#123; return; &#125; this.code=cm.getCode(); this.msg=cm.getMsg(); &#125;//成功的时候调用 private Result(T data)&#123; this.code=0; this.msg="SUCCESS"; this.data=data; &#125; //失败的时候调用 public static &lt;T&gt; Result&lt;T&gt; Error(CodeMsg cm)&#123; return new Result&lt;T&gt;(cm); &#125; //成功的时候调用 public static &lt;T&gt; Result&lt;T&gt; Success(T data)&#123; return new Result&lt;T&gt;(data); &#125; //生成构造方法 public Result(int code)&#123; this.code=code; &#125; public Result(String msg)&#123; this.msg=msg; &#125; //生成set/get方法 public int getCode()&#123; return code; &#125; public void setCode(int code)&#123; this.code=code; &#125; public int getMsg()&#123; return msg; &#125; public void setMsg(String msg)&#123; this.msg=msg; &#125; public T getData()&#123; return data; &#125; public void setData(T data)&#123; this.data=data; &#125;&#125; 123456789101112131415161718192021222324public class CodeMsg&#123; private int code; private String msg; //通用异常public static CodeMsg SUCCESS=new CodeMsg(0, "success");public static CodeMsg ERROR =new CodeMsg(-1, "error"); private CodeMsg(int code,String msg)&#123; this.code=code; this.msg=msg; &#125; public int getCode()&#123; return code; &#125; public String getMsg()&#123; return msg; &#125;&#125; 2 在Controller中使用@ResponseBody注解 返回JSON数据 return 12345678910@Controller@RequestMappingpublic class DemoTestController &#123; @RequestMapping("/") @ResponseBody//通常用来返回JSON数据或者是XML/ String home() &#123; return "hello world"; &#125; 1234567891011121314151617181920212223242526@RequestMapping("/resultsuccess")@ResponseBodypublic Result&lt;String&gt; resultsuccess() &#123; //⭐️⭐️⭐️⭐️⭐️ /**1.返回成功的时候调用 * public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123; * return new Result&lt;T&gt;(data); * &#125; * * private Result(T data) &#123; * this.code = 0; * this.msg = "success"; * this.data = data; * &#125; * 1.Result.success(data); * 结果： * &#123; * "code": 0, * "msg": "success", * "data": "hello immooc" * &#125; */ return Result.success("hello immooc");&#125; 12345678910111213141516171819202122232425262728293031323334@RequestMapping("/resulterror") @ResponseBody public Result&lt;String&gt; resultError() &#123; /** * 2。失败的时候调用 * public static &lt;T&gt; Result&lt;T&gt; error(CodeMsg cm) &#123; * return new Result&lt;T&gt;(cm); * &#125; * * private Result(CodeMsg cm) &#123; * if (cm == null) &#123; * return; * &#125; * this.code = cm.getCode(); * this.msg = cm.getMsg(); * &#125; * 2 Result.error(CodeMsg.SERVER_NAME) * public static CodeMsg SERVER_NAME = new CodeMsg(50001, "服务端异常"); * * 结果 &#123; * "code": 50001, * "msg": "服务端异常", * "data": null * &#125; * 分析： * 因为CodeMsg SUCCESS 用static修饰了 * public static CodeMsg SUCCESS = new CodeMsg(0, "success"); * 所以可以使用类.属性.属性的方式获得 * CodeMsg.SUCCESS.code=50001 * CodeMsg.SUCCESS.msg="服务端异常" */ return Result.error(CodeMsg.SERVER_NAME); &#125; 3 前后的分离的分析 4 Controller 层的代码编写 snipLoginController123456789101112131415161718192021222324@Controller@RequestMapping("/login")public class LoginController &#123; //self4日志处理 private static Logger logger = LoggerFactory.getLogger(LoginController.class); @Autowired private MiaoShaoUserServiceImpl miaoShaoUserService; @RequestMapping("/to_login") public String toLogin() &#123; return "login";//跳转到登陆页面login.html &#125; @RequestMapping("/do_login") @ResponseBody //loginVo用户登陆的POJO public Result doLogin(@Valid LoginVo loginVo) &#123; logger.info(loginVo.toString()); //核心代码 ⭐️⭐️ miaoShaoUserService.login(loginVo); return Result.success(true); &#125;&#125; POJO loginVo12345678910111213141516171819202122232425262728293031323334package com.imooc.miaosha.domain;import com.imooc.miaosha.validate.IsMobile;import org.hibernate.validator.constraints.Length;import javax.validation.constraints.NotNull;public class LoginVo &#123; @NotNull //自定义validator @IsMobile private String mobile; @NotNull @Length(min = 32) private String password; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "LoginVo&#123;" + "mobile='" + mobile + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; MiaoShaoUserService.12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class MiaoShaoUserServiceImpl implements MiaoShaoUserService &#123; @Autowired private MiaoshaUserMapper miaoshaUserMapper; @Override //得到数据库里面的User用户的所有字段 getById(long id) public MiaoshaUser getById(long id) &#123; return miaoshaUserMapper.selectByPrimaryKey(id); &#125; //检测是否登陆 loginVo和前端ajax data绑定了 public boolean login(LoginVo loginVo) &#123; if (loginVo == null) &#123; throw new GlobalException(CodeMsg.SERVER_ERROR); &#125; // 拿到页面中的手机号码 String form_mobile = loginVo.getMobile(); // 拿到页面中的密码 String form_Password = loginVo.getPassword(); //判断手机号是否存在getById==selectByPrimaryKey(id) 看看数据库中存不存在这个数据 //将查询出来的数据变成miaoshaUser MiaoshaUser miaoshaUser = getById(Long.parseLong(form_mobile)); if (miaoshaUser == null) &#123; throw new GlobalException(CodeMsg.MOBILE_NOT_EXIST); &#125; //如果用户存在 //1 验证密码 //数据库里面的密码 dbPassword b7797cce01b4b131b433b6acf4add 449 String dbPassword = miaoshaUser.getPassword();//Md5Utils.inputPassToDbPass()=dbPass //数据库里面的盐值 String dbSalt = miaoshaUser.getSalt(); //经过计算得到的密码 原密码 123456 calcpass= d3b1294a61a07da9b49b6e22b2cbd7 f9 String calcPass = MD5Util.fromPassToDBPass(form_Password, dbSalt); //==inputPassToDbPass=calcPass if (!calcPass.equals(dbPassword)) &#123; throw new GlobalException(CodeMsg.PASSWORED_ERROR); &#125; return true; &#125;&#125; MiaoshaUserMapper–selectByPrimaryKey12345@Mapperpublic interface MiaoshaUserMapper &#123; //id=手机号码 返回一个MiaoshaUser对象 MiaoshaUser selectByPrimaryKey(Long id);&#125; 123456&lt;select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap"&gt; select id, nickname, `password`, salt, head, registerr_date, login_count from miaosha_user where id = #&#123;id,jdbcType=BIGINT&#125; &lt;/select&gt; MD5Utils 密码加密12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.imooc.miaosha.utils;import org.apache.commons.codec.digest.DigestUtils;public class MD5Util &#123; public static void main(String args[]) &#123; System.out.println(inputPassToFormPass("123456")); //d3b1294a61a07da9b49b6e22b2cbd7 f9 System.out.println(fromPassToDBPass("123456", "1a2b3c4d")); //d3b1294a61a07da9b49b6e22b2cbd7 f9 System.out.println(inputPassToDbPass("123456","1a2b3c4d")); //b7797cce01b4b131b433b6acf4add 449 &#125; /*固定盐值*/ private static final String salt = "1a2b3c4d"; //注意导包为codec中的DigestUtils类.codec.digest.DigestUtils; public static String md5(String src) &#123; //计算MD5摘要并以32个字符十六进制字符串的形式返回值。 return DigestUtils.md5Hex(src); &#125; /** * 第一次md5 ： * 用于 通过输入的密码生成 * 传输的密码 ： 方法 通过固定盐值和明文密码之间的拼接在生成md5 */ public static String inputPassToFormPass(String inputPass) &#123; String str = "" + salt.charAt(0) + salt.charAt(2) + inputPass + salt.charAt(5) + salt.charAt(4); return md5(str); &#125; /** * 第二次md5 ： */ public static String fromPassToDBPass(String formpasss, String salt) &#123; String str = "" + salt.charAt(0) + salt.charAt(2) + formpasss + salt.charAt(5) + salt.charAt(4); return md5(str); &#125; //将密码封装到数据库中 public static String inputPassToDbPass(String input, String saltDB) &#123; String s = inputPassToFormPass(input); String formPass = fromPassToDBPass(s, saltDB); return formPass; &#125;&#125; Ajax12345678910111213141516171819202122232425262728293031function doLogin() &#123; ..密码处理 var inputpass = $("#password").val(); var salt = "1a2b3c4d"; var str = "" + salt.charAt(0) + salt.charAt(2) + inputpass + salt.charAt(5) + salt.charAt(4); var password = md5(str); $.ajax(&#123; url: "/login/do_login", type: "POST", data: &#123; mobile: $("#mobile").val(), password: password &#125;, success: function (data) &#123; layer.closeAll(); if (data.code == 0) &#123; layer.msg("成功"); &#125; else &#123; layer.msg(data.msg); &#125; console.log(data); &#125;, error: function () &#123; layer.closeAll(); &#125; &#125;);&#125; MD5.min.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/** * [js-md5]&#123;@link https://github.com/emn178/js-md5&#125; * * @namespace md5 * @version 0.7.2 * @author Chen, Yi-Cyuan [emn178@gmail.com] * @copyright Chen, Yi-Cyuan 2014-2017 * @license MIT */!function () &#123; "use strict"; function Md5(t) &#123; if (t) blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks, this.buffer8 = buffer8; else if (ARRAY_BUFFER) &#123; var r = new ArrayBuffer(68); this.buffer8 = new Uint8Array(r), this.blocks = new Uint32Array(r) &#125; else this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0 &#125; var ERROR = "input is invalid type", WINDOW = "object" == typeof window, root = WINDOW ? window : &#123;&#125;; root.JS_MD5_NO_WINDOW &amp;&amp; (WINDOW = !1); var WEB_WORKER = !WINDOW &amp;&amp; "object" == typeof self, NODE_JS = !root.JS_MD5_NO_NODE_JS &amp;&amp; "object" == typeof process &amp;&amp; process.versions &amp;&amp; process.versions.node; NODE_JS ? root = global : WEB_WORKER &amp;&amp; (root = self); var COMMON_JS = !root.JS_MD5_NO_COMMON_JS &amp;&amp; "object" == typeof module &amp;&amp; module.exports, AMD = "function" == typeof define &amp;&amp; define.amd, ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER &amp;&amp; "undefined" != typeof ArrayBuffer, HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [128, 32768, 8388608, -2147483648], SHIFT = [0, 8, 16, 24], OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"], BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), blocks = [], buffer8; if (ARRAY_BUFFER) &#123; var buffer = new ArrayBuffer(68); buffer8 = new Uint8Array(buffer), blocks = new Uint32Array(buffer) &#125; (root.JS_MD5_NO_NODE_JS || !Array.isArray) &amp;&amp; (Array.isArray = function (t) &#123; return "[object Array]" === Object.prototype.toString.call(t) &#125;), !ARRAY_BUFFER || !root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW &amp;&amp; ArrayBuffer.isView || (ArrayBuffer.isView = function (t) &#123; return "object" == typeof t &amp;&amp; t.buffer &amp;&amp; t.buffer.constructor === ArrayBuffer &#125;); var createOutputMethod = function (t) &#123; return function (r) &#123; return new Md5(!0).update(r)[t]() &#125; &#125;, createMethod = function () &#123; var t = createOutputMethod("hex"); NODE_JS &amp;&amp; (t = nodeWrap(t)), t.create = function () &#123; return new Md5 &#125;, t.update = function (r) &#123; return t.create().update(r) &#125;; for (var r = 0; r &lt; OUTPUT_TYPES.length; ++r) &#123; var e = OUTPUT_TYPES[r]; t[e] = createOutputMethod(e) &#125; return t &#125;, nodeWrap = function (method) &#123; var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), nodeMethod = function (t) &#123; if ("string" == typeof t) return crypto.createHash("md5").update(t, "utf8").digest("hex"); if (null === t || void 0 === t) throw ERROR; return t.constructor === ArrayBuffer &amp;&amp; (t = new Uint8Array(t)), Array.isArray(t) || ArrayBuffer.isView(t) || t.constructor === Buffer ? crypto.createHash("md5").update(new Buffer(t)).digest("hex") : method(t) &#125;; return nodeMethod &#125;; Md5.prototype.update = function (t) &#123; if (!this.finalized) &#123; var r, e = typeof t; if ("string" !== e) &#123; if ("object" !== e) throw ERROR; if (null === t) throw ERROR; if (ARRAY_BUFFER &amp;&amp; t.constructor === ArrayBuffer) t = new Uint8Array(t); else if (!(Array.isArray(t) || ARRAY_BUFFER &amp;&amp; ArrayBuffer.isView(t))) throw ERROR; r = !0 &#125; for (var s, i, o = 0, h = t.length, f = this.blocks, a = this.buffer8; h &gt; o;) &#123; if (this.hashed &amp;&amp; (this.hashed = !1, f[0] = f[16], f[16] = f[1] = f[2] = f[3] = f[4] = f[5] = f[6] = f[7] = f[8] = f[9] = f[10] = f[11] = f[12] = f[13] = f[14] = f[15] = 0), r) if (ARRAY_BUFFER) for (i = this.start; h &gt; o &amp;&amp; 64 &gt; i; ++o) a[i++] = t[o]; else for (i = this.start; h &gt; o &amp;&amp; 64 &gt; i; ++o) f[i &gt;&gt; 2] |= t[o] &lt;&lt; SHIFT[3 &amp; i++]; else if (ARRAY_BUFFER) for (i = this.start; h &gt; o &amp;&amp; 64 &gt; i; ++o) s = t.charCodeAt(o), 128 &gt; s ? a[i++] = s : 2048 &gt; s ? (a[i++] = 192 | s &gt;&gt; 6, a[i++] = 128 | 63 &amp; s) : 55296 &gt; s || s &gt;= 57344 ? (a[i++] = 224 | s &gt;&gt; 12, a[i++] = 128 | s &gt;&gt; 6 &amp; 63, a[i++] = 128 | 63 &amp; s) : (s = 65536 + ((1023 &amp; s) &lt;&lt; 10 | 1023 &amp; t.charCodeAt(++o)), a[i++] = 240 | s &gt;&gt; 18, a[i++] = 128 | s &gt;&gt; 12 &amp; 63, a[i++] = 128 | s &gt;&gt; 6 &amp; 63, a[i++] = 128 | 63 &amp; s); else for (i = this.start; h &gt; o &amp;&amp; 64 &gt; i; ++o) s = t.charCodeAt(o), 128 &gt; s ? f[i &gt;&gt; 2] |= s &lt;&lt; SHIFT[3 &amp; i++] : 2048 &gt; s ? (f[i &gt;&gt; 2] |= (192 | s &gt;&gt; 6) &lt;&lt; SHIFT[3 &amp; i++], f[i &gt;&gt; 2] |= (128 | 63 &amp; s) &lt;&lt; SHIFT[3 &amp; i++]) : 55296 &gt; s || s &gt;= 57344 ? (f[i &gt;&gt; 2] |= (224 | s &gt;&gt; 12) &lt;&lt; SHIFT[3 &amp; i++], f[i &gt;&gt; 2] |= (128 | s &gt;&gt; 6 &amp; 63) &lt;&lt; SHIFT[3 &amp; i++], f[i &gt;&gt; 2] |= (128 | 63 &amp; s) &lt;&lt; SHIFT[3 &amp; i++]) : (s = 65536 + ((1023 &amp; s) &lt;&lt; 10 | 1023 &amp; t.charCodeAt(++o)), f[i &gt;&gt; 2] |= (240 | s &gt;&gt; 18) &lt;&lt; SHIFT[3 &amp; i++], f[i &gt;&gt; 2] |= (128 | s &gt;&gt; 12 &amp; 63) &lt;&lt; SHIFT[3 &amp; i++], f[i &gt;&gt; 2] |= (128 | s &gt;&gt; 6 &amp; 63) &lt;&lt; SHIFT[3 &amp; i++], f[i &gt;&gt; 2] |= (128 | 63 &amp; s) &lt;&lt; SHIFT[3 &amp; i++]); this.lastByteIndex = i, this.bytes += i - this.start, i &gt;= 64 ? (this.start = i - 64, this.hash(), this.hashed = !0) : this.start = i &#125; return this.bytes &gt; 4294967295 &amp;&amp; (this.hBytes += this.bytes / 4294967296 &lt;&lt; 0, this.bytes = this.bytes % 4294967296), this &#125; &#125;, Md5.prototype.finalize = function () &#123; if (!this.finalized) &#123; this.finalized = !0; var t = this.blocks, r = this.lastByteIndex; t[r &gt;&gt; 2] |= EXTRA[3 &amp; r], r &gt;= 56 &amp;&amp; (this.hashed || this.hash(), t[0] = t[16], t[16] = t[1] = t[2] = t[3] = t[4] = t[5] = t[6] = t[7] = t[8] = t[9] = t[10] = t[11] = t[12] = t[13] = t[14] = t[15] = 0), t[14] = this.bytes &lt;&lt; 3, t[15] = this.hBytes &lt;&lt; 3 | this.bytes &gt;&gt; 29, this.hash() &#125; &#125;, Md5.prototype.hash = function () &#123; var t, r, e, s, i, o, h = this.blocks; this.first ? (t = h[0] - 680876937, t = (t &lt;&lt; 7 | t &gt;&gt;&gt; 25) - 271733879 &lt;&lt; 0, s = (-1732584194 ^ 2004318071 &amp; t) + h[1] - 117830708, s = (s &lt;&lt; 12 | s &gt;&gt;&gt; 20) + t &lt;&lt; 0, e = (-271733879 ^ s &amp; (-271733879 ^ t)) + h[2] - 1126478375, e = (e &lt;&lt; 17 | e &gt;&gt;&gt; 15) + s &lt;&lt; 0, r = (t ^ e &amp; (s ^ t)) + h[3] - 1316259209, r = (r &lt;&lt; 22 | r &gt;&gt;&gt; 10) + e &lt;&lt; 0) : (t = this.h0, r = this.h1, e = this.h2, s = this.h3, t += (s ^ r &amp; (e ^ s)) + h[0] - 680876936, t = (t &lt;&lt; 7 | t &gt;&gt;&gt; 25) + r &lt;&lt; 0, s += (e ^ t &amp; (r ^ e)) + h[1] - 389564586, s = (s &lt;&lt; 12 | s &gt;&gt;&gt; 20) + t &lt;&lt; 0, e += (r ^ s &amp; (t ^ r)) + h[2] + 606105819, e = (e &lt;&lt; 17 | e &gt;&gt;&gt; 15) + s &lt;&lt; 0, r += (t ^ e &amp; (s ^ t)) + h[3] - 1044525330, r = (r &lt;&lt; 22 | r &gt;&gt;&gt; 10) + e &lt;&lt; 0), t += (s ^ r &amp; (e ^ s)) + h[4] - 176418897, t = (t &lt;&lt; 7 | t &gt;&gt;&gt; 25) + r &lt;&lt; 0, s += (e ^ t &amp; (r ^ e)) + h[5] + 1200080426, s = (s &lt;&lt; 12 | s &gt;&gt;&gt; 20) + t &lt;&lt; 0, e += (r ^ s &amp; (t ^ r)) + h[6] - 1473231341, e = (e &lt;&lt; 17 | e &gt;&gt;&gt; 15) + s &lt;&lt; 0, r += (t ^ e &amp; (s ^ t)) + h[7] - 45705983, r = (r &lt;&lt; 22 | r &gt;&gt;&gt; 10) + e &lt;&lt; 0, t += (s ^ r &amp; (e ^ s)) + h[8] + 1770035416, t = (t &lt;&lt; 7 | t &gt;&gt;&gt; 25) + r &lt;&lt; 0, s += (e ^ t &amp; (r ^ e)) + h[9] - 1958414417, s = (s &lt;&lt; 12 | s &gt;&gt;&gt; 20) + t &lt;&lt; 0, e += (r ^ s &amp; (t ^ r)) + h[10] - 42063, e = (e &lt;&lt; 17 | e &gt;&gt;&gt; 15) + s &lt;&lt; 0, r += (t ^ e &amp; (s ^ t)) + h[11] - 1990404162, r = (r &lt;&lt; 22 | r &gt;&gt;&gt; 10) + e &lt;&lt; 0, t += (s ^ r &amp; (e ^ s)) + h[12] + 1804603682, t = (t &lt;&lt; 7 | t &gt;&gt;&gt; 25) + r &lt;&lt; 0, s += (e ^ t &amp; (r ^ e)) + h[13] - 40341101, s = (s &lt;&lt; 12 | s &gt;&gt;&gt; 20) + t &lt;&lt; 0, e += (r ^ s &amp; (t ^ r)) + h[14] - 1502002290, e = (e &lt;&lt; 17 | e &gt;&gt;&gt; 15) + s &lt;&lt; 0, r += (t ^ e &amp; (s ^ t)) + h[15] + 1236535329, r = (r &lt;&lt; 22 | r &gt;&gt;&gt; 10) + e &lt;&lt; 0, t += (e ^ s &amp; (r ^ e)) + h[1] - 165796510, t = (t &lt;&lt; 5 | t &gt;&gt;&gt; 27) + r &lt;&lt; 0, s += (r ^ e &amp; (t ^ r)) + h[6] - 1069501632, s = (s &lt;&lt; 9 | s &gt;&gt;&gt; 23) + t &lt;&lt; 0, e += (t ^ r &amp; (s ^ t)) + h[11] + 643717713, e = (e &lt;&lt; 14 | e &gt;&gt;&gt; 18) + s &lt;&lt; 0, r += (s ^ t &amp; (e ^ s)) + h[0] - 373897302, r = (r &lt;&lt; 20 | r &gt;&gt;&gt; 12) + e &lt;&lt; 0, t += (e ^ s &amp; (r ^ e)) + h[5] - 701558691, t = (t &lt;&lt; 5 | t &gt;&gt;&gt; 27) + r &lt;&lt; 0, s += (r ^ e &amp; (t ^ r)) + h[10] + 38016083, s = (s &lt;&lt; 9 | s &gt;&gt;&gt; 23) + t &lt;&lt; 0, e += (t ^ r &amp; (s ^ t)) + h[15] - 660478335, e = (e &lt;&lt; 14 | e &gt;&gt;&gt; 18) + s &lt;&lt; 0, r += (s ^ t &amp; (e ^ s)) + h[4] - 405537848, r = (r &lt;&lt; 20 | r &gt;&gt;&gt; 12) + e &lt;&lt; 0, t += (e ^ s &amp; (r ^ e)) + h[9] + 568446438, t = (t &lt;&lt; 5 | t &gt;&gt;&gt; 27) + r &lt;&lt; 0, s += (r ^ e &amp; (t ^ r)) + h[14] - 1019803690, s = (s &lt;&lt; 9 | s &gt;&gt;&gt; 23) + t &lt;&lt; 0, e += (t ^ r &amp; (s ^ t)) + h[3] - 187363961, e = (e &lt;&lt; 14 | e &gt;&gt;&gt; 18) + s &lt;&lt; 0, r += (s ^ t &amp; (e ^ s)) + h[8] + 1163531501, r = (r &lt;&lt; 20 | r &gt;&gt;&gt; 12) + e &lt;&lt; 0, t += (e ^ s &amp; (r ^ e)) + h[13] - 1444681467, t = (t &lt;&lt; 5 | t &gt;&gt;&gt; 27) + r &lt;&lt; 0, s += (r ^ e &amp; (t ^ r)) + h[2] - 51403784, s = (s &lt;&lt; 9 | s &gt;&gt;&gt; 23) + t &lt;&lt; 0, e += (t ^ r &amp; (s ^ t)) + h[7] + 1735328473, e = (e &lt;&lt; 14 | e &gt;&gt;&gt; 18) + s &lt;&lt; 0, r += (s ^ t &amp; (e ^ s)) + h[12] - 1926607734, r = (r &lt;&lt; 20 | r &gt;&gt;&gt; 12) + e &lt;&lt; 0, i = r ^ e, t += (i ^ s) + h[5] - 378558, t = (t &lt;&lt; 4 | t &gt;&gt;&gt; 28) + r &lt;&lt; 0, s += (i ^ t) + h[8] - 2022574463, s = (s &lt;&lt; 11 | s &gt;&gt;&gt; 21) + t &lt;&lt; 0, o = s ^ t, e += (o ^ r) + h[11] + 1839030562, e = (e &lt;&lt; 16 | e &gt;&gt;&gt; 16) + s &lt;&lt; 0, r += (o ^ e) + h[14] - 35309556, r = (r &lt;&lt; 23 | r &gt;&gt;&gt; 9) + e &lt;&lt; 0, i = r ^ e, t += (i ^ s) + h[1] - 1530992060, t = (t &lt;&lt; 4 | t &gt;&gt;&gt; 28) + r &lt;&lt; 0, s += (i ^ t) + h[4] + 1272893353, s = (s &lt;&lt; 11 | s &gt;&gt;&gt; 21) + t &lt;&lt; 0, o = s ^ t, e += (o ^ r) + h[7] - 155497632, e = (e &lt;&lt; 16 | e &gt;&gt;&gt; 16) + s &lt;&lt; 0, r += (o ^ e) + h[10] - 1094730640, r = (r &lt;&lt; 23 | r &gt;&gt;&gt; 9) + e &lt;&lt; 0, i = r ^ e, t += (i ^ s) + h[13] + 681279174, t = (t &lt;&lt; 4 | t &gt;&gt;&gt; 28) + r &lt;&lt; 0, s += (i ^ t) + h[0] - 358537222, s = (s &lt;&lt; 11 | s &gt;&gt;&gt; 21) + t &lt;&lt; 0, o = s ^ t, e += (o ^ r) + h[3] - 722521979, e = (e &lt;&lt; 16 | e &gt;&gt;&gt; 16) + s &lt;&lt; 0, r += (o ^ e) + h[6] + 76029189, r = (r &lt;&lt; 23 | r &gt;&gt;&gt; 9) + e &lt;&lt; 0, i = r ^ e, t += (i ^ s) + h[9] - 640364487, t = (t &lt;&lt; 4 | t &gt;&gt;&gt; 28) + r &lt;&lt; 0, s += (i ^ t) + h[12] - 421815835, s = (s &lt;&lt; 11 | s &gt;&gt;&gt; 21) + t &lt;&lt; 0, o = s ^ t, e += (o ^ r) + h[15] + 530742520, e = (e &lt;&lt; 16 | e &gt;&gt;&gt; 16) + s &lt;&lt; 0, r += (o ^ e) + h[2] - 995338651, r = (r &lt;&lt; 23 | r &gt;&gt;&gt; 9) + e &lt;&lt; 0, t += (e ^ (r | ~s)) + h[0] - 198630844, t = (t &lt;&lt; 6 | t &gt;&gt;&gt; 26) + r &lt;&lt; 0, s += (r ^ (t | ~e)) + h[7] + 1126891415, s = (s &lt;&lt; 10 | s &gt;&gt;&gt; 22) + t &lt;&lt; 0,e += (t ^ (s | ~r)) + h[14] - 1416354905,e = (e &lt;&lt; 15 | e &gt;&gt;&gt; 17) + s &lt;&lt; 0,r += (s ^ (e | ~t)) + h[5] - 57434055,r = (r &lt;&lt; 21 | r &gt;&gt;&gt; 11) + e &lt;&lt; 0,t += (e ^ (r | ~s)) + h[12] + 1700485571,t = (t &lt;&lt; 6 | t &gt;&gt;&gt; 26) + r &lt;&lt; 0,s += (r ^ (t | ~e)) + h[3] - 1894986606,s = (s &lt;&lt; 10 | s &gt;&gt;&gt; 22) + t &lt;&lt; 0,e += (t ^ (s | ~r)) + h[10] - 1051523,e = (e &lt;&lt; 15 | e &gt;&gt;&gt; 17) + s &lt;&lt; 0,r += (s ^ (e | ~t)) + h[1] - 2054922799,r = (r &lt;&lt; 21 | r &gt;&gt;&gt; 11) + e &lt;&lt; 0,t += (e ^ (r | ~s)) + h[8] + 1873313359,t = (t &lt;&lt; 6 | t &gt;&gt;&gt; 26) + r &lt;&lt; 0,s += (r ^ (t | ~e)) + h[15] - 30611744,s = (s &lt;&lt; 10 | s &gt;&gt;&gt; 22) + t &lt;&lt; 0,e += (t ^ (s | ~r)) + h[6] - 1560198380,e = (e &lt;&lt; 15 | e &gt;&gt;&gt; 17) + s &lt;&lt; 0,r += (s ^ (e | ~t)) + h[13] + 1309151649,r = (r &lt;&lt; 21 | r &gt;&gt;&gt; 11) + e &lt;&lt; 0,t += (e ^ (r | ~s)) + h[4] - 145523070,t = (t &lt;&lt; 6 | t &gt;&gt;&gt; 26) + r &lt;&lt; 0,s += (r ^ (t | ~e)) + h[11] - 1120210379,s = (s &lt;&lt; 10 | s &gt;&gt;&gt; 22) + t &lt;&lt; 0,e += (t ^ (s | ~r)) + h[2] + 718787259,e = (e &lt;&lt; 15 | e &gt;&gt;&gt; 17) + s &lt;&lt; 0,r += (s ^ (e | ~t)) + h[9] - 343485551,r = (r &lt;&lt; 21 | r &gt;&gt;&gt; 11) + e &lt;&lt; 0,this.first ? (this.h0 = t + 1732584193 &lt;&lt; 0, this.h1 = r - 271733879 &lt;&lt; 0, this.h2 = e - 1732584194 &lt;&lt; 0, this.h3 = s + 271733878 &lt;&lt; 0, this.first = !1) : (this.h0 = this.h0 + t &lt;&lt; 0, this.h1 = this.h1 + r &lt;&lt; 0, this.h2 = this.h2 + e &lt;&lt; 0, this.h3 = this.h3 + s &lt;&lt; 0) &#125;, Md5.prototype.hex = function () &#123; this.finalize(); var t = this.h0, r = this.h1, e = this.h2, s = this.h3; return HEX_CHARS[t &gt;&gt; 4 &amp; 15] + HEX_CHARS[15 &amp; t] + HEX_CHARS[t &gt;&gt; 12 &amp; 15] + HEX_CHARS[t &gt;&gt; 8 &amp; 15] + HEX_CHARS[t &gt;&gt; 20 &amp; 15] + HEX_CHARS[t &gt;&gt; 16 &amp; 15] + HEX_CHARS[t &gt;&gt; 28 &amp; 15] + HEX_CHARS[t &gt;&gt; 24 &amp; 15] + HEX_CHARS[r &gt;&gt; 4 &amp; 15] + HEX_CHARS[15 &amp; r] + HEX_CHARS[r &gt;&gt; 12 &amp; 15] + HEX_CHARS[r &gt;&gt; 8 &amp; 15] + HEX_CHARS[r &gt;&gt; 20 &amp; 15] + HEX_CHARS[r &gt;&gt; 16 &amp; 15] + HEX_CHARS[r &gt;&gt; 28 &amp; 15] + HEX_CHARS[r &gt;&gt; 24 &amp; 15] + HEX_CHARS[e &gt;&gt; 4 &amp; 15] + HEX_CHARS[15 &amp; e] + HEX_CHARS[e &gt;&gt; 12 &amp; 15] + HEX_CHARS[e &gt;&gt; 8 &amp; 15] + HEX_CHARS[e &gt;&gt; 20 &amp; 15] + HEX_CHARS[e &gt;&gt; 16 &amp; 15] + HEX_CHARS[e &gt;&gt; 28 &amp; 15] + HEX_CHARS[e &gt;&gt; 24 &amp; 15] + HEX_CHARS[s &gt;&gt; 4 &amp; 15] + HEX_CHARS[15 &amp; s] + HEX_CHARS[s &gt;&gt; 12 &amp; 15] + HEX_CHARS[s &gt;&gt; 8 &amp; 15] + HEX_CHARS[s &gt;&gt; 20 &amp; 15] + HEX_CHARS[s &gt;&gt; 16 &amp; 15] + HEX_CHARS[s &gt;&gt; 28 &amp; 15] + HEX_CHARS[s &gt;&gt; 24 &amp; 15] &#125;, Md5.prototype.toString = Md5.prototype.hex, Md5.prototype.digest = function () &#123; this.finalize(); var t = this.h0, r = this.h1, e = this.h2, s = this.h3; return [255 &amp; t, t &gt;&gt; 8 &amp; 255, t &gt;&gt; 16 &amp; 255, t &gt;&gt; 24 &amp; 255, 255 &amp; r, r &gt;&gt; 8 &amp; 255, r &gt;&gt; 16 &amp; 255, r &gt;&gt; 24 &amp; 255, 255 &amp; e, e &gt;&gt; 8 &amp; 255, e &gt;&gt; 16 &amp; 255, e &gt;&gt; 24 &amp; 255, 255 &amp; s, s &gt;&gt; 8 &amp; 255, s &gt;&gt; 16 &amp; 255, s &gt;&gt; 24 &amp; 255] &#125;, Md5.prototype.array = Md5.prototype.digest, Md5.prototype.arrayBuffer = function () &#123; this.finalize(); var t = new ArrayBuffer(16), r = new Uint32Array(t); return r[0] = this.h0, r[1] = this.h1, r[2] = this.h2, r[3] = this.h3, t &#125;, Md5.prototype.buffer = Md5.prototype.arrayBuffer, Md5.prototype.base64 = function () &#123; for (var t, r, e, s = "", i = this.array(), o = 0; 15 &gt; o;) t = i[o++], r = i[o++], e = i[o++], s += BASE64_ENCODE_CHAR[t &gt;&gt;&gt; 2] + BASE64_ENCODE_CHAR[63 &amp; (t &lt;&lt; 4 | r &gt;&gt;&gt; 4)] + BASE64_ENCODE_CHAR[63 &amp; (r &lt;&lt; 2 | e &gt;&gt;&gt; 6)] + BASE64_ENCODE_CHAR[63 &amp; e]; return t = i[o], s += BASE64_ENCODE_CHAR[t &gt;&gt;&gt; 2] + BASE64_ENCODE_CHAR[t &lt;&lt; 4 &amp; 63] + "==" &#125;; var exports = createMethod(); COMMON_JS ? module.exports = exports : (root.md5 = exports, AMD &amp;&amp; define(function () &#123; return exports &#125;))&#125;(); 5 MD5 Utils加密12345678910111213141516171819//将查询出来的数据变成miaoshaUser MiaoshaUser miaoshaUser = getById(Long.parseLong(form_mobile)); if (miaoshaUser == null) &#123; throw new GlobalException(CodeMsg.MOBILE_NOT_EXIST); &#125; //如果用户存在 //1 验证密码 //数据库里面的密码 dbPassword b7797cce01b4b131b433b6acf4add 449 String dbPassword = miaoshaUser.getPassword();//Md5Utils.inputPassToDbPass()=dbPass //数据库里面的盐值 String dbSalt = miaoshaUser.getSalt(); //经过计算得到的密码 原密码 123456 calcpass= d3b1294a61a07da9b49b6e22b2cbd7 f9 String calcPass = MD5Util.fromPassToDBPass(form_Password, dbSalt); //==inputPassToDbPass=calcPass if (!calcPass.equals(dbPassword)) &#123; throw new GlobalException(CodeMsg.PASSWORED_ERROR); &#125; return true; 123456789101112131415//验证密码//数据库里面的密码 bPasswordString dbPassword = miaoshaUser.getPassword();//数据库里面的盐值String dbSalt = miaoshaUser.getSalt();String calcPass = MD5Util.fromPassToDBPass(form_Password, dbSalt);//d3b1294a61a07da9b49b6e22b2cbd7f9System.err.println("============");System.err.println(form_mobile + "form_mobile ajax md5加密的密码");System.err.println(dbPassword + "dbPassword数据库里面的密码");System.err.println(calcPass + "calcPass经过计算的密码 fromPassToDBPass(form_Password, dbSalt)");System.err.println("inputPassToFormPass=" + "d3b1294a61a07da9b49b6e22b2cbd7f9");System.err.println("fromPassToDBPass=" + "d3b1294a61a07da9b49b6e22b2cbd7f9");System.err.println("inputPassToDbPass=" + "b7797cce01b4b131b433b6acf4add449");System.err.println("============"); inputPassToFormPass(String input). Md5Utils===md5(str). Ajax inputPassToDbPass(String input ,String saltDb) =====Md5Utils.fomPassDBPass(form_password),dbSalt); 两次MD5封装 其本质是一样的。 6 JSR 303 校验1dependency12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2 .@Valid1234567@RequestMapping("/do_login")@ResponseBodypublic Result doLogin(@Valid LoginVo loginVo) &#123; logger.info(loginVo.toString()); miaoShaoUserService.login(loginVo); return Result.success(true);&#125; 3 POJO12345678public class LoginVo &#123; @NotNull //自定义validator @IsMobile private String mobile; @NotNull @Length(min = 32) 4 自定义的 @IsMobile 123456789101112131415161718192021package com.imooc.miaosha.validate;import javax.validation.Constraint;import javax.validation.Payload;import java.lang.annotation.Documented;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.*;import static java.lang.annotation.ElementType.TYPE_USE;import static java.lang.annotation.RetentionPolicy.RUNTIME;@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)@Retention(RUNTIME)@Documented@Constraint(validatedBy = &#123;IsMobileValidator.class&#125;)public @interface IsMobile &#123; boolean required() default true; String message() default "手机号不正确~~ -,- ~~~~"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 123456789101112131415161718192021222324252627package com.imooc.miaosha.validate;import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;import java.util.regex.Pattern;//手机号码的validator校验public class IsMobileValidator implements ConstraintValidator&lt;IsMobile, String&gt; &#123; private boolean required; // 重写initialize方法获取注解实例 @Override public void initialize(IsMobile ca) &#123; // 重注解实例中获信息 required = ca.required(); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; // value就是要校验的数据了 if (value != null &amp;&amp; required) &#123; // 手机号校验规则 System.out.println(value); String regexp = "^(((\\+\\d&#123;2&#125;-)?0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)|((\\+\\d&#123;2&#125;-)?(\\d&#123;2,3&#125;-)?([1][3,4,5,7,8][0-9]\\d&#123;8&#125;)))$"; boolean matches = Pattern.matches(regexp, value); System.out.println(matches); return matches; &#125; return false; &#125;&#125; 7统一异常处理 1234567891011121314151617181920212223242526272829303132333435package com.imooc.miaosha.Exception;import com.imooc.miaosha.result.CodeMsg;import com.imooc.miaosha.result.Result;import org.springframework.validation.BindException;import org.springframework.validation.ObjectError;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import java.util.List;//定义全局异常处理器 Advice@ControllerAdvice@ResponseBody//返回JSON数据public class GlobleExceptionHandler &#123; @ExceptionHandler(value = Exception.class) public Result&lt;String&gt; exceptionHandler(HttpServletRequest httpServletRequest, Exception e) &#123; if (e instanceof BindException) &#123; BindException ex = (BindException) e; List&lt;ObjectError&gt; allErrors = ex.getAllErrors(); ObjectError objectError = allErrors.get(0); String defaultMessage = objectError.getDefaultMessage(); return Result.error(CodeMsg.BINDD_ERROR.fillArgs(defaultMessage)); &#125; else &#123; return Result.error(CodeMsg.SERVER_ERROR); &#125; &#125;&#125; 1234567891011public class CodeMsg &#123;private int code; private String msg; //通用异常 public static CodeMsg BINDD_ERROR = new CodeMsg(50008, "参数绑定异常 :%s"); //⭐️ 不懂 不理解 查文档 public CodeMsg fillArgs(Object... args) &#123; int code = this.code; String message = String.format(this.msg, args); return new CodeMsg(code, message); &#125; 思考🤔 参数绑定异常：手机号码不正确– –，— 哪来的 Ajax data的理解。 五角星⭐️123456789101112131415161718192021$.ajax(&#123; url: "/login/do_login", type: "POST", data: &#123; mobile: $("#mobile").val(), password: password &#125;, success: function (data) &#123; layer.closeAll(); if (data.code === 0) &#123; layer.msg("成功 加油Boy"); &#125; else &#123; layer.msg(data.msg); layer.msg(data.data); &#125; console.log(data); &#125;, error: function () &#123; layer.closeAll(); &#125;&#125;); 这里面传入的 data.code data.msg data.data 应该就是注解@ResponseBody返回的JSON数就是Conlse下Object的值 或者是全局异常 和统一异常返回响应的结果。 Return 语句返回的值data.data的值不存在。 会报错。 layer.js:2 Uncaught TypeError: Cannot read property ‘parents’ of null 123456789101112131415161718192021222324ControllerAdvice用法解析简介 通过@ControllerAdvice注解可以将对于控制器的全局配置放在同一个位置。 注解了@Controller的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上。 @ControllerAdvice注解将作用在所有注解了@RequestMapping的控制器的方法上 @ExceptionHandler：用于全局处理控制器里的异常。用法@ControllerAdvice@ResponseBodypublic class BusinessExceptionHandler &#123; @ExceptionHandler(value = Exception.class) public JsonBackData exceptionHandler(HttpServletRequest request, Exception e) &#123; e.printStackTrace(); JsonBackData back = new JsonBackData(); if (e instanceof BusinessException) &#123; BusinessException ex = (BusinessException) e; back.setSuccess(false); back.setBackMsg(ex.getMessage()); &#125; return back; &#125; 8.全局异常处理1234public boolean login(LoginVo loginVo) &#123; if (loginVo == null) &#123; throw new GlobalException(CodeMsg.SERVER_ERROR); &#125; 123456789101112131415package com.imooc.miaosha.Exception;import com.imooc.miaosha.result.CodeMsg;public class GlobalException extends RuntimeException &#123; private CodeMsg cm; public GlobalException(CodeMsg cm) &#123; super(cm.toString()); this.cm = cm; &#125; public CodeMsg getCm() &#123; return cm; &#125; public void setCm(CodeMsg cm) &#123; this.cm = cm; &#125;&#125; 1234567891011@ControllerAdvice@ResponseBodypublic class GlobleExceptionHandler &#123; @ExceptionHandler(value = Exception.class) public Result&lt;String&gt; exceptionHandler(HttpServletRequest httpServletRequest, Exception e) &#123; if (e instanceof GlobalException) &#123; GlobalException ex = (GlobalException) e; return Result.error(ex.getCm()); &#125; &#125; &#125;]]></content>
      <tags>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目开发常见问题总结]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. @ResponseBody 在你的controller层对应的方法返回html路径及名称时，在前面多加了一个/ 。 例如return “/index”，正式这个/导致报错的，解决：去掉返回前面的/即可，例如return “/index” 。 在使用springboot的过程中，如果使用thymeleaf作为模板文件，则要求HTML格式必须为严格的html5格式，必须有结束标签，否则会报错。 解决办法如下： 在application.yml中添加以下配置 spring.thymeleaf.content-type: text/htmlspring.thymeleaf.cache: falsespring.thymeleaf.mode: LEGACYHTML5 再在pom.xml 添加以下依赖 12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt; &lt;/dependency&gt; 资源文件的路径被修改，如果你其他的请求都正常返回则可忽略这条。 解决：在pom.xml文件的中加入 123&lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt;&lt;/resource&gt; 添加@ResponseBody注解 然后返回JSON格式。后端是无法查看的 要通过前端Google检查元素查看？ 前后端分离2 Redis 远程服务器 liux 腾讯云 https://www.cnblogs.com/KKSJS/p/9622815.html 阿里云部署Redis服务器远程连接问题昨天在阿里云免费领了一个月的云服务器，就着最近学的SpringBoot，准备做一个SpringBoot与Redis的整合。 因为以前用的Redis都是安装在本地的，使用过程中没遇到什么大问题，可是一旦部署到真实的云服务器上就出现了一大堆问题，且听我慢慢道来。 在安装Redis前，云服务器实例是完全纯净的。首先执行下面的命令下载并安装redis： 12345678//下载wget http://download.redis.io/releases/redis-4.0.9.tar.gz//解压tar xzf redis-4.0.9.tar.gz//进入解压后的目录cd redis-4.0.9//安装到当前目录make 如果make失败，一般是系统中还未安装gcc造成的，因为Redis是用C语言写成的，所以需要先通过yum install gcc安装C语言环境。 安装Redis后，先别慌着启动，因为Redis对远程连接要求比较苛刻，具体到以下几点： Redis服务默认只让本机访问，因为现在Redis是在人家阿里云的服务器上，所以需要修改成让外网也能访问。主要是修改Redis的默认配置文件reidis.conf。 注释掉bind 127.0.0.1这一行，这样可以使所有的ip访问redis 修改 protected-mode，值改为no，生产环境下要改为yes 为了Redis的安全，需要把#requirepass foobared去掉注释，foobared改为自己的密码，例如可以改为requirepass 123456 经过以上几步后，理论上就可以通过外网访问到云服务器上的Redis了。如果现在去启动Redis的服务端，会发现Redis只能是前台启动，在这里可以通过修改redis.conf里的daemonize为yes让redis开启后台启动。 因为redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。 在修改完配置文件后，我们进入redis-4.0.9的scr目录，执行以下命令启动Redis的服务端： 1./redis-server ../redis.conf 这样Redis就在云服务器上以后台的方式启动了，接下来我在本地快速搭建了一个SpringBoot整合Redis的案例。在application.properties添加如下内容： 1234#设置redis主机ipspring.redis.host= #你的云服务器IP地址#连接redis服务的密码spring.redis.password= #刚刚在redis.conf中设置的密码 添加controller如下： 1234567891011@RestControllerpublic class TestRedis &#123; @Autowired private StringRedisTemplate strTplRedis; @GetMapping(&quot;/testredis&quot;) public String testRedis()&#123; strTplRedis.opsForValue().set(&quot;testkey&quot;, &quot;testvalue&quot;); strTplRedis.opsForValue().get(&quot;testkey&quot;); return &quot;success&quot;; &#125;&#125; 此时我们启动项目后，访问localhost:8080/testredis，出现如下错误： 这里问题就来了，显示无法连接到Redis，此时配置文件里面该改到的都已经改了，后来我又想到应该是防火墙的问题，因为redis的端口是6379，服务器默认是不开启这个端口的，所以我执行下面命令关闭了防火墙： 1sudo service iptables stop 重新访问url，发现还是报同样的错…… 于是去请教大神，经过大神的一顿排查，最后告诉我应该是我服务器的安全组规则的问题。 原来，新建的阿里云服务器实例，是默认不让外网访问的，一个实例属于一个安全组，这个安全组里一开始有阿里云为我们定义的规则，默认是不开放任何tcp端口的，具体的可以查看官方的介绍：添加安全组规则。 在修改好安全组规则后，再访问页面url，页面显示success，这下总算是将数据存进去了，使用Redis的桌面客户端也能远程连接到Redis，显示Redis里面的数据如下： 回头看来，远程连接Redis的坑基本上是被我踩完了…… 3 加入maven依赖 CodeC/MessageToByteEncoder]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis+SPringBoot Utils]]></title>
    <url>%2F2019%2F01%2F31%2F%E6%8A%80%E6%9C%AF%E6%A0%88%2FRedis%E9%9B%86%E6%88%90SpringBoot%E5%B0%81%E8%A3%85utils%2FRedisUtils%2F</url>
    <content type="text"><![CDATA[1. Redis依赖&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; 2. Redis的配置文件1234567redis.host=192.168.220.128redis.port=6379redis.timeout=3redis.password=123456redis.poolMaxTotal=10redis.poolMaxIdle=10redis.poolMaxWait=3 3. RedisConfig1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.imooc.miaosha.redis;@Component@ConfigurationProperties(prefix="redis")public class RedisConfig &#123; private String host; private int port; private int timeout;//秒 private String password; private int poolMaxTotal; private int poolMaxIdle; private int poolMaxWait;//秒 public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public int getTimeout() &#123; return timeout; &#125; public void setTimeout(int timeout) &#123; this.timeout = timeout; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getPoolMaxTotal() &#123; return poolMaxTotal; &#125; public void setPoolMaxTotal(int poolMaxTotal) &#123; this.poolMaxTotal = poolMaxTotal; &#125; public int getPoolMaxIdle() &#123; return poolMaxIdle; &#125; public void setPoolMaxIdle(int poolMaxIdle) &#123; this.poolMaxIdle = poolMaxIdle; &#125; public int getPoolMaxWait() &#123; return poolMaxWait; &#125; public void setPoolMaxWait(int poolMaxWait) &#123; this.poolMaxWait = poolMaxWait; &#125;&#125; 4. RedisPoolFactory1234567891011121314151617181920package com.imooc.miaosha.redis;@Servicepublic class RedisPoolFactory &#123; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisPoolFactory() &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(), redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp; &#125; &#125; 5.RedisService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.imooc.miaosha.redis;@Servicepublic class RedisService &#123; @Autowired JedisPool jedisPool; /** * 获取当个对象 * */ public &lt;T&gt; T get(KeyPrefix prefix, String key, Class&lt;T&gt; clazz) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; String str = jedis.get(realKey); T t = stringToBean(str, clazz); return t; &#125;finally &#123; returnToPool(jedis); &#125; &#125; /** * 设置对象 * */ public &lt;T&gt; boolean set(KeyPrefix prefix, String key, T value) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); String str = beanToString(value); if(str == null || str.length() &lt;= 0) &#123; return false; &#125; //生成真正的key String realKey = prefix.getPrefix() + key; int seconds = prefix.expireSeconds(); if(seconds &lt;= 0) &#123; jedis.set(realKey, str); &#125;else &#123; jedis.setex(realKey, seconds, str); &#125; return true; &#125;finally &#123; returnToPool(jedis); &#125; &#125; /** * 判断key是否存在 * */ public &lt;T&gt; boolean exists(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.exists(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; /** * 增加值 * */ public &lt;T&gt; Long incr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.incr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; /** * 减少值 * */ public &lt;T&gt; Long decr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.decr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; private &lt;T&gt; String beanToString(T value) &#123; if(value == null) &#123; return null; &#125; Class&lt;?&gt; clazz = value.getClass(); if(clazz == int.class || clazz == Integer.class) &#123; return &quot;&quot;+value; &#125;else if(clazz == String.class) &#123; return (String)value; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return &quot;&quot;+value; &#125;else &#123; return JSON.toJSONString(value); &#125; &#125; @SuppreWarnings(&quot;unchecked&quot;) private &lt;T&gt; T stringToBean(String str, Class&lt;T&gt; clazz) &#123; if(str == null || str.length() &lt;= 0 || clazz == null) &#123; return null; &#125; if(clazz == int.class || clazz == Integer.class) &#123; return (T)Integer.valueOf(str); &#125;else if(clazz == String.class) &#123; return (T)str; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return (T)Long.valueOf(str); &#125;else &#123; return JSON.toJavaObject(JSON.parseObject(str), clazz); &#125; &#125; private void returnToPool(Jedis jedis) &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125;&#125; 6 KeyPrefix123456789package com.imooc.miaosha.redis;public interface KeyPrefix &#123; public int expireSeconds(); public String getPrefix(); &#125; 7 BasePrefix123456789101112131415161718192021222324252627package com.imooc.miaosha.redis;public abstract class BasePrefix implements KeyPrefix&#123; private int expireSeconds; private String prefix; public BasePrefix(String prefix) &#123;//0代表永不过期 this(0, prefix); &#125; public BasePrefix( int expireSeconds, String prefix) &#123; this.expireSeconds = expireSeconds; this.prefix = prefix; &#125; public int expireSeconds() &#123;//默认0代表永不过期 return expireSeconds; &#125; public String getPrefix() &#123; String className = getClass().getSimpleName(); return className+":" + prefix; &#125;&#125; #8 UserKey 12345678910package com.imooc.miaosha.redis;public class UserKey extends BasePrefix&#123; private UserKey(String prefix) &#123; super(prefix); &#125; public static UserKey getById = new UserKey("id"); public static UserKey getByName = new UserKey("name");&#125; 9 OrderKey123456789package com.imooc.miaosha.redis;public class OrderKey extends BasePrefix &#123; public OrderKey(int expireSeconds, String prefix) &#123; super(expireSeconds, prefix); &#125;&#125; 12345678910package com.imooc.miaosha.redis;public class MiaoshaUserKey extends BasePrefix&#123; public static final int TOKEN_EXPIRE = 3600*24 * 2; private MiaoshaUserKey(int expireSeconds, String prefix) &#123; super(expireSeconds, prefix); &#125; public static MiaoshaUserKey token = new MiaoshaUserKey(TOKEN_EXPIRE, "tk");&#125;]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static关键字]]></title>
    <url>%2F2019%2F01%2F31%2Fjava%E5%9F%BA%E7%A1%80%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324public class ClassTest &#123; public static void main(String[] args) &#123; int age = ClassTest.classTest.age; System.out.println(age); String name = ClassTest.classTest.name; System.out.println(name); System.out.println(ClassTest.classTest); &#125; private String name; private int age; static ClassTest classTest = new ClassTest(&quot;yhp&quot;, 23); public ClassTest(String name) &#123; this.name = name; &#125; public ClassTest(int age) &#123; this.age = age; &#125; public ClassTest(String name, int age) &#123; this.name = name; this.age = age;]]></content>
      <tags>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统一封装返回信息]]></title>
    <url>%2F2019%2F01%2F31%2F%E6%8A%80%E6%9C%AF%E6%A0%88%2F%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E4%BF%A1%E6%81%AF%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%2F%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E4%BF%A1%E6%81%AF%7Bcode%2Cmsg%2Cdata%7D%2F</url>
    <content type="text"><![CDATA[1 Result123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.imooc.miaosha.result;public class Result&lt;T&gt; &#123; private int code; private String msg; private T data; //⭐️ private Result(CodeMsg cm) &#123; if (cm == null) &#123; return; &#125; this.code = cm.getCode(); this.msg = cm.getMsg(); &#125; private Result(T data) &#123; this.code = 0; this.msg = &quot;success&quot;; this.data = data; &#125; /** * 失败的时候调用 */ public static &lt;T&gt; Result&lt;T&gt; error(CodeMsg cm) &#123; return new Result&lt;T&gt;(cm); &#125; /** * 成功的时候调用 * * @param code */ public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123; return new Result&lt;T&gt;(data); &#125; //2 生成构造方法 public Result(int code) &#123; this.code = code; &#125; public Result(String msg) &#123; this.msg = msg; &#125; //3。get/set方法 public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 2 CodeMsg12345678910111213141516171819202122232425262728293031323334package com.imooc.miaosha.result;public class CodeMsg &#123; private int code; private String msg; //通用异常 public static CodeMsg SUCCESS = new CodeMsg(0, "success"); public static CodeMsg SERVER_NAME = new CodeMsg(50001, "服务端异常"); //登录模块 5002XX //商品模块 5003XX //订单模块 5004XX //秒杀模块 5005XX private CodeMsg(int code, String msg) &#123; this.code = code; this.msg = msg; &#125; public int getCode() &#123; return code; &#125; public String getMsg() &#123; return msg; &#125; public static CodeMsg getSUCCESS() &#123; return SUCCESS; &#125; public static CodeMsg getServerName() &#123; return SERVER_NAME; &#125;&#125; 3 调用要➕@ResponseBody注解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@RequestMapping("/resultsuccess")@ResponseBodypublic Result&lt;String&gt; resultsuccess() &#123; //⭐️⭐️⭐️⭐️⭐️ /**1.返回成功的时候调用 * public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123; * return new Result&lt;T&gt;(data); * &#125; * * private Result(T data) &#123; * this.code = 0; * this.msg = "success"; * this.data = data; * &#125; * 1.Result.success(data); * 结果： * &#123; * "code": 0, * "msg": "success", * "data": "hello immooc" * &#125; */ return Result.success("hello immooc");&#125;======================================================================@RequestMapping("/resulterror")@ResponseBodypublic Result&lt;String&gt; resultError() &#123; /** * 2。失败的时候调用 * public static &lt;T&gt; Result&lt;T&gt; error(CodeMsg cm) &#123; * return new Result&lt;T&gt;(cm); * &#125; * * private Result(CodeMsg cm) &#123; * if (cm == null) &#123; * return; * &#125; * this.code = cm.getCode(); * this.msg = cm.getMsg(); * &#125; * 2 Result.error(CodeMsg.SERVER_NAME) * public static CodeMsg SERVER_NAME = new CodeMsg(50001, "服务端异常"); * * 结果 &#123; * "code": 50001, * "msg": "服务端异常", * "data": null * &#125; * 分析： * 因为CodeMsg SUCCESS 用static修饰了 * public static CodeMsg SUCCESS = new CodeMsg(0, "success"); * 所以可以使用类.属性.属性的方式获得 * CodeMsg.SUCCESS.code=50001 * CodeMsg.SUCCESS.msg="服务端异常" */ return Result.error(CodeMsg.SERVER_NAME);&#125;]]></content>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两次MD5明文加密]]></title>
    <url>%2F2019%2F01%2F31%2F%E6%8A%80%E6%9C%AF%E6%A0%88%2FMD5%E6%98%8E%E6%96%87%E5%8A%A0%E5%AF%86%2F%E4%B8%A4%E6%AC%A1MD5%E6%98%8E%E6%96%87%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[1 .依赖12345678910111213&lt;!-- https://mvnrepository.com/artifact/commons-codec/commons-codec --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.11&lt;/version&gt;&lt;/dependency&gt;------------------------------------------------------------------------------------------&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.imooc.miaosha.utils;import org.apache.commons.codec.digest.DigestUtils;public class MD5Util &#123; /*固定盐值*/ private static final String salt = &quot;1a2b3c4d&quot;; //注意导包为codec中的DigestUtils类.codec.digest.DigestUtils; public static String md5(String src) &#123; //计算MD5摘要并以32个字符十六进制字符串的形式返回值。 return DigestUtils.md5Hex(src); &#125; /** * 第一次md5 ： * 用于 通过输入的密码生成 * 传输的密码 ： 方法 通过固定盐值和明文密码之间的拼接在生成md5 */ public static String inputPassFormPass(String inputPass) &#123; String str = &quot;&quot; + salt.charAt(0) + salt.charAt(2) + inputPass + salt.charAt(5) + salt.charAt(4); return md5(str); &#125; /** * 第二次md5 ： */ public static String fromPassFormPass(String formpasss, String salt) &#123; String str = &quot;&quot; + salt.charAt(0) + salt.charAt(2) + formpasss + salt.charAt(5) + salt.charAt(4); return md5(str); &#125; //将密码封装到数据库中 public static String inputPassToDbPass(String input, String saltDB) &#123; String s = inputPassFormPass(input); String formPass = fromPassFormPass(s, saltDB); return formPass; &#125; public static void main(String args[]) &#123; //System.out.println(s);//d3b1294a61a07da9b49b6e22b2cbd7f9 //System.out.println(inputPassToDbPass(&quot;123456&quot;, &quot;1a2b3c4d&quot;)); &#125;&#125; 调用]]></content>
      <tags>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java秒杀系统方案优化]]></title>
    <url>%2F2019%2F01%2F30%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2Fjava%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[！]]></content>
      <tags>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马乐友商城-day02-认识微服务]]></title>
    <url>%2F2019%2F01%2F30%2FSpringCloud%2F%E9%BB%91%E9%A9%AC%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E-day02-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解系统架构的演变 了解RPC与Http的区别 掌握HttpClient的简单使用 知道什么是SpringCloud 独立搭建Eureka注册中心 独立配置Robbin负载均衡 -Xms128m -Xmx128m 1.系统架构演变随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？ 其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。 1.1. 集中式架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 存在的问题： 代码耦合，开发维护困难 无法针对不同模块进行针对性优化 无法水平扩展 单点容错率低，并发能力差 1.2.垂直拆分当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分： 优点： 系统拆分实现了流量分担，解决了并发问题 可以针对不同模块进行优化 方便水平扩展，负载均衡，容错率提高 缺点： 系统间相互独立，会有很多重复开发工作，影响开发效率 1.3.分布式服务当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。 优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点： 系统间耦合度变高，调用关系错综复杂，难以维护 1.4.服务治理（SOA）当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 以前出现了什么问题？ 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态 缺点： 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想 1.5.微服务前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别： 微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图： 2.远程调用方式无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下几种： RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。 现在热门的Rest风格，就可以通过http协议来实现。 2.1.认识RPCRPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。 通过上面的概念，我们可以知道，实现RPC主要是做到两点： 实现远程调用其他计算机的服务 要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点： 1）采用何种网络通讯协议？ 现在比较流行的RPC框架，都会采用TCP作为底层传输协议 2）数据传输的格式怎样？ 两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。 像调用本地服务一样调用远程服务 如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装 RPC调用流程图： 想要了解详细的RPC实现，给大家推荐一篇文章：自己动手实现RPC 2.2.认识HttpHttp协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。 RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。 Http中还定义了资源定位的路径，RPC中并不需要 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。 例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。 2.3.如何选择？既然两种方式都可以实现远程调用，我们该如何选择呢？ 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。 难度来看，RPC实现较为复杂，http相对比较简单 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。 3.Http客户端工具既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： HttpClient OKHttp URLConnection 接下来，我们就一起了解一款比较流行的客户端工具：HttpClient 3.1.HttpClient3.1.1.介绍HttpClient是Apache公司的产品，是Http Components下的一个组件。 官网地址：http://hc.apache.org/index.html 特点： 基于标准、纯净的Java语言。实现了Http1.0和Http1.1 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE） 支持HTTPS协议。 通过Http代理建立透明的连接。 自动处理Set-Cookie中的Cookie。 3.1.2.使用我们导入课前资料提供的demo工程：《http-demo》 发起get请求： 123456@Testpublic void testGet() throws IOException &#123; HttpGet request = new HttpGet("http://www.baidu.com"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 发起Post请求： 12345678@Testpublic void testPost() throws IOException &#123; HttpPost request = new HttpPost("http://www.oschina.net/"); request.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 尝试访问昨天编写的接口：http://localhost/hello 这个接口返回一个User对象 123456@Testpublic void testGetPojo() throws IOException &#123; HttpGet request = new HttpGet("http://localhost/hello"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 我们实际得到的是一个json字符串： 123456789101112&#123; "id": 8, "userName": "liuyan", "password": "123456", "name": "柳岩", "age": 21, "sex": 2, "birthday": "1995-08-07T16:00:00.000+0000", "created": "2014-09-20T03:41:15.000+0000", "updated": "2014-09-20T03:41:15.000+0000", "note": "柳岩同学在传智播客学表演"&#125; 如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。 3.1.3.Json转换工具HttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们会使用JacksonJson工具来实现。 JacksonJson是SpringMVC内置的json处理工具，其中有一个ObjectMapper类，可以方便的实现对json的处理： 对象转json12345678910111213// json处理工具 private ObjectMapper mapper = new ObjectMapper(); @Test public void testJson() throws JsonProcessingException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化 String json = mapper.writeValueAsString(user); System.out.println("json = " + json); &#125; 结果： json转普通对象12345678910111213141516// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化 String json = mapper.writeValueAsString(user); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 User result = mapper.readValue(json, User.class); System.out.println("result = " + result);&#125; 结果： json转集合json转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。 因此Jackson做了一个类型工厂，用来解决这个问题： 12345678910111213141516171819// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, User.class)); for (User u : users) &#123; System.out.println("u = " + u); &#125;&#125; 结果： json转任意复杂类型当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。 12345678910111213141516171819// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, new TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;); for (User u : users) &#123; System.out.println("u = " + u); &#125;&#125; 结果： 3.3.Spring的RestTemplateSpring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： HttpClient OkHttp JDK原生的URLConnection（默认的） 首先在项目中注册一个RestTemplate对象，可以在启动类位置注册： 12345678910111213@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; // 默认的RestTemplate，底层是走JDK的URLConnection方式。 return new RestTemplate(); &#125;&#125; 在测试类中直接@Autowired注入： 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123; User user = this.restTemplate.getForObject("http://localhost/hello", User.class); System.out.println(user); &#125;&#125; 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。 学习完了Http客户端工具，接下来就可以正式学习微服务了。 4.初始SpringCloud微服务是一种架构方式，最终肯定需要技术架构去实施。 微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？ 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建 4.1.简介SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/ Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。 SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： netflix Eureka：注册中心 Zuul：服务网关 Ribbon：负载均衡 Feign：服务调用 Hystix：熔断器 以上只是其中一部分，架构图： 4.2.版本SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成： 我们在项目中，会是以Finchley的版本。 其中包含的组件，也都有各自的版本，如下表： Component Edgware.SR3 Finchley.RC1 Finchley.BUILD-SNAPSHOT spring-cloud-aws 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-bus 1.3.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cli 1.4.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-commons 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-contract 1.2.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-config 1.4.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-netflix 1.4.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-security 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cloudfoundry 1.1.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-consul 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-sleuth 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-stream Ditmars.SR3 Elmhurst.RELEASE Elmhurst.BUILD-SNAPSHOT spring-cloud-zookeeper 1.2.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-boot 1.5.10.RELEASE 2.0.1.RELEASE 2.0.0.BUILD-SNAPSHOT spring-cloud-task 1.2.2.RELEASE 2.0.0.RC1 2.0.0.RELEASE spring-cloud-vault 1.1.0.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-gateway 1.0.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-openfeign 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT 接下来，我们就一一学习SpringCloud中的重要组件。 5.微服务场景模拟首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构 5.1.服务提供者我们新建一个项目，对外提供查询用户的服务。 5.1.1.Spring脚手架创建工程借助于Spring提供的快速搭建工具： 填写项目信息： 添加web依赖： 添加mybatis依赖： 填写项目位置： 生成的项目结构： 依赖也已经全部自动引入： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-service-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-service-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 当然，因为要使用通用mapper，所以我们需要手动加一条依赖： 12345&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 非常快捷啊！ 5.1.2.编写代码添加一个对外查询的接口： 123456789101112@RestController@RequestMapping("user")public class UserController &#123; @Autowired private UserService userService; @GetMapping("/&#123;id&#125;") public User queryById(@PathVariable("id") Long id) &#123; return this.userService.queryById(id); &#125;&#125; Service： 12345678910@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) &#123; return this.userMapper.selectByPrimaryKey(id); &#125;&#125; mapper: 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 实体类： 1234567891011121314151617181920212223242526272829303132333435363738@Table(name = "tb_user")public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 用户名 private String userName; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; // 备注 private String note; // 。。。省略getters和setters&#125; 属性文件,这里我们采用了yaml语法，而不是properties： 123456789101112server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/mydb01 username: root password: 123 hikari: maximum-pool-size: 20 minimum-idle: 10mybatis: type-aliases-package: com.leyou.userservice.pojo 项目结构： 5.1.3.启动并测试：启动项目，访问接口：http://localhost:8081/user/7 5.2.服务调用者5.2.1.创建工程与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。 pom： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-consumer-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-consumer-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加OkHttp支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 5.2.2.编写代码首先在启动类中注册RestTemplate： 12345678910111213@SpringBootApplicationpublic class UserConsumerDemoApplication &#123; @Bean public RestTemplate restTemplate() &#123; // 这次我们使用了OkHttp客户端,只需要注入工厂即可 return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 然后编写UserDao，注意，这里不是调用mapper查数据库，而是通过RestTemplate远程查询user-service-demo中的接口： 1234567891011@Componentpublic class UserDao &#123; @Autowired private RestTemplate restTemplate; public User queryUserById(Long id)&#123; String url = "http://localhost:8081/user/" + id; return this.restTemplate.getForObject(url, User.class); &#125;&#125; 然后编写user-service，循环查询UserDAO信息： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; querUserByIds(List&lt;Long&gt; ids)&#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (Long id : ids) &#123; User user = this.userDao.queryUserById(id); users.add(user); &#125; return users; &#125;&#125; 编写controller： 123456789101112@RestController@RequestMapping("consume")public class ConsumerController &#123; @Autowired private UserService userService; @GetMapping public List&lt;User&gt; consume(@RequestParam("ids") List&lt;Long&gt; ids) &#123; return this.userService.queryUserByIds(ids); &#125;&#125; 5.2.3.启动测试：因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost:8080/consume?ids=6,7,8 一个简单的远程服务调用案例就实现了。 5.3.有没有问题？简单回顾一下，刚才我们写了什么： use-service-demo：一个提供根据id查询用户的微服务 consumer-demo：一个服务调用者，通过RestTemplate远程调用user-service-demo 流程如下： 存在什么问题？ 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护 consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效 consumer不清楚user-service的状态，服务宕机也不知道 user-service只有1台服务，不具备高可用性 即便user-service形成集群，consumer还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： 服务管理 如何自动注册和发现 如何实现状态监管 如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 服务如何实现统一配置 以上的问题，我们都将在SpringCloud中得到答案。 6.Eureka注册中心6.1.认识Eureka首先我们来解决第一问题，服务的管理。 问题分析 在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。 网约车 这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。 此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。 此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！ Eureka做什么？ Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。 同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 这就实现了服务的自动注册、发现、状态监控。 6.2.原理图 基本架构： Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址 提供者：启动后向Eureka注册自己信息（地址，提供什么服务） 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 6.3.入门案例6.3.1.编写EurekaServer接下来我们创建一个项目，启动一个EurekaServer： 依然使用spring提供的快速搭建工具： 选择依赖： 完整的Pom文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;eureka-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- SpringCloud版本，是最新的F系列 --&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Eureka服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 编写启动类： 12345678@SpringBootApplication@EnableEurekaServer // 声明这个应用是一个EurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125; 编写配置： 1234567891011server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true fetch-registry: false # 是否拉取其它服务的信息，默认是true service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka 启动服务，并访问：http://127.0.0.1:10086/eureka 6.3.2.将user-service注册到Eureka注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。 我们在user-service-demo中添加Eureka客户端依赖： 先添加SpringCloud依赖： 1234567891011121314151617181920212223&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 然后是Eureka客户端： 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类上开启Eureka客户端功能 通过添加@EnableDiscoveryClient来开启Eureka客户端功能 1234567@SpringBootApplication@EnableDiscoveryClient // 开启EurekaClient功能public class UserServiceDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceDemoApplication.class, args); &#125;&#125; 编写配置 123456789101112131415161718192021server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/mydb01 username: root password: 123 hikari: maximum-pool-size: 20 minimum-idle: 10 application: name: user-service # 应用名称mybatis: type-aliases-package: com.leyou.userservice.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称 ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 注意： 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。 不用指定register-with-eureka和fetch-registry，因为默认是true 重启项目，访问Eureka监控页面查看 我们发现user-service服务已经注册成功了 6.3.3.消费者从Eureka获取服务接下来我们修改consumer-demo，尝试从EurekaServer获取服务。 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！ 1）添加依赖： 先添加SpringCloud依赖： 1234567891011121314151617181920212223&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 然后是Eureka客户端： 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）在启动类开启Eureka客户端 1234567891011@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class UserConsumerDemoApplication &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 3）修改配置： 123456789101112server: port: 8080spring: application: name: consumer # 应用名称eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当其它服务获取地址时提供ip而不是hostname ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例： 12345678910111213141516171819202122232425262728293031@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient;// Eureka客户端，可以获取到服务实例信息 public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // String baseUrl = "http://localhost:8081/user/"; // 根据服务名称，获取服务实例 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("user-service"); // 因为只有一个UserService,因此我们直接get(0)获取 ServiceInstance instance = instances.get(0); // 获取ip和端口信息 String baseUrl = "http://"+instance.getHost() + ":" + instance.getPort()+"/user/"; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125; 5）Debug跟踪运行： 生成的URL： 访问结果： 6.4.Eureka详解接下来我们详细讲解Eureka的原理及配置。 6.4.1.基础架构Eureka架构中的三个核心角色： 服务注册中心 Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo 服务提供者 提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo 服务消费者 消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo 6.4.2.高可用的Eureka ServerEureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。 动手搭建高可用的EurekaServer 我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087 1）我们修改原来的EurekaServer配置： 123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： 删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 2）另外一台配置恰好相反： 123456789server: port: 10087 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10086/eureka 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器： 然后启动即可。 3）启动测试： 4）客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化： 1234eureka: client: service-url: # EurekaServer地址,多个地址以','隔开 defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka 6.4.3.服务提供者服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 服务注册 服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。 服务续约 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： 1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 1234eureka: instance: lease-expiration-duration-in-seconds: 10 # 10秒即过期 lease-renewal-interval-in-seconds: 5 # 5秒一次心跳 实例id 先来看一下服务状态信息： 在Eureka监控页面，查看服务注册信息： 在status一列中，显示以下信息： UP(1)：代表现在是启动了1个示例，没有集群 DESKTOP-2MVEC12:user-service:8081：是示例的名称（instance-id）， 默认格式是：${hostname} + ${spring.application.name} + ${server.port} instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。 我们可以通过instance-id属性来修改它的构成： 123eureka: instance: instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 重启服务再试试看： 6.4.4.服务消费者 获取服务列表 当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： 123eureka: client: registry-fetch-interval-seconds: 5 生产环境中，我们不需要修改这个值。 但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。 6.4.5.失效剔除和自我保护 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： 1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms） 7.负载均衡Robbin在刚才的案例中，我们启动了一个user-service，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。 但是实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？ 一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。 不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 什么是Ribbon： 接下来，我们就来使用Ribbon实现负载均衡。 7.1.启动两个服务实例首先我们启动两个user-service实例，一个8081，一个8082。 Eureka监控面板： 7.2.开启负载均衡因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码： 在RestTemplate的配置方法上添加@LoadBalanced注解： 12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory());&#125; 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： 1234567891011121314151617181920212223242526@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // 地址直接写服务名称即可 String baseUrl = "http://user-service/user/"; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125; 访问页面，查看结果： 完美！ 7.3.源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor 我们进行源码跟踪： 继续跟入execute方法：发现获取了8082端口的服务 再跟下一次，发现获取的是8081： 7.4.负载均衡策略Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下： 编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的： 现在这个就是负载均衡获取实例的方法。 我们对注入这个类的对象，然后对其测试： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = UserConsumerDemoApplication.class)public class LoadBalanceTest &#123; @Autowired RibbonLoadBalancerClient client; @Test public void test()&#123; for (int i = 0; i &lt; 100; i++) &#123; ServiceInstance instance = this.client.choose("user-service"); System.out.println(instance.getHost() + ":" + instance.getPort()); &#125; &#125;&#125; 结果： 符合了我们的预期推测，确实是轮询方式。 我们是否可以修改负载均衡的策略呢？ 继续跟踪源码，发现这么一段代码： 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： SpringBoot也帮我们提供了修改负载均衡规则的配置入口： 123user-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 再次测试，发现结果变成了随机： 7.5.重试机制Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。 我们现在关闭一个user-service实例： 因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示： 但是此时，8081服务其实是正常的。 因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。 只需要简单配置即可实现Ribbon的重试： 123456789101112spring: cloud: loadbalancer: retry: enabled: true # 开启Spring Cloud的重试功能user-service: ribbon: ConnectTimeout: 250 # Ribbon的连接超时时间 ReadTimeout: 1000 # Ribbon的数据读取超时时间 OkToRetryOnAllOperations: true # 是否对所有操作都进行重试 MaxAutoRetriesNextServer: 1 # 切换实例的重试次数 MaxAutoRetries: 1 # 对当前实例的重试次数 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt; 我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枚举]]></title>
    <url>%2F2019%2F01%2F29%2Fjava%E5%9F%BA%E7%A1%80%2F%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[1.枚举用法一：常量在JDK1.5 之前，我们定义常量都是： public static final…. 。现在好了，有了枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。 Java代码 123public enum Color &#123; RED, GREEN, BLANK, YELLOW &#125; 用法三：向枚举中添加新方法如果打算自定义自己的方法，那么必须在enum实例序列的最后添加一个分号。而且 Java 要求必须先定义 enum 实例。 Java代码 123456789101112131415161718192021222324252627282930313233public enum Color &#123; RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; // 普通方法 public static String getName(int index) &#123; for (Color c : Color.values()) &#123; if (c.getIndex() == index) &#123; return c.name; &#125; &#125; return null; &#125; // get set 方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125; &#125; https://blog.csdn.net/qq_27093465/article/details/52180865 https://www.cnblogs.com/sister/p/4700702.html 1.values()获取存储枚举中所有常量实例的数组。常配合foreach完成遍历 123for(ColorEnum temp:ColorEnum.values())&#123; System.out.println(temp);&#125; 运行结果： 123 RED GREEN BLUE 2.构造方法，枚举的构造方法只能用private修饰符修饰，原因就不需要解释了…… 3.valueOf()通过常量名获取对应的枚举实例。 12 ColorEnum red = ColorEnum.valueOf(&quot;RED&quot;); System.out.println(red); 123456789101112131415161718192021222324252627//枚举类的后缀建议为Enum，枚举类型的实例对象建议全大写（这样做符合JAVA的规范//当我们创建SeasonEnum这个枚举类时，// 可不可以让SeasonEnum中的每一个实例对象都有一个getChinese()方法呢。\// 答案是肯定的，而且这种做法在企业开发中很常见。public enum SeasonEnum &#123; SPRING("春天"), SUMMER("夏天"), AUTUMN("秋天"), WINTER("冬天");// 这样乍一看是不是有点像我们平时创建一般实体类一样。// 其实枚举类型可以看做我们平时新建.class差不多，// 只是枚举类限制了此类的实例对象// 当然，枚举类可以有自己的成员变量和方法。// 上面的SeasonEnum 枚举类有了chinese这个成员变量，// 所以我们在定义实例对象时就要维护这个chinese成员变量。// 现在再来看看，我们是怎么使用这个枚举类简化我们的代码 private String chinese; SeasonEnum(String chinese) &#123; this.chinese = chinese; &#125; public String getChinese() &#123; return chinese; &#125;&#125; 123456789public class Test &#123; public static void main(String[] args) &#123; SeasonEnum spring = SeasonEnum.SPRING; System.out.println(spring.getChinese()); &#125;&#125; https://blog.csdn.net/cauchy6317/article/details/82313088 1234567891011121314151617181920212223242526272829303132333435363738394041424344public enum Weekday &#123; SUN(0),MON(1),TUS(2),WED(3),THU(4),FRI(5),SAT(6); private int value; private Weekday(int value)&#123; this.value = value; &#125; public static Weekday getNextDay(Weekday nowDay)&#123; int nextDayValue = nowDay.value; if (++nextDayValue == 7)&#123; nextDayValue =0; &#125; return getWeekdayByValue(nextDayValue); &#125;//重要的代码段 public static Weekday getWeekdayByValue(int value) &#123; for (Weekday c : Weekday.values()) &#123; if (c.value == value) &#123; return c; &#125; &#125; return null; &#125;&#125;class Test2&#123; public static void main(String[] args) &#123; System.out.println("nowday ====&gt; " + Weekday.SAT); System.out.println("nowday int ====&gt; " + Weekday.SAT.ordinal()); System.out.println("nextday ====&gt; " + Weekday.getNextDay(Weekday.SAT)); // 输出 SUN //输出： //nowday ====&gt; SAT //nowday int ====&gt; 6 //nextday ====&gt; SUN &#125;&#125; 这样就完成了我们的目标，和之前的代码比起来，有没有觉得突然高大上了许多？没有那么多烦人的ifelse，世界都清净了。好了，现在你大概知道为什么要引入枚举类了吧？就是因为在没有枚举类的时候，我们要定义一个有限的序列，比如星期几，男人女人，春夏秋冬，一般会通过上面那种静态变量的形式，但是使用那样的形式如果需要一些其他的功能，需要些很多奇奇怪怪的代码。所以，枚举类的出现，就是为了简化这种操作 Weekday可以调用的方法和参数。发现它有两个方法：value()和valueOf()。还有我们刚刚定义的七个变量。这些事枚举变量的方法。我们接下来会演示几个比较重要的： public enum Weekday { SUN,MON,TUS,WED,THU,FRI,SAT} class Test3{ public static void main(String[] args) { System.out.println(Weekday.valueOf(“mon”.toUpperCase())); //MON for (Weekday w : Weekday.values()){ System.out.println(w + &quot;.ordinal() ====&gt;&quot; +w.ordinal()); } //SUN.ordinal() ====&gt;0 //MON.ordinal() ====&gt;1 //TUS.ordinal() ====&gt;2 //WED.ordinal() ====&gt;3 //THU.ordinal() ====&gt;4 //FRI.ordinal() ====&gt;5 //SAT.ordinal() ====&gt;6 System.out.println(&quot;Weekday.MON.compareTo(Weekday.FRI) ===&gt; &quot; + Weekday.MON.compareTo(Weekday.FRI)); System.out.println(&quot;Weekday.MON.compareTo(Weekday.MON) ===&gt; &quot; + Weekday.MON.compareTo(Weekday.MON)); System.out.println(&quot;Weekday.MON.compareTo(Weekday.SUM) ===&gt; &quot; + Weekday.MON.compareTo(Weekday.SUN)); //Weekday.MON.compareTo(Weekday.FRI) ===&gt; -4 //Weekday.MON.compareTo(Weekday.MON) ===&gt; 0 //Weekday.MON.compareTo(Weekday.SUM) ===&gt; 1 System.out.println(&quot;Weekday.MON.name() ====&gt; &quot; + Weekday.MON.name()); //Weekday.MON.name() ====&gt; MON } Weekday.valueOf() 方法： 它的作用是传来一个字符串，然后将它转变为对应的枚举变量。前提是你传的字符串和定义枚举变量的字符串一抹一样，区分大小写。如果你传了一个不存在的字符串，那么会抛出异常。 Weekday.values()方法。 这个方法会返回包括所有枚举变量的数组。在该例中，返回的就是包含了七个星期的Weekday[]。可以方便的用来做循环。 枚举变量的toString()方法。 该方法直接返回枚举定义枚举变量的字符串，比如MON就返回【”MON”】。 好了，你很聪明，你已经掌握了上面的知识，你想，既然能自定义一个变量，能不能自定义两个呢？ 当然可以： public enum Weekday { MON(1,”mon”),TUS(2,”tus”),WED(3,”wed”),THU(4,”thu”),FRI(5,”fri”),SAT(6,”sat”),SUN(0,”sun”); private int value; private String label; private Weekday(int value,String label){ this.value = value; this.label = label; } 你可以定义任何你想要的变量。学完了这些，大概枚举类你也应该掌握了，但是，还有没有其他用法呢? 1234567891011121314151617181920212223242526272829303132333435363738394041 1. **package** com.think.enumeration; 2. 3. **public** **enum** Season &#123; 4. ​ //Java要求必须先定义枚举实例， 5. ​ SPRING(10,20), 6. ​ SUMMER(20,32), 7. ​ FULL(10,20), 8. ​ //这就是哈尔滨的真实写照 9. ​ WINTER(-40,-5);//注意这个分号，比不可少 10. ​ 11. ​ **private** **double** lowTemp; 12. ​ **private** **double** highTemp; 13. ​ //一旦enum定义结束，编译器就不允许我们再使用 14. ​ //其构造器来创建任何实例了，所以即使不是private也没关系 15. ​ **private** Season(**double** low,**double** high) &#123; 16. ​ lowTemp = low; 17. ​ highTemp = high; 18. ​ &#125; 19. ​ 20. ​ //自定义的方法，就像在普通的类中一样 21. ​ **public** **void** setLow(**double** low) &#123; 22. ​ **this**.lowTemp = low; 23. ​ &#125; 24. ​ 25. ​ //还可以覆盖父类中的方法 26. ​ @Override 27. ​ **public** String toString() &#123; 28. ​ **return** "(" + lowTemp + "," + highTemp + ")"; 29. ​ &#125; 30. ​ 31. ​ //甚至还可以有main方法 32. ​ **public** **static** **void** main(String[] args) &#123; 33. ​ **for**(Season e : Season.values()) &#123; 34. ​ **if**(e == SPRING) 35. ​ e.setLow(-10); 36. ​ System.out.println(e); 37. ​ &#125; 38. ​ &#125; 39. &#125; 我们一定要抓住enum的本质： 它是一组常量的集合 。所以很多限制都是为了确保“常量性”，比如在定义枚举类时，必须先定义enum，它的构造方法在定义enum实例结束后就不能使用。出了围绕常量性的限制之外，其他的语法与普通类无异，我们可以添加普通方法，可以覆盖父类方法等。在所有的特性中，最具特色的要数在enum中除了给enum类型添加方法之外，每个实例还可以有自己的方法，这样的方法叫做常量相关方法：对于同一个方法，不同的实例可以实现自己的行为。这样甚至有了多态性。实现常量相关的方法时，可以将一个方法实现成抽象方法，每个实例提供具体实现；也可以把方法实现成普通方法，每个实例根据需求，选择是否覆盖该方法，示例如下：]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F01%2F26%2F%E9%9D%A2%E8%AF%95%2FHTTP%2F</url>
    <content type="text"><![CDATA[1.HTTP 2 .网络协议分层 #3 HTTP 三次握手 4 URI URL URN 包括URL 和URN ftp协议 5 HTTP 报文 6Http客户端 CURL]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网Java校招面试 Google面试官亲授]]></title>
    <url>%2F2019%2F01%2F26%2F%E9%9D%A2%E8%AF%95%2F%E9%9D%A2%E8%AF%95Google%2F</url>
    <content type="text"><![CDATA[第一章 网络]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合]]></title>
    <url>%2F2019%2F01%2F24%2FSSM%20%2FSSM%E6%95%B4%E5%90%882%2F</url>
    <content type="text"><![CDATA[SSM整合1 Spring - dao123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置整合mybatis过程 --&gt; &lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name="maxPoolSize" value="30"/&gt; &lt;property name="minPoolSize" value="10"/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name="autoCommitOnClose" value="false"/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name="checkoutTimeout" value="10000"/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name="acquireRetryAttempts" value="2"/&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"/&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="o2o.entity"/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="o2o.dao"/&gt; &lt;/bean&gt;&lt;/beans&gt; 2 Spring -service123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="o2o.service" /&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;/beans&gt; 3 Spring-web123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解模式 --&gt; &lt;!-- 简化配置： (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用"/"做整体映射 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package="o2o.web" /&gt;&lt;!--controller层 web--&gt;&lt;/beans&gt; 4 myhbatis-config1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;!-- 使用列标签替换别名 默认:true --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;/settings&gt;&lt;/configuration&gt; 5 web.xml123456789101112131415161718192021222324&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1" metadata-complete="true"&gt; &lt;!-- 如果是用mvn命令生成的xml，需要修改servlet版本为3.1 --&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml Mybatis - &gt; spring -&gt; springmvc --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;!-- 默认匹配所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 6 jdbc.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/o2o?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=YHP836143 7 Logback日志配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version="1.0" encoding="utf-8" standalone="no"?&gt;&lt;configuration debug="false"&gt; &lt;appender name="INFO-FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;catalina.base&#125;/webapps/myo2o/logs/info/info.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;catalina.base&#125;/webapps/myo2o/logs/info/info.%d&#123;yyyy-MM-dd&#125;.%i.log.zip&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;1024MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;55&#125; - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name="ACCESS-FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt; $&#123;catalina.base&#125;/webapps/myo2o/logs/access/access.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;FileNamePattern&gt;$&#123;catalina.base&#125;/webapps/myo2o/logs/access/access.%d&#123;yyyy-MM-dd&#125;.%i.log.zip&lt;/FileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;1024MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;55&#125; - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name="com.imooc.myo2o" level="DEBUG" additivity="false"&gt; &lt;appender-ref ref="ACCESS-FILE" /&gt; &lt;/logger&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="INFO-FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt; &lt;!--======================================================--&gt;&lt;!--&lt;?xml version="1.0" encoding="utf-8" standalone="no"?&gt;--&gt;&lt;!--&lt;configuration debug="false" scan="true" scanPeriod="50 seconds"&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;定义参数常量&amp;ndash;&amp;gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR&amp;ndash;&amp;gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;logger.info("msg") logger.debug("msg") logger.error("msg")&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name="log.level" value="debug"&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!--&lt;property name="log.maxHistory" value="30"&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!--&lt;property name="log.filePath" value="$&#123;catalina.base&#125;/logs/webapps"&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!--&lt;property name="log.pattern" value="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;55&#125; - --&gt; &lt;!--%msg%n"&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;控制台设置&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;appender name="consoleApperder" class="ch.qos.logback.core.ConsoleAppender"&gt;--&gt; &lt;!--&lt;encoder&gt;--&gt; &lt;!--&lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt;--&gt; &lt;!--&lt;/encoder&gt;--&gt; &lt;!--&lt;/appender&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;Debug&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;appender name="debugAppender" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;文件路径&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;file&gt;--&gt; &lt;!--$&#123;log.filePath&#125;/debug.log--&gt; &lt;!--&lt;/file&gt;--&gt; &lt;!--&lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;文件名称&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;fileNamePattern&gt;--&gt; &lt;!--&lt;/fileNamePattern&gt;--&gt; &lt;!--&lt;MaxHistory&gt;--&gt; &lt;!----&gt; &lt;!--&lt;/MaxHistory&gt;--&gt; &lt;!--&lt;/rollingPolicy&gt;--&gt; &lt;!--&lt;/appender&gt;--&gt;&lt;!--&lt;/configuration&gt;--&gt; 8 日志文件 9 pom 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICEccNSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;!-- $Id: pom.xml 642118 2008-03-28 08:04:16Z reinhard $ --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;o2o&lt;/name&gt; &lt;groupId&gt;com.imooc.o2o&lt;/groupId&gt; &lt;artifactId&gt;o2o&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;spring.version&gt;4.3.7.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 1.日志 --&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2.数据库 --&gt; &lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;mysql&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;5.1.37&lt;/version&gt;--&gt; &lt;!--&lt;scope&gt;runtime&lt;/scope&gt;--&gt; &lt;!--&lt;/dependency&gt;--&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.14&lt;/version&gt; &lt;/dependency&gt; &lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;c3p0&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;c3p0&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;0.9.1.2&lt;/version&gt;--&gt; &lt;!--&lt;/dependency&gt;--&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- DAO: MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3.Servlet web --&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4.Spring --&gt; &lt;!-- 1)Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2)Spring DAO层 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3)Spring web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4)Spring test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Map工具类 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;6.1.7&lt;/version&gt; &lt;configuration&gt; &lt;connectors&gt; &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt; &lt;port&gt;8888&lt;/port&gt; &lt;maxIdleTime&gt;30000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;webAppSourceDirectory&gt;$&#123;project.build.directory&#125;/$&#123;pom.artifactId&#125;-$&#123;pom.version&#125; &lt;/webAppSourceDirectory&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 10 验证DAO12345678/*配置Spring和Junit整合 Junit启动时加载SpringIOC容器 */@RunWith(SpringJUnit4ClassRunner.class)//告诉Junit Spring配置文件的位置@ContextConfiguration(&#123;"classpath:spring/spring-dao.xml"&#125;)public class BaseTest &#123;&#125; 12345678910public class TbAreaMapperTest extends BaseTest &#123; @Autowired private TbAreaMapper tbAreaMapper; @Test public void testQueryArea() &#123; List&lt;TbArea&gt; tbAreas = tbAreaMapper.queryArea(); System.err.println(tbAreas); &#125;&#125; 11 验证Service12345678910public class TbAreaServiceTest extends BaseTest &#123; @Autowired private AreaService areaService; @Test public void testGetAreaList() &#123; List&lt;TbArea&gt; areaList = areaService.getAreaList(); System.out.println(areaList); &#125;&#125; 12验证Controller123456789101112131415161718192021@Controller@RequestMapping("/superadmin")public class AreaController &#123; @Autowired private AreaService areaService; @RequestMapping(value = "/listArea", method = RequestMethod.GET) @ResponseBody private Map&lt;String, Object&gt; listArea() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); try &#123; List&lt;TbArea&gt; areaList = areaService.getAreaList(); map.put("rows", areaList); map.put("total", areaList.size()); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put("success", false); map.put("errMsg", e.toString()); &#125; return map; &#125; 注意⚠️Mysql8.0.14 将pom文件换成最高版本的 要不然会连接失败 12345&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt; 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.14&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯]]></title>
    <url>%2F2019%2F01%2F24%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%2F%E8%93%9D%E6%A1%A5%E6%9D%AF1%2F</url>
    <content type="text"><![CDATA[1 16进制转换8进制题目问题描述 给定n个十六进制正整数，输出它们对应的八进制数。 输入格式 输入的第一行为一个正整数n （1&lt;=n&lt;=10）。 接下来n行，每行一个由09、大写字母AF组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。 输出格式 输出n行，每行为输入对应的八进制正整数。 注意 输入的十六进制数不会有前导0，比如012A。 输出的八进制数也不能有前导0。 样例输入 2 39 123ABC 样例输出 71 4435274 提示 先将十六进制数转换成某进制数，再由某进制数转换成八进制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 /* * 16进制转成2进制，再转8进制 16--》2 每个位上的数字都可以转化为4个位的2进制 * 每三个为上的2进制组合转化为8进制上的每个位上的数字，不够就补0 */ public void convert16from2to8(String num16) &#123; char[] chArr = num16.toCharArray(); int tmp = 0; StringBuffer sbSum = new StringBuffer(); for (int x = 0; x &lt; chArr.length; x++) &#123; switch (chArr[x]) &#123;// 字符对应的整数 case &apos;A&apos;: case &apos;B&apos;: case &apos;C&apos;: case &apos;D&apos;: case &apos;E&apos;: case &apos;F&apos;: tmp = chArr[x] - &apos;0&apos; - 7; break; default: tmp = chArr[x] - &apos;0&apos;; break; &#125; StringBuffer sb = new StringBuffer(); // 转化为二进制 while (tmp &gt;= 2) &#123; sb.insert(0, tmp % 2); tmp /= 2; &#125; sb.insert(0, tmp); // System.out.println(sb.length()); int len = 4 - sb.length();// 假如直接写在for循环里面sb在变化，导致len会变化 for (int y = 0; y &lt; len; y++) sb.insert(0, 0); // System.out.println(sb.toString()); sbSum.append(sb); &#125; // System.out.println(sbSum.toString()); StringBuffer sbSum8=new StringBuffer();//记录最终的结果 int tmp8item=0; // 每3个一组，不够尽兴高位补0，即最左边补0，采用421， // 或者用一个3做循环，进行划分区域，有1,就根据421的方式进行相加 char[] chArr2 = sbSum.toString().toCharArray(); //1001 for (int z = chArr2.length - 1, num3 = 0; z &gt;= 0; z--) &#123; if (chArr2[z] - &apos;0&apos; == 1) &#123; switch (num3) &#123; case 0: tmp8item+=1; break; case 1: tmp8item+=2; break; case 2: tmp8item+=4; break; &#125; &#125; if((num3+1)%3==0)&#123; sbSum8.insert(0, tmp8item); tmp8item=0; &#125; num3=(num3+1)%3; &#125; if(sbSum8.substring(0, 1).equals(&quot;0&quot;))//输出的八进制数也不能有前导0的判断 System.out.println(sbSum8.substring(1,sbSum8.length())); else System.out.println(sbSum8.toString()); &#125;]]></content>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guns实战]]></title>
    <url>%2F2019%2F01%2F24%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2FGuns%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MongoDB]]></title>
    <url>%2F2019%2F01%2F18%2FMongoDB%2FMongoDB%2F</url>
    <content type="text"><![CDATA[1.安装与简介 1sudo mkdir -p /data/db 使用 brew 安装此外你还可以使用 OSX 的 brew 来安装 mongodb： 1sudo brew install mongodb 如果要安装支持 TLS/SSL 命令如下： 1sudo brew install mongodb --with-openssl 安装最新开发版本： 1sudo brew install mongodb --devel 运行 MongoDB1、首先我们创建一个数据库存储目录 /data/db： 1sudo mkdir -p /data/db 启动 mongodb，默认数据库目录即为 /data/db： 12345sudo mongod# 如果没有创建全局路径 PATH，需要进入以下目录cd /usr/local/mongodb/binsudo ./mongod 再打开一个终端进入执行以下命令： 12345678910$ cd /usr/local/mongodb/bin $ ./mongoMongoDB shell version v3.4.2connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.2Welcome to the MongoDB shell.……&gt; 1 + 12&gt; 1.启动mongodb 2 基本使用 3文档之间的关系 一对一 一对多 【重要】 4 sort 和投影 5 Mongoose Node.js 修改文档12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 修改 db.collection.update(查询条件,新对象) - update()默认情况下会使用新对象来替换旧的对象 - 如果需要修改指定的属性，而不是替换需要使用“修改操作符”来完成修改 $set 可以用来修改文档中的指定属性 $unset 可以用来删除文档的指定属性 - update()默认只会修改一个 db.collection.updateMany() - 同时修改多个符合条件的文档 db.collection.updateOne() - 修改一个符合条件的文档 db.collection.replaceOne() - 替换一个文档*/db.stus.find(&#123;&#125;);//替换db.stus.update(&#123;name:"沙和尚"&#125;,&#123;age:28&#125;);db.stus.update( &#123;"_id" : ObjectId("59c219689410bc1dbecc0709")&#125;, &#123;$set:&#123; gender:"男", address:"流沙河" &#125;&#125; )db.stus.update( &#123;"_id" : ObjectId("59c219689410bc1dbecc0709")&#125;, &#123;$unset:&#123; address:1 &#125;&#125; )db.stus.updateMany( &#123;"name" : "猪八戒"&#125;, &#123; $set:&#123; address:"猪老庄" &#125; &#125; ); db.stus.update( &#123;"name" : "猪八戒"&#125;, &#123; $set:&#123; address:"呵呵呵" &#125; &#125; , &#123; multi:true &#125; )db.stus.find() 删除文档123456789101112131415161718192021222324252627282930313233/* db.collection.remove() - 删除一个或多个，可以第二个参数传递一个true，则只会删除一个 - 如果传递一个空对象作为参数，则会删除所有的 db.collection.deleteOne() db.collection.deleteMany() db.collection.drop() 删除集合 db.dropDatabase() 删除数据库 - 一般数据库中的数据都不会删除，所以删除的方法很少调用 一般会在数据中添加一个字段，来表示数据是否被删除*/ db.stus.insert([ &#123; name:"zbj", isDel:0 &#125;, &#123; name:"shs", isDel:0 &#125;, &#123; name:"ts", isDel:0 &#125;]);db.stus.updateOne(&#123;name:"ts"&#125;,&#123;$set:&#123;isDel:1&#125;&#125;); db.stus.find(&#123;isDel:0&#125;) 插入文档1234567891011121314151617181920212223242526/* 向数据库插入文档 db.&lt;collection&gt;.insert() - 向集合中插入一个或多个文档 - 当我们向集合中插入文档时，如果没有给文档指定_id属性，则数据库会自动为文档添加_id 该属性用来作为文档的唯一标识 - _id我们可以自己指定，如果我们指定了数据库就不会在添加了，如果自己指定_id 也必须确保它的唯一性 db.collection.insertOne() - 插入一个文档对象 db.collection.insertMany() - 插入多个文档对象*/db.stus.insert(&#123;name:"猪八戒",age:28,gender:"男"&#125;);db.stus.insert([ &#123;name:"沙和尚",age:38,gender:"男"&#125;, &#123;name:"白骨精",age:16,gender:"女"&#125;, &#123;name:"蜘蛛精",age:14,gender:"女"&#125;]);db.stus.insert(&#123;_id:"hello",name:"猪八戒",age:28,gender:"男"&#125;);db.stus.find();ObjectId() 文档查询12345678910111213141516171819202122/* 查询 db.collection.find() - find()用来查询集合中所有符合条件的文档 - find()可以接收一个对象作为条件参数 &#123;&#125; 表示查询集合中所有的文档 &#123;属性:值&#125; 查询属性是指定值的文档 - find()返回的是一个数组 db.collection.findOne() - 用来查询集合中符合条件的第一个文档 - findOne()返回的是一个文档对象 db.collection.find(&#123;&#125;).count() - 查询所有结果的数量*/db.stus.find(&#123;_id:"hello"&#125;);db.stus.find(&#123;age:16 , name:"白骨精"&#125;);db.stus.find(&#123;age:28&#125;);db.stus.findOne(&#123;age:28&#125;);db.stus.find(&#123;&#125;).count(); 笔记MongoDB - MongoDB是一个NoSQL的数据库 - MongoDB是一款文档型数据库 - 数据库指的就是一个存储数据的仓库 数据库可以使我们完成对数据的持久化的操作 - MongoDB数据库中存储的数据的基本单位就是文档， MongoDB中存储的就是文档，所谓文档其实就是一个“JSON” - MongoDB中的“JSON”我们称为BSON，比普通的JSON的功能要更加的强大 - MongoDB数据库使用的是JavaScript进行操作的，在MongoDB含有一个对ES标准实现的引擎， 在MongoDB中所有ES中的语法中都可以使用 - MongoDB的基本的指令 - 启动服务器 mongod --dbpath 路径 --port 端口号 - 启动客户端 mongo - MongoDB的CRUD的操作 - 基本操作 use 数据库 - 进入指定的数据库 show dbs - 显示所有的数据库 show collections - 显示数据库中所有的集合 db - 显示当前所在的数据库 - 向数据库中插入文档 - db.collection.insert() - insert()可以向集合中插入一个或多个文档 - db.collection.insertOne() - 向集合中插入一个文档 - db.collection.insertMany() - 向集合中插入多个文档 - 查询数据库中的文档 - db.collection.find() - 可以根据指定条件从集合中查询所有符合条件的文档 - 返回的是一个数组 - db.collection.findOne() - 查询第一个符合条件的文档 - 返回的是一个对象 - db.collection.find().count() - 查询符合条件的文档的数量 - 修改数据库中的文档 - db.collection.update() - 可以修改、替换集合中的一个或多个文档 - db.collection.updateOne() - 修改集合中的一个文档 - db.collection.updateMany() - 修改集合中的多个文档 - db.collection.replaceOne() - 替换集合中的一个文档 - 删除集合中的文档 - db.collection.remove() - 删除集合中的一个或多个文档（默认删除多个） - db.collection.deleteOne() - 删除集合中的一个文档 - db.collection.deleteMany() - 删除集合中的多个文档 - 清空一个集合 db.collection.remove({}) - 删除一个集合 db.collection.drop() - 删除一个数据库 db.dropDatabase() 练习11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//1.进入my_test数据库use my_test//2.向数据库的user集合中插入一个文档 db.users.insert(&#123; username:"sunwukong"&#125;);//3.查询user集合中的文档db.users.find();//4.向数据库的user集合中插入一个文档 db.users.insert(&#123; username:"zhubajie"&#125;); //5.查询数据库user集合中的文档db.users.find();//6.统计数据库user集合中的文档数量db.users.find().count();//7.查询数据库user集合中username为sunwukong的文档db.users.find(&#123;username:"sunwukong"&#125;);//8.向数据库user集合中的username为sunwukong的文档，添加一个address属性，属性值为huaguoshandb.users.update(&#123;username:"sunwukong"&#125;,&#123;$set:&#123;address:"huaguoshan"&#125;&#125;);//9.使用&#123;username:"tangseng"&#125; 替换 username 为 zhubajie的文档db.users.replaceOne(&#123;username:"zhubajie"&#125;,&#123;username:"tangseng"&#125;); //10.删除username为sunwukong的文档的address属性db.users.update(&#123;username:"sunwukong"&#125;,&#123;$unset:&#123;address:1&#125;&#125;);//11.向username为sunwukong的文档中，添加一个hobby:&#123;cities:["beijing","shanghai","shenzhen"] , movies:["sanguo","hero"]&#125;//MongoDB的文档的属性值也可以是一个文档，当一个文档的属性值是一个文档时，我们称这个文档叫做 内嵌文档db.users.update(&#123;username:"sunwukong"&#125;,&#123;$set:&#123;hobby:&#123;cities:["beijing","shanghai","shenzhen"] , movies:["sanguo","hero"]&#125;&#125;&#125;);db.users.find();//12.向username为tangseng的文档中，添加一个hobby:&#123;movies:["A Chinese Odyssey","King of comedy"]&#125;db.users.update(&#123;username:"tangseng"&#125;,&#123;$set:&#123;hobby:&#123;movies:["A Chinese Odyssey","King of comedy"]&#125;&#125;&#125;)//13.查询喜欢电影hero的文档//MongoDB支持直接通过内嵌文档的属性进行查询，如果要查询内嵌文档则可以通过.的形式来匹配//如果要通过内嵌文档来对文档进行查询，此时属性名必须使用引号 db.users.find(&#123;'hobby.movies':"hero"&#125;);//14.向tangseng中添加一个新的电影Interstellar//$push 用于向数组中添加一个新的元素//$addToSet 向数组中添加一个新元素 ， 如果数组中已经存在了该元素，则不会添加db.users.update(&#123;username:"tangseng"&#125;,&#123;$push:&#123;"hobby.movies":"Interstellar"&#125;&#125;);db.users.update(&#123;username:"tangseng"&#125;,&#123;$addToSet:&#123;"hobby.movies":"Interstellar"&#125;&#125;);db.users.find();//15.删除喜欢beijing的用户db.users.remove(&#123;"hobby.cities":"beijing"&#125;);//16.删除user集合db.users.remove(&#123;&#125;);db.users.drop();show dbs;//17.向numbers中插入20000条数据 7.2sfor(var i=1 ; i&lt;=20000 ; i++)&#123; db.numbers.insert(&#123;num:i&#125;);&#125;db.numbers.find()db.numbers.remove(&#123;&#125;);//0.4svar arr = [];for(var i=1 ; i&lt;=20000 ; i++)&#123; arr.push(&#123;num:i&#125;);&#125;db.numbers.insert(arr); 练习21234567891011121314151617181920212223242526272829303132333435363738394041424344//18.查询numbers中num为500的文档db.numbers.find(&#123;num:500&#125;)//19.查询numbers中num大于5000的文档db.numbers.find(&#123;num:&#123;$gt:500&#125;&#125;);db.numbers.find(&#123;num:&#123;$eq:500&#125;&#125;);//20.查询numbers中num小于30的文档db.numbers.find(&#123;num:&#123;$lt:30&#125;&#125;);//21.查询numbers中num大于40小于50的文档db.numbers.find(&#123;num:&#123;$gt:40 , $lt:50&#125;&#125;);//22.查询numbers中num大于19996的文档db.numbers.find(&#123;num:&#123;$gt:19996&#125;&#125;);//23.查看numbers集合中的前10条数据db.numbers.find(&#123;num:&#123;$lte:10&#125;&#125;);//limit()设置显示数据的上限db.numbers.find().limit(10);//在开发时，我们绝对不会执行不带条件的查询db.numbers.find();//24.查看numbers集合中的第11条到20条数据/* 分页 每页显示10条 1-10 0 11-20 10 21-30 20 。。。 skip((页码-1) * 每页显示的条数).limit(每页显示的条数); skip()用于跳过指定数量的数据 MongoDB会自动调整skip和limit的位置*/db.numbers.find().skip(10).limit(10);//25.查看numbers集合中的第21条到30条数据db.numbers.find().skip(20).limit(10);db.numbers.find().limit(10).skip(10); 练习312345678910111213141516171819202122232425262728//26.将dept和emp集合导入到数据库中db.dept.find()db.emp.find()//27.查询工资小于2000的员工db.emp.find(&#123;sal:&#123;$lt:2000&#125;&#125;);//28.查询工资在1000-2000之间的员工db.emp.find(&#123;sal:&#123;$lt:2000 , $gt:1000&#125;&#125;);//29.查询工资小于1000或大于2500的员工db.emp.find(&#123;$or:[&#123;sal:&#123;$lt:1000&#125;&#125; , &#123;sal:&#123;$gt:2500&#125;&#125;]&#125;);//30.查询财务部的所有员工//(depno)var depno = db.dept.findOne(&#123;dname:"财务部"&#125;).deptno;db.emp.find(&#123;depno:depno&#125;);//31.查询销售部的所有员工var depno = db.dept.findOne(&#123;dname:"销售部"&#125;).deptno;db.emp.find(&#123;depno:depno&#125;);//32.查询所有mgr为7698的所有员工db.emp.find(&#123;mgr:7698&#125;)//33.为所有薪资低于1000的员工增加工资400元db.emp.updateMany(&#123;sal:&#123;$lte:1000&#125;&#125; , &#123;$inc:&#123;sal:400&#125;&#125;);db.emp.find() 文档间的关系123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 /* 文档之间的关系 一对一（one to one） - 夫妻 (一个丈夫 对应 一个妻子) - 在MongoDB，可以通过内嵌文档的形式来体现出一对一的关系 一对多（one to many）/多对一(many to one) - 父母 - 孩子 用户 - 订单 文章 - 评论 - 也可以通过内嵌文档来映射一对多的关系 多对多(many to many) - 分类 - 商品 老师 - 学生 */db.wifeAndHusband.insert([ &#123; name:"黄蓉", husband:&#123; name:"郭靖" &#125; &#125;,&#123; name:"潘金莲", husband:&#123; name:"武大郎" &#125; &#125;]);db.wifeAndHusband.find();//一对多 用户(users) 和 订单(orders)db.users.insert([&#123; username:"swk" &#125;,&#123; username:"zbj"&#125;]);db.order.insert(&#123; list:["牛肉","漫画"], user_id: ObjectId("59c47e35241d8d36a1d50de0") &#125;);db.users.find()db.order.find()//查找用户swk的订单var user_id = db.users.findOne(&#123;username:"zbj"&#125;)._id;db.order.find(&#123;user_id:user_id&#125;);//多对多db.teachers.insert([ &#123;name:"洪七公"&#125;, &#123;name:"黄药师"&#125;, &#123;name:"龟仙人"&#125;]);db.stus.insert([ &#123; name:"郭靖", tech_ids:[ ObjectId("59c4806d241d8d36a1d50de4"), ObjectId("59c4806d241d8d36a1d50de5") ] &#125;,&#123; name:"孙悟空", tech_ids:[ ObjectId("59c4806d241d8d36a1d50de4"), ObjectId("59c4806d241d8d36a1d50de5"), ObjectId("59c4806d241d8d36a1d50de6") ] &#125;])db.teachers.find()db.stus.find() Sort和投影1234567//查询文档时，默认情况是按照_id的值进行排列（升序）//sort()可以用来指定文档的排序的规则,sort()需要传递一个对象来指定排序规则 1表示升序 -1表示降序//limit skip sort 可以以任意的顺序进行调用db.emp.find(&#123;&#125;).sort(&#123;sal:1,empno:-1&#125;);//在查询时，可以在第二个参数的位置来设置查询结果的 投影db.emp.find(&#123;&#125;,&#123;ename:1 , _id:0 , sal:1&#125;); ​​​​​​]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实战电商项目]]></title>
    <url>%2F2019%2F01%2F18%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E6%85%95%E8%AF%BE%E7%BD%91%20Java%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[12 第一章课程介绍第二章开发环境的安装预配置讲解第三章数据库表设计 mysql 索引怎么弄 普通索引 创建索引 这是最基本的索引，它没有任何限制。它有以下几种创建方式： 1CREATE INDEX indexName ON mytable(username(length)); 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 修改表结构(添加索引) 1ALTER table tableName ADD INDEX indexName(columnName) 创建表的时候直接指定 123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 删除索引的语法 1DROP INDEX [indexName] ON mytable; 唯一索引 它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式： 创建索引 1CREATE UNIQUE INDEX indexName ON mytable(username(length)) 修改表结构 1ALTER table mytable ADD UNIQUE [indexName] (username(length)) 创建表的时候直接指定 123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); 第四章 项目初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;mmall&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;mmall Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;org.springframework.version&gt;4.0.0.RELEASE&lt;/org.springframework.version&gt; &lt;org.mybatis.version&gt;3.4.1&lt;/org.mybatis.version&gt; &lt;org.mybatis.spring.version&gt;1.3.0&lt;/org.mybatis.spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;7.0.64&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mybatis.spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;!--&lt;scope&gt;runtime&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;20.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- id加密解密 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hashids&lt;/groupId&gt; &lt;artifactId&gt;hashids&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ftpclient --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- file upload --&gt; &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis pager --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alipay --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-configuration&lt;/groupId&gt; &lt;artifactId&gt;commons-configuration&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;mmall&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- geelynote maven的核心插件之-complier插件默认只支持编译Java 1.4，因此需要加上支持高版本jre的配置，在pom.xml里面加上 增加编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;compilerArguments&gt; &lt;extdirs&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib&lt;/extdirs&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 时间戳 now () mybatis-plugin 高清小鸟大图 🐦 Spring 官网代码 宠物医院。绿房子 https://github.com/spring-projects/spring-mvc-showcase https://github.com/spring-projects/spring-petclinic https://github.com/spring-projects/greenhouse 代码配置 配置web.xml配置1.设置过滤器 解决中文乱码问题123456789101112131415161718&lt;!--设置过滤器 解决中文乱码问题--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!--拦截所有的请求 走这个filter--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2 监听器123456789101112131415&lt;!--监听器1 负责监听web容器的启动和关闭 RequestContextListener--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--监听器2 将Spring和web容器整合的监听器 ContextLoaderListener--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--通过ContextLoaderListener加载applicationContext.xml--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt;&lt;/context-param&gt; 3 spring mvc的配置12345678910111213&lt;!--SpringMVC 的配置--&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--优先级启动顺序--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!--设置过滤器 解决中文乱码问题--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!--拦截所有的请求 走这个filter--&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!--监听器1 负责监听web容器的启动和关闭 RequestContextListener--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--监听器2 将Spring和web容器整合的监听器 ContextLoaderListener--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--通过ContextLoaderListener加载applicationContext.xml--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt;&lt;/context-param&gt;&lt;!--SpringMVC 的配置--&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--优先级启动顺序--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt; Spring的配置1. Spring的主配置1234567&lt;!-- 扫描的基本包路径 --&gt; &lt;!-- 是否激活属性注入注解 --&gt; &lt;context:component-scan base-package="com.mmall" annotation-config="true"/&gt; &lt;!--&lt;context:annotation-config/&gt;--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!--分离Spring配置文件--&gt; &lt;import resource="applicationContext-datasource.xml"/&gt; 2.Spring数据库的配置2.1 配置Spring文件的时候将常量进行分离123456789101112&lt;!--配置Spring文件的时候将常量进行分离--&gt;&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="order" value="2"/&gt; &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:datasource.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="fileEncoding" value="utf-8"/&gt;&lt;/bean&gt; 2.2 数据库连接池1234567891011121314151617181920212223242526272829303132&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;db.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;db.url&#125;"/&gt; &lt;property name="username" value="$&#123;db.username&#125;"/&gt; &lt;property name="password" value="$&#123;db.password&#125;"/&gt; &lt;!-- 连接池启动时的初始值 --&gt; &lt;property name="initialSize" value="$&#123;db.initialSize&#125;"/&gt; &lt;!-- 连接池的最大值 --&gt; &lt;property name="maxActive" value="$&#123;db.maxActive&#125;"/&gt; &lt;!-- 最大空闲值.当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --&gt; &lt;property name="maxIdle" value="$&#123;db.maxIdle&#125;"/&gt; &lt;!-- 最小空闲值.当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 --&gt; &lt;property name="minIdle" value="$&#123;db.minIdle&#125;"/&gt; &lt;!-- 最大建立连接等待时间。如果超过此时间将接到异常。设为－1表示无限制 --&gt; &lt;property name="maxWait" value="$&#123;db.maxWait&#125;"/&gt; &lt;!--#给出一条简单的sql语句进行验证 --&gt; &lt;!--&lt;property name="validationQuery" value="select getdate()" /&gt;--&gt; &lt;property name="defaultAutoCommit" value="$&#123;db.defaultAutoCommit&#125;"/&gt; &lt;!-- 回收被遗弃的（一般是忘了释放的）数据库连接到连接池中 --&gt; &lt;!--&lt;property name="removeAbandoned" value="true" /&gt;--&gt; &lt;!-- 数据库连接过多长时间不用将被视为被遗弃而收回连接池中 --&gt; &lt;!--&lt;property name="removeAbandonedTimeout" value="120" /&gt;--&gt; &lt;!-- #连接的超时时间，默认为半小时。 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;db.minEvictableIdleTimeMillis&#125;"/&gt; &lt;!--# 失效检查线程运行时间间隔，要小于MySQL默认--&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="40000"/&gt; &lt;!--# 检查连接是否有效--&gt; &lt;property name="testWhileIdle" value="true"/&gt; &lt;!--# 检查连接有效性的SQL语句--&gt; &lt;property name="validationQuery" value="SELECT 1 FROM dual"/&gt;&lt;/bean&gt; 2.3 myBatis的配置1234567&lt;!--mybatis的配置sqlSessionFactory--&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!--mybatis的配置 读取mapper.xml文件--&gt; &lt;property name="mapperLocations" value="classpath*:mappers/*Mapper.xml"&gt; &lt;/property&gt; 1234&lt;!--mybatis的扫描Dao层 MapperScannerConfigurer--&gt;&lt;bean name="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.mmall.dao"/&gt;&lt;/bean&gt; 2.4 分页插件123456789101112&lt;!-- 分页插件 --&gt;&lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageHelper"&gt; &lt;property name="properties"&gt; &lt;value&gt; dialect=mysql &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt;&lt;/property&gt; 2.5 @Transaction1234567&lt;!-- 使用@Transactional进行声明式事务管理需要声明下面这行 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/&gt; &lt;!-- 事务管理 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="rollbackOnCommitFailure" value="true"/&gt; &lt;/bean&gt; application.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 扫描的基本包路径 --&gt; &lt;!-- 是否激活属性注入注解 --&gt; &lt;context:component-scan base-package="com.mmall" annotation-config="true"/&gt; &lt;!--&lt;context:annotation-config/&gt;--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!--分离Spring配置文件--&gt; &lt;import resource="applicationContext-datasource.xml"/&gt;&lt;/beans&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;context:component-scan base-package="com.mmall" annotation-config="true"/&gt; &lt;!--配置Spring文件的时候将常量进行分离--&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="order" value="2"/&gt; &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:datasource.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="fileEncoding" value="utf-8"/&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;db.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;db.url&#125;"/&gt; &lt;property name="username" value="$&#123;db.username&#125;"/&gt; &lt;property name="password" value="$&#123;db.password&#125;"/&gt; &lt;!-- 连接池启动时的初始值 --&gt; &lt;property name="initialSize" value="$&#123;db.initialSize&#125;"/&gt; &lt;!-- 连接池的最大值 --&gt; &lt;property name="maxActive" value="$&#123;db.maxActive&#125;"/&gt; &lt;!-- 最大空闲值.当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --&gt; &lt;property name="maxIdle" value="$&#123;db.maxIdle&#125;"/&gt; &lt;!-- 最小空闲值.当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 --&gt; &lt;property name="minIdle" value="$&#123;db.minIdle&#125;"/&gt; &lt;!-- 最大建立连接等待时间。如果超过此时间将接到异常。设为－1表示无限制 --&gt; &lt;property name="maxWait" value="$&#123;db.maxWait&#125;"/&gt; &lt;!--#给出一条简单的sql语句进行验证 --&gt; &lt;!--&lt;property name="validationQuery" value="select getdate()" /&gt;--&gt; &lt;property name="defaultAutoCommit" value="$&#123;db.defaultAutoCommit&#125;"/&gt; &lt;!-- 回收被遗弃的（一般是忘了释放的）数据库连接到连接池中 --&gt; &lt;!--&lt;property name="removeAbandoned" value="true" /&gt;--&gt; &lt;!-- 数据库连接过多长时间不用将被视为被遗弃而收回连接池中 --&gt; &lt;!--&lt;property name="removeAbandonedTimeout" value="120" /&gt;--&gt; &lt;!-- #连接的超时时间，默认为半小时。 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;db.minEvictableIdleTimeMillis&#125;"/&gt; &lt;!--# 失效检查线程运行时间间隔，要小于MySQL默认--&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="40000"/&gt; &lt;!--# 检查连接是否有效--&gt; &lt;property name="testWhileIdle" value="true"/&gt; &lt;!--# 检查连接有效性的SQL语句--&gt; &lt;property name="validationQuery" value="SELECT 1 FROM dual"/&gt; &lt;/bean&gt; &lt;!--mybatis的配置--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="mapperLocations" value="classpath*:mappers/*Mapper.xml"&gt; &lt;/property&gt; &lt;!-- 分页插件 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageHelper"&gt; &lt;property name="properties"&gt; &lt;value&gt; dialect=mysql &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--mybatis的扫描Dao层--&gt; &lt;bean name="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.mmall.dao"/&gt; &lt;/bean&gt; &lt;!-- 使用@Transactional进行声明式事务管理需要声明下面这行 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/&gt; &lt;!-- 事务管理 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="rollbackOnCommitFailure" value="true"/&gt; &lt;/bean&gt;&lt;/beans&gt; Spring MVC 的配置1 编码配置123456789&lt;!--配置编码--&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 2 JSON配置12345678&lt;!--配置JSON格式--&gt; &lt;bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 3 文件上传配置12345678&lt;!-- 文件上传 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;!-- 10m --&gt; &lt;property name="maxInMemorySize" value="4096"/&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt; &lt;/property&gt;&lt;/bean&gt; SpringMVC.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!--Spring MVC的配置--&gt; &lt;!--包扫描--&gt; &lt;context:component-scan base-package="com.mmall" annotation-config="true"/&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;!--配置编码--&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--配置JSON格式--&gt; &lt;bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 文件上传 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;!-- 10m --&gt; &lt;property name="maxInMemorySize" value="4096"/&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; LogBack的配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!----&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name="mmall" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!--&lt;File&gt;d:/mmalllog/mmall.log&lt;/File&gt;--&gt; &lt;File&gt;/developer/apache-tomcat-7.0.73/logs/mmall.log&lt;/File&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;/developer/apache-tomcat-7.0.73/logs/mmall.log.%d&#123;yyyy-MM-dd&#125;.gz&lt;/fileNamePattern&gt; &lt;append&gt;true&lt;/append&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="error" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!--&lt;File&gt;d:/mmalllog/error.log&lt;/File&gt;--&gt; &lt;File&gt;/developer/apache-tomcat-7.0.73/logs/error.log&lt;/File&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;/devsoft/apache-tomcat-7.0.73/logs/error.log.%d&#123;yyyy-MM-dd&#125;.gz&lt;/fileNamePattern&gt; &lt;!--&lt;fileNamePattern&gt;d:/mmalllog/error.log.%d&#123;yyyy-MM-dd&#125;.gz&lt;/fileNamePattern&gt;--&gt; &lt;append&gt;true&lt;/append&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;logger name="com.mmall" additivity="false" level="INFO" &gt; &lt;appender-ref ref="mmall" /&gt; &lt;appender-ref ref="console"/&gt; &lt;/logger&gt; &lt;!-- geelynote mybatis log 日志 --&gt; &lt;logger name="com.mmall.dao" level="DEBUG"/&gt; &lt;!--&lt;logger name="com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate" level="DEBUG" &gt;--&gt; &lt;!--&lt;appender-ref ref="console"/&gt;--&gt; &lt;!--&lt;/logger&gt;--&gt; &lt;!--&lt;logger name="java.sql.Connection" level="DEBUG"&gt;--&gt; &lt;!--&lt;appender-ref ref="console"/&gt;--&gt; &lt;!--&lt;/logger&gt;--&gt; &lt;!--&lt;logger name="java.sql.Statement" level="DEBUG"&gt;--&gt; &lt;!--&lt;appender-ref ref="console"/&gt;--&gt; &lt;!--&lt;/logger&gt;--&gt; &lt;!--&lt;logger name="java.sql.PreparedStatement" level="DEBUG"&gt;--&gt; &lt;!--&lt;appender-ref ref="console"/&gt;--&gt; &lt;!--&lt;/logger&gt;--&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="console"/&gt; &lt;appender-ref ref="error"/&gt; &lt;/root&gt;&lt;/configuration&gt; Ftp服务器的配置 上传图片123456ftp.server.ip=你的FTP服务器ip地址ftp.user=mmallftpftp.pass=ftppasswordftp.server.http.prefix=http://img.happymmall.com/alipay.callback.url=http://www.happymmall.com/order/alipay_callback.dopassword.salt=geelysdafaqj23ou89ZXcj@#$@#$#@KJdjklj;D../dSF., Idea的注入和自动编译配置 实时编译 BUG Error:Maven Resources Compiler: Maven project configuration required for module ‘mmall’ isn’t available. Compilation of Maven projects is supported only if external build is started from an IDE. 解决方案： Autowired报错的解决方案 ## 两个提高工作效率的神器-Restlet Client和fe助手 https://restlet.com/modules/client/ https://chrome.google.com/webstore/category/extensions?utm_source=chrome-ntp-icon 第五章 用户模块开发 1 Coding1.1 高复用服务器响应对象的设计1234在web开发中，后台开发与前端交互主要是通过json的方式，后台通过统一的返回样式，可以使前后端更好的交互，在一次项目中，我每次返回一个复杂对象的时候，都是用一个匿名对象序列化成json格式的数据返回前端，由于这个项目前后台都是我一个人完成，所以我能比较清楚返回的东西，但是如果是前后端分开进行开发或者前期是一个人开发，后期进行前后端离就会变得异常困难。 因此，规范返回的格式显得很重要，于是乎我便封装了一个简单的高复可用的对象用于响应数据。具体思路如下：--------------------- 原文：https://blog.csdn.net/x1032019725/article/details/77919079 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113设计思路：使用泛型让返回数据多样化，且可以让返回对象统一声明状态字段，表示服务响应状态声明描述字段，描述当前状态的原因声明泛型数据字段，用于返回多种类型的数据，实现高复用 主要代码如下：import org.codehaus.jackson.annotate.JsonIgnore;import org.codehaus.jackson.map.annotate.JsonSerialize;import java.io.Serializable;/** * Created by *** on 2017/8/16. */@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)//项目使用的是Jackson包，添加该注解，保证json序列化的时候，不返回key-null这种类型的数据public class ServerResponse&lt;T&gt; implements Serializable &#123; private int status; private String msg; private T data; //私有化构造方法，通过响应状态来创建 private ServerResponse(int status)&#123; this.status = status; &#125; private ServerResponse(int status,T data)&#123; this.status = status; this.data = data; &#125; private ServerResponse(int status,String msg,T data)&#123; this.status = status; this.msg = msg; this.data = data; &#125; private ServerResponse(int status,String msg)&#123; this.status = status; this.msg = msg; &#125;@JsonIgnore//json序列化返回前端的时候，忽略该方法，不需要返回 public boolean isSuccess() &#123; return this.status == ResponseCode.SUCCESS.getCode(); &#125; //把字段封装成属性，开放get方法 public int getStatus()&#123; return status; &#125; public String getMsg()&#123; return msg; &#125; public T getData()&#123; return data; &#125; //声明创建对象的静态方法，通过下面这些方法来调用私有构造方法，并且set状态 //状态被声明在枚举ResponseCode中 public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccessMessage(String msg)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(String msg,T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg,data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByError()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),ResponseCode.ERROR.getDesc()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorMessage(String errorMessage)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),errorMessage); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorCodeMessage(int errorCode,String errorMessage)&#123; return new ServerResponse&lt;T&gt;(errorCode,errorMessage); &#125;&#125; 下面是ResponseCode的主要代码public enum ResponseCode &#123; SUCCESS(0,&quot;SUCCESS&quot;), ERROR(1,&quot;ERROR&quot;), NEED_LOGIN(10,&quot;NEED_LOGIN&quot;), ILLEGAL_ARGUMENT(2,&quot;ILLEGAL_ARGUMENT&quot;); private final int code; private final String desc; ResponseCode(int code,String desc)&#123; this.code = code; this.desc = desc; &#125; public int getCode()&#123; return this.code; &#125; public String getDesc()&#123; return this.desc; &#125;&#125; 总结：使用ServeResponse这个响应类去进行json序列化，然后响应前端，或者用于后台的各层之间进行交互，提高了代码的可读性，并且增加代码的重用。--------------------- 作者：极_晓 来源：CSDN 原文：https://blog.csdn.net/x1032019725/article/details/77919079 版权声明：本文为博主原创文章，转载请附上博文链接！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778高复用服务响应对象的设计与使用一.什么是高复用服务响应对象？它有什么作用？ 1.这次项目中，为了实现前后端分离，设计了一个所有接口都使用，封装后台业务数据放回json数据给前端的对象，用于实现前后端的分离，开发效率有了明显的提高。 二.怎么使用？ 1.首先，要明确，这个对象要实现序列化接口。它主要封装了三个属性，泛型的返回数据，字符串类型的提示信息以及整型的状态码，以及四个私有的构造函数，需要注意的是，当T 的类型也就是数据类型是String类型时，好像会和下面的String msg重合，到底会调用哪一个呢？答案是，当T为String时，的确会调用第二个，这样会产生一个问题，就是当返回的数据就是String，如果这样就会用到msg的那个构造函数，传到信息那边去了。解决方法在后面，所以具体如下：//保证在序列化json时，如果为空的值，key也会消失，比如只要返回状态码时，msg和data就会忽略不返回 //保证在序列化json时，如果为空的值，key也会消失@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)public class ServerResponse&lt;T&gt; implements Serializable &#123; private int status; private String msg; private T data; private ServerResponse(int status)&#123; this.status = status; &#125; private ServerResponse(int status,String msg)&#123; this.status = status; this.msg = msg; &#125; private ServerResponse(int status,String msg,T data)&#123; this.status = status; this.msg = msg; this.data = data; &#125; private ServerResponse(int status,T data)&#123; this.data = data;&#125; 2.成员变量的get方法，以及一个判断状态码或者说判断响应是否成功的方法，具体如下： @JsonIgnore//在序列化时忽略 public boolean isSuccess()&#123; return this.status==ResponseCode.SUCCESS.getCode(); &#125; public int getStatus()&#123; return status; &#125; public String getMsg()&#123; return msg; &#125; public T getData()&#123; return data; &#125; 3.提供对外访问的七个构造方法，成功的有四个，失败的三个，具体如下：复制代码public static &lt;T&gt; ServerResponse&lt;T&gt; creatBySuccess()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; creatBySuccessMessage(String msg)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; creatBySuccess(T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),data); &#125; //这个方法就解决了msg和String类型的数据冲突的问题 public static &lt;T&gt; ServerResponse&lt;T&gt; creatBySuccess(String msg,T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg,data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; creatByError()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),ResponseCode.ERROR.getDesc()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; creatByErrorMessage(String errorMessage)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),errorMessage); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; creatByErrorCodeMessage(int errorCode,String errorMessage)&#123; return new ServerResponse&lt;T&gt;(errorCode,errorMessage); &#125;复制代码三.总结 这次的高复用服务响应对象的设计与使用涉及到泛型类，后端的数据的处理模式，枚举类的使用，以及前后端数据交互等知识，在后期使用Restlet Clint进行接口功能测试时更加直观地看到了这个对象的作用。 https://blog.csdn.net/qq_27093465/article/details/52180865]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis 尚硅谷]]></title>
    <url>%2F2019%2F01%2F16%2FRedis%2FRedis%20%E5%B0%9A%E7%A1%85%E8%B0%B7%2F</url>
    <content type="text"><![CDATA[1 下载 ⏬ https://redis.io/download 官网下载地址 2 使用 HelloWord 先cd 到redis （root）下面 然后ls 找到src 然后./redis-server 然后新开一个终端 然后ls 找到src ./redis-cli 3 Redis_启动后杂项基础知识 4 Redis的五大数据类型 5.Redis 键 key1.keys * ：列出所有key 2.exists key的名字 判断某个key是否存在 3. move key db —&gt;当前库就没有了 被移除了 4.expire key 秒钟 为给定的key设置过期时间5.ttl key 查看还有多少秒过期 -1表示永不过期 -2表示已过期 6.Redis String 单值单value 1.get/set/del/append/strlen Incr/decr/incrby/decrby一定是要数字才能加减 Get range/setrange setex键秒值/setnx 7 Redis -List 单值 多valueLPUSH RPUSHLRANGE LPOP RPOP 取出栈顶元素 lindex 按照索引获得元素 从上到下 llen 长度 lrem key 删除N 个value 删除2个 value=3的value 8 Redis set 9 Redis Hash 重要 KV模式不变 但v是一个箭值对 10 Redis Zset 11 Redis 配置文件介绍 12 Redis_持久化之RDB 13 Redis 持久化 之AOF 14 Redis事务 15 Redies 消息订阅 16 Redis主从复制。读写分离 哨兵模式 17 JRedis JRedis Pool]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch]]></title>
    <url>%2F2019%2F01%2F16%2FELasticseach%2FElsearch%2F</url>
    <content type="text"><![CDATA[快速入门篇课程介绍Elasticsearch，是目前行业中非常热门的一个技术。Elasticsearch是一种分布式的海量数据搜索与分析的技术，可以用于电商网站、门户网站、企业IT系统等各种场景下的搜索引擎，也可以用于对海量的数据进行近实时的数据分析。相较于Lucene来说，Elasticsearch天然的分布式特性，让其可以支持海量的、PB级的大数据搜索。相对于Spark Streaming、Storm等大数据实时计算引擎来说，Elasticsearch天生为分布式执行数据分析操作而生的架构，海量数据量级下的近实时（秒级）性能支持，以及无比强大的搜索和聚合分析的语法支持，让ES更加适合进行大数据场景下的数据分析应用。 Spark Streaming进行实时数据分析，有天然的无法全量多数据流join、内核shuffle过程大量基于磁盘落地等缺陷，导致其实时数据分析功能较差，实时数据分析性能也较差。Storm则作为实时计算引擎的鼻祖，由于其对SQL的支持很弱，导致其非常不适合进行实时数据分析，开发成本巨大。而Elasticsearch克服了上述大数据技术的缺点，更加适合进行大数据场景下的数据分析操作。 本课程深入浅出剖析了Elasticsearch的核心基础知识，带着大家一步一步，从快速入门，到理解Elasticsearch的工作原理、内核级原理，再到动手实战操作Elasticsearch的各种核心功能，到最后可以基于Java开发基本的搜索和分析应用程序。 课程特点如下： 1、基于Elasticsearch最新版本，5.2版本，进行课程的讲解，让大家学好技术后，绝对不会落伍。而市面上的书籍和视频，使用的Elasticsearch版本都非常陈旧，一般都是1.x，或者2.x，即使学了，也完全跟现在最新的版本无法兼容，无法让同学们学以致用。 2、大白话讲解各种复杂知识点，不用太官方和学术的语言照着ppt简单讲解，而是采用与朋友聊天式的方式，进行对话和讲解，尽量采用最通俗的语言来解释各种复杂的技术问题，还有底层原理。 3、课程知识体系设计的足够详细，将一门技术的各个知识点和技术点，全部包含在课程中，一点一点的细致剖析和展开讲解，绝不让大家遗漏任何有用的知识点，尽量做到，课程知识体系完整，系统化，有广度，而且也有深度。比如说本套课程中，既全面包括了从入门使用，到分布式文档系统操作，到搜索引擎操作，到索引管理，最后到Java API使用，这样完整的知识体系。同时还细致到包含很多独家的知识点，比如说Elasticsearch如何突破扩容瓶颈，search timeout机制，如何定位不合法的搜索，等等。 4、包含很多独家的核心知识点和技术，比如乐观锁并发控制，写一致性与quorum机制，bulk api底层性能优化，deep-paging性能问题，大数据量零停机重建索引，等等。 5、课程的原理性讲解足够深入，一直剖析到ES的内核层面，而且几乎所有原理知识点的讲解100%都使用现场一点一点手工画图的方式来剖析和讲解。比如ES容错机制，document数据路由，object类型底层结构，相关度评分TF/IDF算法，doc value，type底层数据结构，内核级数据写入流程，index segment、memory buffer、filesystem cache、flush、commit等内核级原理。 6、大量的上机动手实验，几乎所有功能都会带着大家上机动手实战操作，演练，掌握功能的使用。比如入门级的电商网站商品管理案例，基于版本号进行乐观锁并发控制的实验，mget+bulk批量处理的实验，scoll滚动搜索大量数据的实验，scoll+bulk+alias零停机重建索引的实验，基于Java开发的员工管理案例，等等。 本套课程学完以后能够达到的效果： 1、快速掌握Elasticsearch的各种使用，包括document管理，索引管理，搜索，聚合分析，等等。2、细致掌握Elasticsearch的各种高级核心知识点，包括乐观锁并发控制，mget+bulk批处理，零停机场景下重建索引，dynamic mapping模板定制，分词器定制，等等。3、深入理解Elasticsearch的各种核心原理，包括分布式架构原理，分布式文档系统原理，分布式搜索引擎原理，内核级原理。4、快速掌握基于Java来开发Elasticsearch的简单应用程序，实现包括document增删改查，常见的搜索操作，常见的聚合分析操作。5、基于上述4点的掌握，可以为更加进一步深入学习Elasticsearch这门技术打好基础。 《Elasticsearch顶尖高手系列课程：核心知识篇（下半季）》预告： 核心知识篇还会有下半季，会在这半季的基础上更加深入的去讲解Elasticsearch的核心知识，让大家一站式彻底掌握和精通ES的核心知识体系 1、深度探秘Elasticsearch的搜索功能，彻底讲解ES搜索相关的所有知识点，包括复杂多条件组合搜索，搜索权重控制，多域/跨域搜索，近似匹配搜索，search as you type，相关度评分彻底掌控，Stemmer，模糊匹配和自动纠错，等等。 2、彻底解析ES的数据聚合分析功能，包括基于时间跨度的聚合分析，聚合结果排序，近似聚合算法，doc value和fielddata大揭秘，等等。 3、深入讲解ES的数据建模，包括父子关系数据建模，嵌套关系数据建模，超大数据量场景下，搜索和分析应用的数据建模与设计原则，等等。 4、基于Java彻底玩转Elasticsearch，包括基于Java实现bulk，scoll，复杂搜索，复杂聚合，索引管理，等等。 5、项目实战：新闻门户网站的小型搜索引擎&amp;数据分析系统 Elasticsearch的功能 特点 适用场景课程大纲 1、Elasticsearch的功能，干什么的2、Elasticsearch的适用场景，能在什么地方发挥作用3、Elasticsearch的特点，跟其他类似的东西不同的地方在哪里 1、Elasticsearch的功能 （1）分布式的搜索引擎和数据分析引擎 搜索：百度，网站的站内搜索，IT系统的检索数据分析：电商网站，最近7天牙膏这种商品销量排名前10的商家有哪些；新闻网站，最近1个月访问量排名前3的新闻版块是哪些分布式，搜索，数据分析 （2）全文检索，结构化检索，数据分析 全文检索：我想搜索商品名称包含牙膏的商品，select from products where product_name like “%牙膏%”结构化检索：我想搜索商品分类为日化用品的商品都有哪些，select from products where category_id=’日化用品’部分匹配、自动完成、搜索纠错、搜索推荐数据分析：我们分析每一个商品分类下有多少个商品，select category_id,count(*) from products group by category_id （3）对海量数据进行近实时的处理 分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索海联数据的处理：分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了近实时：检索个数据要花费1小时（这就不要近实时，离线批处理，batch-processing）；在秒级别对数据进行搜索和分析 跟分布式/海量数据相反的：lucene，单机应用，只能在单台服务器上使用，最多只能处理单台服务器可以处理的数据量 2、Elasticsearch的适用场景 国外 （1）维基百科，类似百度百科，牙膏，牙膏的维基百科，全文检索，高亮，搜索推荐（2）The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜）（3）Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案（4）GitHub（开源代码管理），搜索上千亿行代码（5）电商网站，检索商品（6）日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana）（7）商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买（8）BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，**区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘，Kibana进行数据可视化 国内 （9）国内：站内搜索（电商，招聘，门户，等等），IT系统搜索（OA，CRM，ERP，等等），数据分析（ES热门的一个使用场景） 3、Elasticsearch的特点 （1）可以作为一个大型分布式集群（数百台服务器）技术，处理PB级数据，服务大公司；也可以运行在单机上，服务小公司（2）Elasticsearch不是什么新技术，主要是将全文检索、数据分析以及分布式技术，合并在了一起，才形成了独一无二的ES；lucene（全文检索），商用的数据分析软件（也是有的），分布式数据库（mycat）（3）对用户而言，是开箱即用的，非常简单，作为中小型的应用，直接3分钟部署一下ES，就可以作为生产环境的系统来使用了，数据量不大，操作不是太复杂（4）数据库的功能面对很多领域是不够用的（事务，还有各种联机事务型的操作）；特殊的功能，比如全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理；Elasticsearch作为传统数据库的一个补充，提供了数据库所不不能提供的很多功能 手工画图剖析Elasticsearch核心概念：NRT、索引、分片、副本课程大纲 1、lucene和elasticsearch的前世今生2、elasticsearch的核心概念3、elasticsearch核心概念 vs. 数据库核心概念 1、lucene和elasticsearch的前世今生 lucene，最先进、功能最强大的搜索库，直接基于lucene开发，非常复杂，api复杂（实现一些简单的功能，写大量的java代码），需要深入理解原理（各种索引结构） elasticsearch，基于lucene，隐藏复杂性，提供简单易用的restful api接口、java api接口（还有其他语言的api接口）（1）分布式的文档存储引擎（2）分布式的搜索引擎和分析引擎（3）分布式，支持PB级数据 开箱即用，优秀的默认参数，不需要任何额外设置，完全开源 关于elasticsearch的一个传说，有一个程序员失业了，陪着自己老婆去英国伦敦学习厨师课程。程序员在失业期间想给老婆写一个菜谱搜索引擎，觉得lucene实在太复杂了，就开发了一个封装了lucene的开源项目，compass。后来程序员找到了工作，是做分布式的高性能项目的，觉得compass不够，就写了elasticsearch，让lucene变成分布式的系统。 2、elasticsearch的核心概念 （1）Near Realtime（NRT）：近实时，两个意思，从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级 （2）Cluster：集群，包含多个节点，每个节点属于哪个集群是通过一个配置（集群名称，默认是elasticsearch）来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常（3）Node：节点，集群中的一个节点，节点也有一个名称（默认是随机分配的），节点名称很重要（在执行运维管理操作的时候），默认节点会去加入一个名称为“elasticsearch”的集群，如果直接启动一堆节点，那么它们会自动组成一个elasticsearch集群，当然一个节点也可以组成一个elasticsearch集群 （4）Document&amp;field：文档，es中的最小数据单元，一个document可以是一条客户数据，一条商品分类数据，一条订单数据，通常用JSON数据结构表示，每个index下的type中，都可以去存储多个document。一个document里面有多个field，每个field就是一个数据字段。 product document { “product_id”: “1”, “product_name”: “高露洁牙膏”, “product_desc”: “高效美白”, “category_id”: “2”, “category_name”: “日化用品”} （5）Index：索引，包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document。比如说建立一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品document。（6）Type：类型，每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field，比如博客系统，有一个索引，可以定义用户数据type，博客数据type，评论数据type。 商品index，里面存放了所有的商品数据，商品document 但是商品分很多种类，每个种类的document的field可能不太一样，比如说电器商品，可能还包含一些诸如售后时间范围这样的特殊field；生鲜商品，还包含一些诸如生鲜保质期之类的特殊field type，日化商品type，电器商品type，生鲜商品type 日化商品type：product_id，product_name，product_desc，category_id，category_name电器商品type：product_id，product_name，product_desc，category_id，category_name，service_period生鲜商品type：product_id，product_name，product_desc，category_id，category_name，eat_period 每一个type里面，都会包含一堆document { “product_id”: “2”, “product_name”: “长虹电视机”, “product_desc”: “4k高清”, “category_id”: “3”, “category_name”: “电器”, “service_period”: “1年”} { “product_id”: “3”, “product_name”: “基围虾”, “product_desc”: “纯天然，冰岛产”, “category_id”: “4”, “category_name”: “生鲜”, “eat_period”: “7天”} （7）shard：单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个shard都是一个lucene index。（8）replica：任何一个服务器随时可能故障或宕机，此时shard可能就会丢失，因此可以为每个shard创建多个replica副本。replica可以在shard故障时提供备用服务，保证数据不丢失，多个replica还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认5个），replica shard（随时修改数量，默认1个），默认每个索引10个shard，5个primary shard，5个replica shard，最小的高可用配置，是2台服务器。 3、elasticsearch核心概念 vs. 数据库核心概念 Elasticsearch 数据库 Document 行Type 表Index 库 在windows上安装和启动Elasticseach1、安装JDK，至少1.8.0_73以上版本，java -version2、下载和解压缩Elasticsearch安装包，目录结构3、启动Elasticsearch：bin\elasticsearch.bat，es本身特点之一就是开箱即用，如果是中小型应用，数据量少，操作不是很复杂，直接启动就可以用了 4、检查ES是否启动成功：http://localhost:9200/?pretty name: node名称cluster_name: 集群名称（默认的集群名称就是elasticsearch）version.number: 5.2.0，es版本号 { “name” : “4onsTYV”, “cluster_name” : “elasticsearch”, “cluster_uuid” : “nKZ9VK_vQdSQ1J0Dx9gx1Q”, “version” : { “number” : “5.2.0”, “build_hash” : “24e05b9”, “build_date” : “2017-01-24T19:52:35.800Z”, “build_snapshot” : false, “lucene_version” : “6.4.0” }, “tagline” : “You Know, for Search”} 5、修改集群名称：elasticsearch.yml6、下载和解压缩Kibana安装包，使用里面的开发界面，去操作elasticsearch，作为我们学习es知识点的一个主要的界面入口7、启动Kibana：bin\kibana.bat8、进入Dev Tools界面9、GET _cluster/health 快速入门案例实战之电商网站商品管理：集群健康检查，文档CRUD课程大纲 1、document数据格式2、电商网站商品管理案例：背景介绍3、简单的集群管理4、商品的CRUD操作（document CRUD操作） 1、document数据格式 面向文档的搜索分析引擎 （1）应用系统的数据结构都是面向对象的，复杂的（2）对象数据存储到数据库中，只能拆解开来，变为扁平的多张表，每次查询的时候还得还原回对象格式，相当麻烦（3）ES是面向文档的，文档中存储的数据结构，与面向对象的数据结构是一样的，基于这种文档数据结构，es可以提供复杂的索引，全文检索，分析聚合等功能（4）es的document用json数据格式来表达 public class Employee { private String email; private String firstName; private String lastName; private EmployeeInfo info; private Date joinDate; } private class EmployeeInfo { private String bio; // 性格 private Integer age; private String[] interests; // 兴趣爱好 } EmployeeInfo info = new EmployeeInfo();info.setBio(“curious and modest”);info.setAge(30);info.setInterests(new String[]{“bike”, “climb”}); Employee employee = new Employee();employee.setEmail(“zhangsan@sina.com“);employee.setFirstName(“san”);employee.setLastName(“zhang”);employee.setInfo(info);employee.setJoinDate(new Date()); employee对象：里面包含了Employee类自己的属性，还有一个EmployeeInfo对象 两张表：employee表，employee_info表，将employee对象的数据重新拆开来，变成Employee数据和EmployeeInfo数据employee表：email，first_name，last_name，join_date，4个字段employee_info表：bio，age，interests，3个字段；此外还有一个外键字段，比如employee_id，关联着employee表 { “email”: “zhangsan@sina.com“, “first_name”: “san”, “last_name”: “zhang”, “info”: { “bio”: “curious and modest”, “age”: 30, “interests”: [ “bike”, “climb” ] }, “join_date”: “2017/01/01”} 我们就明白了es的document数据格式和数据库的关系型数据格式的区别 2、电商网站商品管理案例背景介绍 有一个电商网站，需要为其基于ES构建一个后台系统，提供以下功能： （1）对商品信息进行CRUD（增删改查）操作（2）执行简单的结构化查询（3）可以执行简单的全文检索，以及复杂的phrase（短语）检索（4）对于全文检索的结果，可以进行高亮显示（5）对数据进行简单的聚合分析 3、简单的集群管理 （1）快速检查集群的健康状况 es提供了一套api，叫做cat api，可以查看es中各种各样的数据 GET /_cat/health?v epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1488006741 15:12:21 elasticsearch yellow 1 1 1 1 0 0 1 0 - 50.0% epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1488007113 15:18:33 elasticsearch green 2 2 2 1 0 0 0 0 - 100.0% epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1488007216 15:20:16 elasticsearch yellow 1 1 1 1 0 0 1 0 - 50.0% 如何快速了解集群的健康状况？green、yellow、red？ green：每个索引的primary shard和replica shard都是active状态的yellow：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态red：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了 为什么现在会处于一个yellow状态？ 我们现在就一个笔记本电脑，就启动了一个es进程，相当于就只有一个node。现在es中有一个index，就是kibana自己内置建立的index。由于默认的配置是给每个index分配5个primary shard和5个replica shard，而且primary shard和replica shard不能在同一台机器上（为了容错）。现在kibana自己建立的index是1个primary shard和1个replica shard。当前就一个node，所以只有1个primary shard被分配了和启动了，但是一个replica shard没有第二台机器去启动。 做一个小实验：此时只要启动第二个es进程，就会在es集群中有2个node，然后那1个replica shard就会自动分配过去，然后cluster status就会变成green状态。 （2）快速查看集群中有哪些索引 GET /_cat/indices?v health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizeyellow open .kibana rUm9n9wMRQCCrRDEhqneBg 1 1 1 0 3.1kb 3.1kb （3）简单的索引操作 创建索引：PUT /test_index?pretty health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizeyellow open test_index XmS9DTAtSkSZSwWhhGEKkQ 5 1 0 0 650b 650byellow open .kibana rUm9n9wMRQCCrRDEhqneBg 1 1 1 0 3.1kb 3.1kb 删除索引：DELETE /test_index?pretty health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizeyellow open .kibana rUm9n9wMRQCCrRDEhqneBg 1 1 1 0 3.1kb 3.1kb 4、商品的CRUD操作 （1）新增商品：新增文档，建立索引 PUT /index/type/id{ “json数据”} PUT /ecommerce/product/1{ “name” : “gaolujie yagao”, “desc” : “gaoxiao meibai”, “price” : 30, “producer” : “gaolujie producer”, “tags”: [ “meibai”, “fangzhu” ]} { “_index”: “ecommerce”, “_type”: “product”, “_id”: “1”, “_version”: 1, “result”: “created”, “_shards”: { “total”: 2, “successful”: 1, “failed”: 0 }, “created”: true} PUT /ecommerce/product/2{ “name” : “jiajieshi yagao”, “desc” : “youxiao fangzhu”, “price” : 25, “producer” : “jiajieshi producer”, “tags”: [ “fangzhu” ]} PUT /ecommerce/product/3{ “name” : “zhonghua yagao”, “desc” : “caoben zhiwu”, “price” : 40, “producer” : “zhonghua producer”, “tags”: [ “qingxin” ]} es会自动建立index和type，不需要提前创建，而且es默认会对document每个field都建立倒排索引，让其可以被搜索 （2）查询商品：检索文档 GET /index/type/idGET /ecommerce/product/1 { “_index”: “ecommerce”, “_type”: “product”, “_id”: “1”, “_version”: 1, “found”: true, “_source”: { “name”: “gaolujie yagao”, “desc”: “gaoxiao meibai”, “price”: 30, “producer”: “gaolujie producer”, “tags”: [ “meibai”, “fangzhu” ] }} （3）修改商品：替换文档 PUT /ecommerce/product/1{ “name” : “jiaqiangban gaolujie yagao”, “desc” : “gaoxiao meibai”, “price” : 30, “producer” : “gaolujie producer”, “tags”: [ “meibai”, “fangzhu” ]} { “_index”: “ecommerce”, “_type”: “product”, “_id”: “1”, “_version”: 1, “result”: “created”, “_shards”: { “total”: 2, “successful”: 1, “failed”: 0 }, “created”: true} { “_index”: “ecommerce”, “_type”: “product”, “_id”: “1”, “_version”: 2, “result”: “updated”, “_shards”: { “total”: 2, “successful”: 1, “failed”: 0 }, “created”: false} PUT /ecommerce/product/1{ “name” : “jiaqiangban gaolujie yagao”} 替换方式有一个不好，即使必须带上所有的field，才能去进行信息的修改 （4）修改商品：更新文档 POST /ecommerce/product/1/_update{ “doc”: { “name”: “jiaqiangban gaolujie yagao” }} { “_index”: “ecommerce”, “_type”: “product”, “_id”: “1”, “_version”: 8, “result”: “updated”, “_shards”: { “total”: 2, “successful”: 1, “failed”: 0 }} 我的风格，其实有选择的情况下，不太喜欢念ppt，或者照着文档做，或者直接粘贴写好的代码，尽量是纯手敲代码 （5）删除商品：删除文档 DELETE /ecommerce/product/1 { “found”: true, “_index”: “ecommerce”, “_type”: “product”, “_id”: “1”, “_version”: 9, “result”: “deleted”, “_shards”: { “total”: 2, “successful”: 1, “failed”: 0 }} { “_index”: “ecommerce”, “_type”: “product”, “_id”: “1”, “found”: false} 快速入门案例实战之电商网站商品管理：多种搜索方式]]></content>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC详解]]></title>
    <url>%2F2019%2F01%2F01%2FSpring%2FSpring%20IOC%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[相当于@Bean注解和@Controller注解]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring @AspectJ]]></title>
    <url>%2F2019%2F01%2F01%2FSpring%2F9.%40Aspect%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F01%2FSpring%2F8.Spring%20AOP%20API%20imooc%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Spring Autpwired]]></title>
    <url>%2F2019%2F01%2F01%2FSpring%2F6.%40Autowird%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Autowired]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Spring依赖注入的一些理解]]></title>
    <url>%2F2018%2F12%2F31%2FSpring%2F2.Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[问大家一个问题 Spring中注册的bean 在xml中配置 我看写的程序中没有调用 xxx.getBean(“xxx”)。那在程序中是如何使用这个bean的呢]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 千峰教育笔记]]></title>
    <url>%2F2018%2F12%2F25%2FRabbitMQ%2FRabbit%20MQ%E5%8D%83%E5%B3%B0%2F</url>
    <content type="text"><![CDATA[1.RabbitMQ 简介 2.Rabbit MQ的安装 3.Rabbit MQ添加用户 4.Rabbit MQ使用教程 ⭐️4.1消息模式种类 4.2 pom&amp;log4j.properties123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qianfeng&lt;/groupId&gt; &lt;artifactId&gt;testrabbitmqdemo&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;testrabbitmqdemo&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt; &lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt; =====================amqp-clien========================== ============================ &lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;4.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.amqp/spring-rabbit􏴏􏴐 spring 􏰚􏲂􏱗,amqp 􏰪􏱚 rabbitmq 􏴑􏲅􏴒􏴓 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; ===================spring-rabbit========================= ============================ &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt; &lt;version&gt;1.7.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567log4j.rootLogger=DEBUG,A1log4j.logger.com.taotao = DEBUGlog4j.logger.org.mybatis = DEBUGlog4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c]-[%p] %m%n 4.3HelloWorld (生产者 消费者)123456789101112131415161718package com.rabbitmq;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * 用于创建连接的工具类 */public class ConnectionUtils &#123; public static Connection getConnection() throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost("94.191.24.33");//这个Host是ip地址 如果是Linux的就是Linux的ipconfig// 否则就是服务器的公网地址此处是腾讯云的公网ip地址 connectionFactory.setPort(5672);//5672是服务器的端口 15672是网页的端口 connectionFactory.setUsername("guest"); connectionFactory.setPassword("guest"); connectionFactory.setVirtualHost("/"); return connectionFactory.newConnection(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.rabbitmq;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;//生产者public class Sender &#123; private final static String QUEUEName = "RabbitmqName";//定义一个队列的名字 public static void main(String[] args) throws Exception &#123; //1。获取连接 Connection connection = ConnectionUtils.getConnection(); //2。创建通道 Channel channel = connection.createChannel(); //3。声明队列 /** * 如果队列存在则什么都不做 如果不存在才创建 * QUEUEName ： 参数1 队列的名字 * durable : 参数2 是否持久化队列 * &gt; 我们的队列模式是在内存中的 如果rabbitmq 重启 会丢失 * &gt; 如果设置为true ,则会保存到erlang自带的数据库中，重启后会重新读取 *exclusive: 参数3 是否排除 有两个作用 * &gt; 作用1： 第一个当我们的连接关闭后是否会自动删除队列 * &gt; 作用2：是否私有当前队列 如果私有了其他通道不可以访问当前对列 * &gt; 如果为true 一般是一个队列只适用于一个消费者的时候 *autodelete： 参数4：是否自动删除 * 参数5：一切其他参数 */ channel.queueDeclare(QUEUEName, false, false, false, null); //4。发送内容 channel.basicPublish("", QUEUEName, null, "发送的消息".getBytes()); //5。关闭连接 connection.close(); channel.close(); &#125;&#125; 123456789101112131415161718192021222324252627package com.rabbitmq;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.QueueingConsumer;//消费者public class Recver &#123; private final static String QUEUEName = "RabbitmqName";//定义一个队列的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUEName, false, false, false, null); //定义一个消费者 QueueingConsumer consumer = new QueueingConsumer(channel); //接受参数 参数2是自动确认 channel.basicConsume(QUEUEName, true, consumer); while (true) &#123; //获取消息 //如果没有消息会等待 有的话就获取执行然后销毁是一次性的 QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String s = new String(delivery.getBody()); System.out.println(s); &#125; &#125;&#125; RabbitMQ连接工具 4.4 消息队列之RabbitMq-work 模式 12345678910111213141516171819202122232425262728293031public class Recver1 &#123; private final static String QUEUE = "testwork";//队列的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE,false,false,false,null); // 同一时刻服务器只会发一条消息给消费者,只有当前消费者将消息处理完成后才会获取到下一条消息 //注释掉后可以获取多条消息,但是会一条一条处理 channel.basicQos(1);//告诉服务器,在我们没有确认当前消息完成之前,不要给我发新的消息 DefaultConsumer consumer =new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //当我们收到消息的时候调用 System.out.println("消费者1 收到的内容是:"+new String(body)); //确认 try &#123; Thread.sleep(10);//模拟耗时 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false);//参数2,false 为确认收到消息, true 为拒接收到消息 &#125; &#125;; //注册消费者, 参数2 手动确认,代表我们收到消息后需要手动告诉服务器,我收到消息了 channel.basicConsume(QUEUE,false,consumer); &#125;&#125; 1234567891011121314151617181920212223242526272829public class Recver2 &#123; private final static String QUEUE = "testwork";//队列的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE,false,false,false,null); channel.basicQos(1);//告诉服务器,在我们没有确认当前消息完成之前,不要给我发新的消息 DefaultConsumer consumer =new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //当我们收到消息的时候调用 System.out.println("消费者2 收到的内容是:"+new String(body)); try &#123; Thread.sleep(300);//模拟耗时 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //确认 channel.basicAck(envelope.getDeliveryTag(), false);//参数2,false 为确认收到消息, true 为拒接收到消息 &#125; &#125;; //注册消费者, 参数2 手动确认,代表我们收到消息后需要手动告诉服务器,我收到消息了 channel.basicConsume(QUEUE,false,consumer); &#125;&#125; 1234567891011121314151617181920212223242526public class Sender &#123; private final static String QUEUE = "testwork";//队列的名字 public static void main(String[] args) throws Exception &#123; //获取连接 Connection connection = ConnextionUtil.getConnection(); //创建通道 Channel channel = connection.createChannel(); //声明队列,如果队列存在则什么都不做,如果不存在才创建 // 参数1 队列的名字 //参数2 是否持久化队列,我们的队列模式是在内存中的,如果 rabbitmq 重启会丢失,如果我们设置为 true, 则会保存到 erlang 自带的数据库中,重启后会重新读取 //参数3 是否排外,有两个作用,第一个当我们的连接关闭后是否会自动删除队列,作用二 是否私有当天前队列,如果私有了,其他通道不可以访问当前队列,如果为 true, 一般是一个队列只适用于一个消费者的时候 //参数4 是够自动删除 //参数5 我们的一些其他参数 channel.queueDeclare(QUEUE, false, false, false, null); for (int i = 0; i &lt; 100; i++) &#123; //发送内容 channel.basicPublish("",QUEUE,null,("发送的消息"+i).getBytes()); &#125; //关闭连接 channel.close(); connection.close(); &#125;&#125; 4.5消息队列之RabbitMq -消息确认 4.6 消息队列之RabbitMq -Publish_Subscribe发布订阅模式 123456789101112131415161718192021222324public class Recver1 &#123; private final static String EXCHANGE_NAME = "testexchange";//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare("testpubqueue1", false, false, false,null); //绑定队列到交换机 channel.queueBind("testpubqueue1", EXCHANGE_NAME, ""); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println("消费者11111111:"+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume("testpubqueue1", false, consumer); &#125;&#125; 1234567891011121314151617181920public class Recver2 &#123; private final static String EXCHANGE_NAME = "testexchange";//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare("testpubqueue2", false, false, false,null); //绑定队列到交换机 channel.queueBind("testpubqueue2", EXCHANGE_NAME, ""); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println("消费者2222222:"+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume("testpubqueue2", false, consumer); &#125;&#125; 1234567891011121314public class Sender &#123; private final static String EXCHANGE_NAME = "testexchange";//定义交换机的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(EXCHANGE_NAME, "fanout");//定义一个交换机,类型是fanout,也就是发布订阅模式 //发布订阅模式的,因为消息是先发到交换机中,而交换机是没有保存功能的,所以如果没有消费者,消息会丢失 channel.basicPublish(EXCHANGE_NAME, "", null, "发布订阅模式的消息".getBytes()); channel.close(); connection.close(); &#125; &#125; 4.7消息队列之RabbitMq -route 路由模式 RabbitMQ topic模式 1234567891011121314public class Sender &#123; private final static String EXCHANGE_NAME = "testtopic"; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange,声明为 topic 也就是通配符类型 channel.exchangeDeclare(EXCHANGE_NAME, "topic"); //发送 abc.1.2数据,凡是能匹配到这个关键词的都会收到 channel.basicPublish(EXCHANGE_NAME, "abc.1.2", null, "topic 模式消息111".getBytes()); channel.close(); connection.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031import com.qianfeng.uitl.ConnextionUtil;import com.rabbitmq.client.*;import java.io.IOException;/** * Created by jackiechan on 2018/4/5/下午4:33 */public class Recver2 &#123; private final static String EXCHANGE_NAME = "testtopic";//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare("testtopicqueue2", false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 channel.queueBind("testtopicqueue2", EXCHANGE_NAME, "key.#"); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind("testtopicqueue2", EXCHANGE_NAME, "abc.#"); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println("消费者22222:"+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume("testtopicqueue2", false, consumer); &#125; &#125; 12345678910111213141516171819202122232425262728293031import com.qianfeng.uitl.ConnextionUtil;import com.rabbitmq.client.*;import java.io.IOException;/** * Created by jackiechan on 2018/4/5/下午4:33 */public class Recver1 &#123; private final static String EXCHANGE_NAME = "testtopic";//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare("testtopicqueue1", false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 channel.queueBind("testtopicqueue1", EXCHANGE_NAME, "key.*"); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind("testtopicqueue1", EXCHANGE_NAME, "abc.#"); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println("消费者11111111:"+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume("testtopicqueue1", false, consumer); &#125;&#125; Rabbit MQ 整合Spring 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xsi:schemaLocation="http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.7.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"&gt; &lt;!--1 定义连接工厂--&gt; &lt;rabbit:connection-factory id="connectionFactory" host="192.168.3.233" port="5672" username="test" password="test" virtual-host="/test"/&gt; &lt;!--消息是发送到交换机还是队列--&gt; &lt;!--定义 rabbitmq 的模板 queue="" 如果发送到队列则写队列 exchange="" 如果发送到交换机则写交换机 routing-key="" 定义路由的关键字 --&gt; &lt;rabbit:template id="template" connection-factory="connectionFactory" exchange="fanoutExchange" /&gt; &lt;rabbit:admin connection-factory="connectionFactory"/&gt; &lt;!--定义队列--&gt; &lt;rabbit:queue name="myQueue" auto-declare="true"/&gt; &lt;!--定义交换机--&gt; &lt;rabbit:fanout-exchange name="fanoutExchange" auto-declare="true"&gt; &lt;!--将队列绑定到交换机--&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="myQueue"&gt; &lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:fanout-exchange&gt;&lt;!--定义监听容易,当收到消息的时候会执行内部的配置--&gt; &lt;rabbit:listener-container connection-factory="connectionFactory"&gt;&lt;!--定义到底哪个类里面的什么方法用于处理收到的消息--&gt; &lt;rabbit:listener ref="consumer" method="test" queue-names="myQueue"/&gt; &lt;/rabbit:listener-container&gt; &lt;!--定义消费者--&gt; &lt;bean id="consumer" class="com.qianfeng.spring.MyConsumer"/&gt;&lt;!-- &lt;rabbit:direct-exchange name="directExchange" durable="true" auto-delete="false"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="myQueue" key="key1"&gt; &lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:direct-exchange&gt;--&gt; &lt;!-- &lt;rabbit:topic-exchange name="topicExchange" durable="true" auto-delete="false"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding pattern="dfasfsd.*" queue="myQueue"/&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:topic-exchange&gt;--&gt;&lt;/beans&gt; 123456789public class MyConsumer &#123; /** * 用于接收消息 * @param message */ public void test(String message) &#123; System.err.println(message); &#125;&#125; 12345678public class SpringTest &#123; public static void main(String[] args) throws Exception&#123; ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); RabbitTemplate template = context.getBean(RabbitTemplate.class); template.convertAndSend("spring 的消息"); ((ClassPathXmlApplicationContext) context).destroy(); &#125;&#125;]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ Exchange]]></title>
    <url>%2F2018%2F12%2F25%2FRabbitMQ%2F6.Exchange%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合]]></title>
    <url>%2F2018%2F12%2F23%2FSSM%20%2FSSM%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[新建SSM项目 ，关于IDEA的版本问题强烈建议使用旗舰版，有条件的就购买，没条件的嘛。。 天朝你懂的。在欢迎界面点击Create New Project。 之后选择Maven(新建JAVAEE项目是需要安装JDK的，这个就不在这里讲解了。 )选好之后点击下一步。之后填入GroupID和ArtifactID这里尽量按照Maven的命名规范来即可。之后点击下一步，填入项目名称，这里我建议和之前填写的ArtifactID名称一样即可。点击Finish完成项目的创建。之后尽量不要做其他操作，让IDEA完成索引创建。 完善目录结构首先观察一下IDEA给我们生成的目录结构，这是一个标准的Maven目录。 但是其中少了一个webapp目录用于存放jsp、css、js、图片之类的文件。 之后还需要完善我们的目录结构，如下图：以上的命名都是我们开发过程中常用的命名规则，不一定按照我这样来，但是最好是有一定的规范。 POM.xmlpom.xml是整个maven的核心配置文件，里面有对项目的描述和项目所需要的依赖。 哦对了，在修改pom.xml文件之前我们最好先设置一下该项目的Maven设置(IDEA对每个项目的maven设置和Eclipse不一样，不是设置一次就可了，如果今后还要新建项目那就还需要设置， 同时按住ctrl,alt,s是打开设置的快捷键，更多有关IDEA的操作今后会更新相关博文。 ) IDEA的Maven设置在Eclipse中用过Maven的都应该知道，这里是将项目的Maven换成我们自己安装的Maven，下面两个目录是选择Maven配置文件，不知道是什么原因在Eclipse 中选择了配置文件之后会自动的将Maven本地厂库的路径更改为你settings.xml中配置的路径。 既然这里没有自动选中那我们就手动修改即可，尽量不要放在C盘，一是用久之后本地厂库占用的空间会比较大，二是万一系统崩溃的话还有可能找回来。 修改pom.xml以下是我的pom.xml文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress MavenModelInspection --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.crossoverJie&lt;/groupId&gt; &lt;artifactId&gt;SSM&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;4.1.4.RELEASE&lt;/spring.version&gt; &lt;jackson.version&gt;2.5.0&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 使用SpringMVC需配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 关系型数据库整合时需配置 如hibernate jpa等 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql连接 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0-alpha-1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传文件 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; spring-mvc.xml这个配置文件是springMVC的配置文件：里面的我都写有注释，应该都能看懂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package=&quot;com.crossoverJie.controller&quot; /&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;!--&lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置拦截器 --&gt; &lt;!--&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &amp;lt;!&amp;ndash; &lt;mvc:mapping path=&quot;/**&quot;/&gt;拦截所有 &amp;ndash;&amp;gt; &lt;mvc:mapping path=&quot;/user/**&quot;/&gt; &lt;mvc:mapping path=&quot;/role/**&quot;/&gt; &lt;mvc:mapping path=&quot;/function/**&quot;/&gt; &lt;mvc:mapping path=&quot;/news/**&quot;/&gt; &lt;mvc:mapping path=&quot;/img/**&quot;/&gt; &lt;bean class=&quot;com.crossoverJie.intercept.Intercept&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;--&gt;&lt;/beans&gt; 关于上面拦截器注释掉的那里，配置是没有问题的，因为这是一个整合项目，所以里边也没有用到拦截器，为了防止运行报错所以就先注释掉了。 如果后续需要增加拦截器，可以参考这里的配置。 spring-mybatis.xml这个是spring和mybatis的整合配置文件，其中还有Druid连接池的配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;com.crossoverJie&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;!-- 指定连接数据库的驱动 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;3&quot; /&gt; &lt;property name=&quot;minIdle&quot; value=&quot;3&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &apos;x&apos;&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot; /&gt; &lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt; &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapping/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.crossoverJie.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 以上两个就是最重要的配置文件了，只要其中的包名和配置文件中的名字一样就不会出问题。关于xxMpper.xml以及实体类的生成，我们可以借助mybatis-generator自动生成工具来生成，方便快捷。 —- IDEA配置Tomcat关于Tomcat的下载与安装我这里就不多介绍了。按照下图选择：在name中为这个Tomcat输入一个名字。 之后选择你本地Tomcat的目录点击Ok即可。点击apply和保存之后就返回首页即可看到Tomcat的标识。根据需要点击Run和Debug即可运行。 运行结果如下：点击上图的2,3,4可看到不同用户的结果，如果你走到这一步，那么恭喜你整合成功。 Jdbc.properties12345jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3307/ssm?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password= mybatis-config.xml1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot; /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt; &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt; &lt;/settings&gt;&lt;/configuration&gt;]]></content>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网SSM到Spring Boot-从零开发校园商铺平台 o2o]]></title>
    <url>%2F2018%2F12%2F22%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E6%85%95%E8%AF%BE%E7%BD%91SSM%E5%88%B0Spring%20Boot-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA%E5%B9%B3%E5%8F%B0%20o2o%20%2F</url>
    <content type="text"><![CDATA[1.实体类解析与表的创建 $商品类别$： 1:商品类别的id 2:店铺id 3:商品类别的名称 4:商品类别的权重 5:商品创建时间 $详情图片：$ 1:详情图片的id 2.图片的地址 3.图片显示的权重 大靠前显示 4.创建时间 5.属于那个商品的详情图片（多对一）的关系 2 SprintBoot环境搭载2.1 maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.imooc.demo&lt;/groupId&gt; &lt;artifactId&gt;myo2o&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;myo2o Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;spring.version&gt;4.3.7.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 1.日志 --&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2.数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- DAO: MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3.Servlet web --&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4.Spring --&gt; &lt;!-- 1)Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2)Spring DAO层 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3)Spring web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4)Spring test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- redis客户端:Jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt; &lt;version&gt;1.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt; &lt;version&gt;1.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Map工具类 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/net.coobird/thumbnailator --&gt; &lt;dependency&gt; &lt;groupId&gt;net.coobird&lt;/groupId&gt; &lt;artifactId&gt;thumbnailator&lt;/artifactId&gt; &lt;version&gt;0.4.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- wechat相关 --&gt; &lt;!-- https://mvnrepository.com/artifact/net.sf.json-lib/json-lib --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.thoughtworks.xstream/xstream --&gt; &lt;dependency&gt; &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.4.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.dom4j/dom4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 二维码相关 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/javase --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;myo2o&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/projec ###2.2 环境搭建SSM jdbc.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/o2odb?useUnicode=true&amp;characterEncoding=utf8jdbc.username=WnplV/ietfQ=jdbc.password=TdixoQRe6Y0= logback.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;?xml version="1.0" encoding="utf-8" standalone="no"?&gt;&lt;configuration debug="false"&gt; &lt;appender name="INFO-FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;catalina.base&#125;/webapps/myo2o/logs/info/info.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;catalina.base&#125;/webapps/myo2o/logs/info/info.%d&#123;yyyy-MM-dd&#125;.%i.log.zip&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;1024MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;55&#125; - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name="ACCESS-FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt; $&#123;catalina.base&#125;/webapps/myo2o/logs/access/access.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;FileNamePattern&gt;$&#123;catalina.base&#125;/webapps/myo2o/logs/access/access.%d&#123;yyyy-MM-dd&#125;.%i.log.zip&lt;/FileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;1024MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;55&#125; - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name="com.imooc.myo2o" level="DEBUG" additivity="false"&gt; &lt;appender-ref ref="ACCESS-FILE" /&gt; &lt;/logger&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="INFO-FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt; mybatis-config.xml12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;!-- 打印查询语句 --&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;/settings&gt;&lt;/configuration&gt; redis.properties1234567redis.hostname=127.0.0.1redis.port=6379redis.database=0redis.pool.maxActive=600redis.pool.maxIdle=300redis.pool.maxWait=3000redis.pool.testOnBorrow=true weixin.properties12weixinappid=PTv/7qETW0kO5N0WT223IlBEOUuK0+SOweixinappsecret=jOjEubTD3dTzTbNzX+vREKnTJvvKZRud6c3712kCaGgfJAfVsP+M2w== web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1" metadata-complete="true"&gt; &lt;!-- 如果是用mvn命令生成的xml，需要修改servlet版本为3.1 --&gt; &lt;servlet&gt; &lt;!-- 生成图片的Servlet --&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt; &lt;!-- 是否有边框 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.border&lt;/param-name&gt; &lt;param-value&gt;no&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 字体颜色 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.font.color&lt;/param-name&gt; &lt;param-value&gt;red&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 图片宽度 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.image.width&lt;/param-name&gt; &lt;param-value&gt;135&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 使用哪些字符生成验证码 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.char.string&lt;/param-name&gt; &lt;param-value&gt;ACDEFHKPRSTWX345679&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 图片高度 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.image.height&lt;/param-name&gt; &lt;param-value&gt;50&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 字体大小 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.font.size&lt;/param-name&gt; &lt;param-value&gt;43&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 干扰线的颜色 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.noise.color&lt;/param-name&gt; &lt;param-value&gt;black&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 字符个数 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.char.length&lt;/param-name&gt; &lt;param-value&gt;4&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 使用哪些字体 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.font.names&lt;/param-name&gt; &lt;param-value&gt;Arial&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 映射的url --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;url-pattern&gt;/Kaptcha&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml Mybatis - &gt; spring -&gt; springmvc --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;!-- 默认匹配所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Springspring-dao.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置整合mybatis过程 --&gt; &lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;bean class="com.imooc.myo2o.util.EncryptPropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:redis.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="fileEncoding" value="UTF-8" /&gt; &lt;/bean&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name="maxPoolSize" value="30" /&gt; &lt;property name="minPoolSize" value="10" /&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name="autoCommitOnClose" value="false" /&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name="checkoutTimeout" value="10000" /&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name="acquireRetryAttempts" value="2" /&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.imooc.myo2o.entity" /&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml" /&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.imooc.myo2o.dao" /&gt; &lt;/bean&gt;&lt;/beans&gt; spring-redis.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxTotal" value="$&#123;redis.pool.maxActive&#125;" /&gt; &lt;property name="maxIdle" value="$&#123;redis.pool.maxIdle&#125;" /&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.pool.maxWait&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.pool.testOnBorrow&#125;" /&gt; &lt;/bean&gt; &lt;bean id="jedisWritePool" class="com.imooc.myo2o.cache.JedisPoolWriper" depends-on="jedisPoolConfig"&gt; &lt;constructor-arg index="0" ref="jedisPoolConfig" /&gt; &lt;constructor-arg index="1" value="$&#123;redis.hostname&#125;" /&gt; &lt;constructor-arg index="2" value="$&#123;redis.port&#125;" type="int" /&gt; &lt;/bean&gt; &lt;bean id="jedisKeys" class="com.imooc.myo2o.cache.JedisUtil$Keys" scope="singleton"&gt; &lt;constructor-arg ref="jedisUtil"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="jedisStrings" class="com.imooc.myo2o.cache.JedisUtil$Strings" scope="singleton"&gt; &lt;constructor-arg ref="jedisUtil"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="jedisLists" class="com.imooc.myo2o.cache.JedisUtil$Lists" scope="singleton"&gt; &lt;constructor-arg ref="jedisUtil"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="jedisSets" class="com.imooc.myo2o.cache.JedisUtil$Sets" scope="singleton"&gt; &lt;constructor-arg ref="jedisUtil"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="jedisHash" class="com.imooc.myo2o.cache.JedisUtil$Hash" scope="singleton"&gt; &lt;constructor-arg ref="jedisUtil"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="jedisUtil" class="com.imooc.myo2o.cache.JedisUtil" scope="singleton"&gt; &lt;property name="jedisPool"&gt; &lt;ref bean="jedisWritePool" /&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; spring-service.xml123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="com.imooc.myo2o.service" /&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt; spring -web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解模式 --&gt; &lt;!-- 简化配置： (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用"/"做整体映射 --&gt; &lt;mvc:resources mapping="/resources/**" location="/resources/" /&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 3.定义视图解析器 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/html/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".html"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 文件上传解析器 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="utf-8"&gt;&lt;/property&gt; &lt;property name="maxUploadSize" value="10485760000"&gt;&lt;/property&gt;&lt;!-- 最大上传文件大小 --&gt; &lt;property name="maxInMemorySize" value="10960"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 在spring-mvc.xml文件中加入这段配置后，spring返回给页面的都是utf-8编码了 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package="com.imooc.myo2o.web" /&gt; &lt;!-- 5.权限拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/shop/**" /&gt; &lt;mvc:exclude-mapping path="/shop/ownerlogin" /&gt; &lt;mvc:exclude-mapping path="/shop/ownerlogincheck" /&gt; &lt;mvc:exclude-mapping path="/shop/logout" /&gt; &lt;mvc:exclude-mapping path="/shop/register" /&gt; &lt;bean id="ShopInterceptor" class="com.imooc.myo2o.interceptor.shop.ShopLoginInterceptor" /&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/shop/**" /&gt; &lt;mvc:exclude-mapping path="/shop/ownerlogin" /&gt; &lt;mvc:exclude-mapping path="/shop/ownerlogincheck" /&gt; &lt;mvc:exclude-mapping path="/shop/register" /&gt; &lt;!-- shoplist page --&gt; &lt;mvc:exclude-mapping path="/shop/shoplist" /&gt; &lt;mvc:exclude-mapping path="/shop/logout" /&gt; &lt;mvc:exclude-mapping path="/shop/list" /&gt; &lt;!-- changepsw page --&gt; &lt;mvc:exclude-mapping path="/shop/changepsw" /&gt; &lt;mvc:exclude-mapping path="/shop/changelocalpwd" /&gt; &lt;!-- ownerbind page --&gt; &lt;mvc:exclude-mapping path="/shop/ownerbind" /&gt; &lt;mvc:exclude-mapping path="/shop/bindlocalauth" /&gt; &lt;!-- shopmanage page --&gt; &lt;mvc:exclude-mapping path="/shop/shopmanage" /&gt; &lt;!-- shopedit page --&gt; &lt;mvc:exclude-mapping path="/shop/shopedit" /&gt; &lt;mvc:exclude-mapping path="/shop/getshopbyid" /&gt; &lt;mvc:exclude-mapping path="/shop/getshopinitinfo" /&gt; &lt;mvc:exclude-mapping path="/shop/registershop" /&gt; &lt;bean id="ShopPermissionInterceptor" class="com.imooc.myo2o.interceptor.shop.ShopPermissionInterceptor" /&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/superadmin/**" /&gt; &lt;mvc:exclude-mapping path="/superadmin/login" /&gt; &lt;mvc:exclude-mapping path="/superadmin/logincheck" /&gt; &lt;mvc:exclude-mapping path="/superadmin/main" /&gt; &lt;mvc:exclude-mapping path="/superadmin/top" /&gt; &lt;bean id="SuperAdminInterceptor" class="com.imooc.myo2o.interceptor.superadmin.SuperAdminLoginInterceptor" /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; 3 SpringBoot整合SSM项目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# mybatis#1 domain POJO entity 层 就是实体类mybatis.type-aliases-package=com.imooc.o2o.o2o.domainmybatis.configuration.map-underscore-to-camel-case=truemybatis.configuration.default-fetch-size=100mybatis.configuration.default-statement-timeout=3000mybatis.mapperLocations=classpath:mapperxml/*.xml# druidspring.datasource.url=jdbc:mysql://localhost:3306/o2o?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=YHP836143#spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.filters=statspring.datasource.maxActive=2spring.datasource.initialSize=1spring.datasource.maxWait=60000spring.datasource.minIdle=1spring.datasource.timeBetweenEvictionRunsMillis=60000spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=select &apos;x&apos;spring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=falsespring.datasource.poolPreparedStatements=truespring.datasource.maxOpenPreparedStatements=20#thymeleaf startspring.thymeleaf.cache=falsespring.thymeleaf.servlet.content-type=text/html#spring.thymeleaf.servlet.content-type=text/htmlspring.thymeleaf.enabled=truespring.thymeleaf.encoding=UTF-8spring.thymeleaf.mode=HTML5spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.html#Redis的相关配置#spring.redis.database=1#spring.redis.host=127.0.0.1#spring.redis.port=6379#spring.redis.password=#spring.redis.lettuce.pool.max-active=8#spring.redis.lettuce.pool.max-wait=-1#spring.redis.lettuce.pool.max-idle=8#spring.redis.lettuce.pool.min-idle=0#dubbo的配置#dubbo.application.name=taotaomall#dubbo.registry.address=94.191.24.33:2181#dubbo.registry.protocol=zookeeper#dubbo.protocol.name=dubbo#dubbo.monitor.protocol=registry#dubbo.protocol.port=2181 4 项目1.0开发 店铺注册功能模块 4.1新增加店铺跟新店铺开发 dao层 12 //1 开发功能1 新增店铺int insert(TbShop record); xml 123456789101112131415161718&lt;insert id=&quot;insert&quot; keyColumn=&quot;shop_id&quot; keyProperty=&quot;shopId&quot; parameterType=&quot;com.imooc.o2o.o2o.domain.TbShop&quot; useGeneratedKeys=&quot;true&quot;&gt; &lt;!-- WARNING - @mbg.generated This element is automatically generated by MyBatis Generator, do not modify. --&gt; insert into tb_shop (owner_id, area_id, shop_category_id, parent_category_id, shop_name, shop_desc, shop_addr, phone, shop_img, longitude, latitude, priority, create_time, last_edit_time, enable_status, advice) values (#&#123;ownerId,jdbcType=INTEGER&#125;, #&#123;areaId,jdbcType=INTEGER&#125;, #&#123;shopCategoryId,jdbcType=INTEGER&#125;, #&#123;parentCategoryId,jdbcType=INTEGER&#125;, #&#123;shopName,jdbcType=VARCHAR&#125;, #&#123;shopDesc,jdbcType=VARCHAR&#125;, #&#123;shopAddr,jdbcType=VARCHAR&#125;, #&#123;phone,jdbcType=VARCHAR&#125;, #&#123;shopImg,jdbcType=VARCHAR&#125;, #&#123;longitude,jdbcType=DOUBLE&#125;, #&#123;latitude,jdbcType=DOUBLE&#125;, #&#123;priority,jdbcType=INTEGER&#125;, #&#123;createTime,jdbcType=TIMESTAMP&#125;, #&#123;lastEditTime,jdbcType=TIMESTAMP&#125;, #&#123;enableStatus,jdbcType=INTEGER&#125;, #&#123;advice,jdbcType=VARCHAR&#125;) &lt;/insert&gt; 1int updateByPrimaryKeySelective(TbShop record); 1234567891011/** * update tb_shop * &lt;set&gt; * &lt;if test="ownerId != null"&gt; * owner_id = #&#123;ownerId,jdbcType=INTEGER&#125;, * area_id = #&#123;areaId,jdbcType=INTEGER&#125;, * &lt;/if&gt; * &lt;if test="shopCategoryId != null"&gt; * &lt;/set&gt; * where shop_id = #&#123;shopId,jdbcType=INTEGER&#125; */ 4.2 Thumbnailator图片处理和封装Util 1234567&lt;!-- https://mvnrepository.com/artifact/net.coobird/thumbnailator --&gt;---&lt;dependency&gt; &lt;groupId&gt;net.coobird&lt;/groupId&gt; &lt;artifactId&gt;thumbnailator&lt;/artifactId&gt; &lt;version&gt;0.4.8&lt;/version&gt;&lt;/dependency&gt; https://github.com/coobird/thumbnailator/wiki/Examples 123Thumbnails.of(new File("original.jpg")) .size(160, 160) .toFile(new File("thumbnail.jpg")); 123456Thumbnails.of(new File(&quot;original.jpg&quot;)) .size(160, 160) .rotate(90) .watermark(Positions.BOTTOM_RIGHT, ImageIO.read(new File(&quot;watermark.png&quot;)), 0.5f) .outputQuality(0.8) .toFile(new File(&quot;image-with-watermark.jpg&quot;)); 5 thumbnails图像处理库的使用 imageUtils 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.imooc.o2o.o2o.util;import java.io.File;import java.io.IOException;import java.util.ArrayList;import java.util.List;import net.coobird.thumbnailator.Thumbnails;import org.springframework.web.multipart.commons.CommonsMultipartFile;//https://www.jianshu.com/p/04d04afc34fd简书public class ImageUtil &#123; public static String generateThumbnail(CommonsMultipartFile thumbnail, String targetAddr) &#123; String realFileName = FileUtil.getRandomFileName(); String extension = getFileExtension(thumbnail); makeDirPath(targetAddr); String relativeAddr = targetAddr + realFileName + extension; File dest = new File(FileUtil.getImgBasePath() + relativeAddr); try &#123; Thumbnails.of(thumbnail.getInputStream()).size(200, 200).outputQuality(0.25f).toFile(dest); &#125; catch (IOException e) &#123; throw new RuntimeException("创建缩略图失败：" + e.toString()); &#125; return relativeAddr; &#125; public static String generateNormalImg(CommonsMultipartFile thumbnail, String targetAddr) &#123; String realFileName = FileUtil.getRandomFileName(); String extension = getFileExtension(thumbnail); makeDirPath(targetAddr); String relativeAddr = targetAddr + realFileName + extension; File dest = new File(FileUtil.getImgBasePath() + relativeAddr); try &#123; Thumbnails.of(thumbnail.getInputStream()).size(337, 640).outputQuality(0.5f).toFile(dest); &#125; catch (IOException e) &#123; throw new RuntimeException("创建缩略图失败：" + e.toString()); &#125; return relativeAddr; &#125; public static List&lt;String&gt; generateNormalImgs(List&lt;CommonsMultipartFile&gt; imgs, String targetAddr) &#123; int count = 0; List&lt;String&gt; relativeAddrList = new ArrayList&lt;String&gt;(); if (imgs != null &amp;&amp; imgs.size() &gt; 0) &#123; makeDirPath(targetAddr); for (CommonsMultipartFile img : imgs) &#123; String realFileName = FileUtil.getRandomFileName(); String extension = getFileExtension(img); String relativeAddr = targetAddr + realFileName + count + extension; File dest = new File(FileUtil.getImgBasePath() + relativeAddr); count++; try &#123; Thumbnails.of(img.getInputStream()).size(600, 300).outputQuality(0.5f).toFile(dest); &#125; catch (IOException e) &#123; throw new RuntimeException("创建图片失败：" + e.toString()); &#125; relativeAddrList.add(relativeAddr); &#125; &#125; return relativeAddrList; &#125; //* 目标路径文件夹不存在就创建 private static void makeDirPath(String targetAddr) &#123; String realFileParentPath = FileUtil.getImgBasePath() + targetAddr; File dirPath = new File(realFileParentPath); if (!dirPath.exists()) &#123; dirPath.mkdirs(); &#125; &#125; //* 获取输入文件流的扩展名 private static String getFileExtension(CommonsMultipartFile cFile) &#123; String originalFileName = cFile.getOriginalFilename(); return originalFileName.substring(originalFileName.lastIndexOf(".")); &#125;//&#125;&#125; FileUtil 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.imooc.o2o.o2o.util;import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Random;public class FileUtil &#123; private static String seperator = System.getProperty("file.separator"); private static final SimpleDateFormat sDateFormat = new SimpleDateFormat( "yyyyMMddHHmmss"); // 时间格式化的格式 private static final Random r = new Random(); public static String getImgBasePath() &#123; String os = System.getProperty("os.name"); String basePath = ""; if (os.toLowerCase().startsWith("win")) &#123; basePath = "D:/projectdev/image/"; &#125; else &#123; basePath = "/home/xiangzepro/"; &#125; basePath = basePath.replace("/", seperator); return basePath; &#125; public static String getHeadLineImagePath() &#123; String headLineImagePath = "/upload/images/item/headtitle/"; headLineImagePath = headLineImagePath.replace("/", seperator); return headLineImagePath; &#125; public static String getShopCategoryImagePath() &#123; String shopCategoryImagePath = "/upload/images/item/shopcategory/"; shopCategoryImagePath = shopCategoryImagePath.replace("/", seperator); return shopCategoryImagePath; &#125; // public static String getPersonInfoImagePath() &#123; String personInfoImagePath = "/upload/images/item/personinfo/"; personInfoImagePath = personInfoImagePath.replace("/", seperator); return personInfoImagePath; &#125; public static String getShopImagePath(long shopId) &#123; StringBuilder shopImagePathBuilder = new StringBuilder(); shopImagePathBuilder.append("/upload/images/item/shop/"); shopImagePathBuilder.append(shopId); shopImagePathBuilder.append("/"); String shopImagePath = shopImagePathBuilder.toString().replace("/", seperator); return shopImagePath; &#125; // public static String getRandomFileName() &#123; // 生成随机文件名：当前年月日时分秒+五位随机数（为了在实际项目中防止文件同名而进行的处理） int rannum = (int) (r.nextDouble() * (99999 - 10000 + 1)) + 10000; // 获取随机数 String nowTimeStr = sDateFormat.format(new Date()); // 当前时间 return nowTimeStr + rannum; &#125; // public static void deleteFile(String storePath) &#123; File file = new File(getImgBasePath() + storePath); if (file.exists()) &#123; if (file.isDirectory()) &#123; File files[] = file.listFiles(); for (int i = 0; i &lt; files.length; i++) &#123; files[i].delete(); &#125; &#125; file.delete(); &#125; &#125;&#125; https://www.jianshu.com/p/04d04afc34fd. 6 Dto的开发123456789101112131415161718192021222324252627282930313233343536public class ShopExcution &#123; //结果状态 private int state; //状态标识 private String stateInfo; //店铺的数量 private int count; //操作的shop(增删改查店铺的时候用到) private TbShop tbShop; //shop列表（查询店铺列表的时候使用） private List&lt;TbShop&gt; shopList; public ShopExcution() &#123; &#125; //构造方法 传入两个参数 //店铺操作失败的时候 用的构造方法 public ShopExcution(ShopStateEnum stateEnum) &#123; this.state = stateEnum.getState(); this.stateInfo = stateEnum.getStateInfo(); &#125; //店铺成功的时候所用的构造方法 成功才能返回店铺信息 public ShopExcution(ShopStateEnum stateEnum, TbShop tbShop) &#123; this.state = stateEnum.getState(); this.stateInfo = stateEnum.getStateInfo(); this.tbShop = tbShop; &#125; //店铺成功的时候所用的构造方法 成功才能返回店铺信息tbListShop public ShopExcution(ShopStateEnum stateEnum, List&lt;TbShop&gt; tbShopList) &#123; this.state = stateEnum.getState(); this.stateInfo = stateEnum.getStateInfo(); this.shopList = tbShopList; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public enum ShopStateEnum &#123; //枚举里面的参数 就是定义的成员变量的值 CHECK(0, "审核中"), OFFLINE(-1, "非法商铺"), SUCCESS(1, "操作成功"), PASS(2, "通过认证"), INNER_ERROR(-1001, "操作失败"), NULL_SHOPID(-1002, "ShopId为空"), NULL_SHOP_INFO(-1003, "传入了空的信息"); private int state; private String stateInfo; private ShopStateEnum(int state, String stateInfo) &#123; this.state = state; this.stateInfo = stateInfo; &#125; public int getState() &#123; return state; &#125; public String getStateInfo() &#123; return stateInfo; &#125; //依据传入的state返回相应的enum值 public static ShopStateEnum stateOf(int index) &#123; //这个方法会返回包括所有枚举变量的数组。在该例中，返回的就是包含了七个星期的Weekday[]。可以方便的用来做循环。 //index =state state的值已经定义好了 for (ShopStateEnum stateEnum : ShopStateEnum.values()) &#123; if (stateEnum.getState() == index) return stateEnum; &#125; return null; &#125; 7 Service层的开发—添加店铺 和店铺图片12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class ShopServiceImpl implements ShopService &#123; private TbShopMapper tbShopMapper; @Override @Transactional public ShopExcution addShop(TbShop tbShop, CommonsMultipartFile ShopImg) &#123; //空值判断 if (tbShop == null) &#123; //调用了ShopStateExcution失败的方法 返回枚举里面的数据 //ShopStateEnum.NULL_SHOP_INFO=(-1003, "传入了空的信息") return new ShopExcution(ShopStateEnum.NULL_SHOP_INFO); &#125; //给店铺信息赋初始值 tbShop.setEnableStatus(0); tbShop.setCreateTime(new Date()); tbShop.setLastEditTime(new Date()); /* tbShopMapper :int insert(TbShop record);属性 insert into tb_shop (owner_id, area_id, shop_category_id,...)values=#&#123;...&#125; */ //添加店铺信息 int effectedNum = tbShopMapper.insert(tbShop); if (effectedNum &lt;= 0) &#123; throw new RuntimeException("店铺创建失败"); &#125; //店铺添加成功 else &#123; //存储图片 if (ShopImg != null) &#123; addShopImg(tbShop, ShopImg);//根据tbShop里面的id存储图片 更新图片 //更新店铺的图片地址 只更新一个字段吗？？？？ effectedNum = tbShopMapper.updateByPrimaryKeySelective(tbShop); if (effectedNum &lt;= 0) &#123; throw new RuntimeException("店铺更新图片地址失败"); &#125; &#125; &#125; return new ShopExcution(ShopStateEnum.CHECK, tbShop); &#125; //添加店铺图片 ⭐️⭐️⭐️⭐️⭐️⭐️ private void addShopImg(TbShop tbShop, CommonsMultipartFile shopImg) &#123; //1 获取Shop图片目录的相对值路径 /** * public static String getShopImagePath(long shopId) &#123; * StringBuilder shopImagePathBuilder = new StringBuilder(); * shopImagePathBuilder.append("/upload/images/item/shop/"); * shopImagePathBuilder.append(shopId); * shopImagePathBuilder.append("/"); * String shopImagePath = shopImagePathBuilder.toString().replace("/", * seperator); * return shopImagePath; * &#125; */ String shopImagePath = FileUtil.getShopImagePath(tbShop.getShopId()); //2 存储图片返回相对子路径 imageUtil /** * public static String generateThumbnail(CommonsMultipartFile thumbnail, String targetAddr) &#123; * String realFileName = FileUtil.getRandomFileName(); * String extension = getFileExtension(thumbnail); * makeDirPath(targetAddr); * String relativeAddr = targetAddr + realFileName + extension; * File dest = new File(FileUtil.getImgBasePath() + relativeAddr); * try &#123; * Thumbnails.of(thumbnail.getInputStream()).size(200, 200).outputQuality(0.25f).toFile(dest); * &#125; catch (IOException e) &#123; * throw new RuntimeException("创建缩略图失败：" + e.toString()); * &#125; * return relativeAddr; * &#125;* 对图片进行压缩并加水印 * //https://www.jianshu.com/p/04d04afc34fd简书 */ String shopImgAddr = ImageUtil.generateThumbnail(shopImg, shopImagePath); tbShop.setShopImg(shopImgAddr); &#125;&#125; 12345public class ShopOperationException extends RuntimeException &#123; public ShopOperationException(String msg) &#123; super(msg); &#125;&#125; 8 店铺注册功能Controller层的实现 ⭐️ ⭐️ ⭐️12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//实现店铺管理相关的逻辑店铺注册功能Controller层的实现//先从前端拿到字段 然后注册到数据库里面@Controller@RequestMapping("/shopadmin")public class ShopManagementController &#123; @Autowired private ShopServiceImpl shopService; @RequestMapping("/registershop") @ResponseBody public Map&lt;String, Object&gt; registerShop(HttpServletRequest request) throws IOException &#123; Map&lt;String, Object&gt; modelMap = new HashMap&lt;&gt;(); //1 接受并转化相应的参数 包括店铺信息以及图片信息 解析request的参数 //就是 request.getParameter(name); String shopStr = HttpServletRequestUtil.getString(request, "shopStr"); ObjectMapper mapper = new ObjectMapper(); TbShop tbShop = null; try &#123; //将字符串转为实体类 tbShop = mapper.readValue(shopStr, TbShop.class); &#125; catch (Exception e) &#123; modelMap.put("scuuess", false); modelMap.put("errMsg", e.getMessage()); return modelMap; &#125; //2 接受图片 CommonsMultipartFile shopImg = null; CommonsMultipartResolver commonsMultipartResolver = new CommonsMultipartResolver( request.getSession().getServletContext()); if (commonsMultipartResolver.isMultipart(request)) &#123; MultipartHttpServletRequest multipartHttpServletRequest = (MultipartHttpServletRequest) request; shopImg = (CommonsMultipartFile) multipartHttpServletRequest.getFile("shopImg"); &#125; else &#123; modelMap.put("success", false); modelMap.put("errMsg", "图片上传不能为空"); return modelMap; &#125; //2 注册店铺 if (tbShop != null &amp;&amp; shopImg != null) &#123; TbPersonInfo tbPersonInfo = new TbPersonInfo(); tbPersonInfo.setUserId(1); tbShop.setOwner(tbPersonInfo); //添加shopService ShopExcution shopExcution = shopService.addShop(tbShop, shopImg); if (shopExcution.getState() == ShopStateEnum.CHECK.getState()) &#123; modelMap.put("success", true); return modelMap; &#125; else &#123; modelMap.put("success", false); modelMap.put("errMsg", shopExcution.getState()); return modelMap; &#125; &#125; else &#123; modelMap.put("success", false); modelMap.put("errMsg", "图片上传不能为空"); return modelMap; &#125; &#125; 1 HttpServletRequestUtils12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import javax.servlet.http.HttpServletRequest;public class HttpServletRequestUtil &#123; public static int getInt(HttpServletRequest request, String name) &#123; try &#123; return Integer.decode(request.getParameter(name)); &#125; catch (Exception e) &#123; return -1; &#125; &#125; public static long getLong(HttpServletRequest request, String name) &#123; try &#123; return Long.valueOf(request.getParameter(name)); &#125; catch (Exception e) &#123; return -1; &#125; &#125; public static Double getDouble(HttpServletRequest request, String name) &#123; try &#123; return Double.valueOf(request.getParameter(name)); &#125; catch (Exception e) &#123; return -1d; &#125; &#125; public static Boolean getBoolean(HttpServletRequest request, String name) &#123; try &#123; return Boolean.valueOf(request.getParameter(name)); &#125; catch (Exception e) &#123; return false; &#125; &#125; public static String getString(HttpServletRequest request, String name) &#123; try &#123; String result = request.getParameter(name); if (result != null) &#123; result = result.trim(); &#125; if ("".equals(result)) result = null; return result; &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; Jackson之jackson-databind https://blog.csdn.net/u011499747/article/details/78762007 CSDN 博客 https://github.com/FasterXML/jackson-databind Github官网API 123456789101112131415161718&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; POJO和JSON之间的转化 给出一个足够简单的POJO: 1234public class MyValue &#123; public String name; public int age;&#125; 注意:如果使用getters/setters的话，可以用private/protected修饰属性，这里直接用public修饰了，就不需要getters/setters了。 使用databind，我们需要一个最基础的对象com.fasterxml.jackson.databind.ObjectMapper，这里我们构造一个: 1ObjectMapper mapper = new ObjectMapper(); 注意:这个mapper是可以复用的，就好比HttpClient一样。 简单的把JSON反序列化成Object的用法如下 123456789MyValue value = mapper.readValue(new File("data.json"), MyValue.class);// or:value = mapper.readValue(new URL("http://www.dubby.cn/api/entry.json"), MyValue.class);// or:value = mapper.readValue("&#123;\"name\":\"Bob\", \"age\":13&#125;", MyValue.class);------------------- //将字符串转为实体类tbShop = mapper.readValue(shopStr, TbShop.class); 简单的把Object序列化成JSON的用法如下: 12345mapper.writeValue(new File("result.json"), myResultObject);// or:byte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);// or:String jsonString = mapper.writeValueAsString(myResultObject); 可以从Jackson-docs存储库中找到更全面的文档; 以及来自该项目的Wiki。但这里有简要的介绍性教程，建议阅读顺序。 1分钟教程：POJO到JSON并返回最常见的用法是使用JSON，并从中构造一个Plain Old Java Object（“POJO”）。那么让我们从那里开始。简单的2属性POJO像这样： 123456//注意：也可以使用getter / setter; 这里我们直接使用公共字段：public class MyValue &#123; public String name; 公共 INT年龄; //注意：如果使用getter / setter，可以保留字段`protected`或`private` &#125; 我们需要一个com.fasterxml.jackson.databind.ObjectMapper用于所有数据绑定的实例，所以让我们构造一个： 1ObjectMapper mapper = new ObjectMapper（）; //创建一次，重用 默认实例适合我们使用 - 稍后我们将了解如何在必要时配置映射器实例。用法很简单： 12345MyValue值= mapper 。readValue（新 文件（“ data.json ”），myvalue的。类）;//或： value = mapper 。readValue（新 URL（“ http://some.com/api/entry.json ”），MyValue 。类）;//或： value = mapper 。readValue（“ &#123; \” name \“：\” Bob \“，\ “年龄\”：13&#125; “， myvalue的。类）; 如果我们想写JSON，我们会做相反的事情： 12345映射器。writeValue（新 文件（“ result.json ”），myResultObject）;//或：byte [] jsonBytes = mapper 。writeValueAsBytes（myResultObject）;//或：String jsonString = mapper 。writeValueAsString（myResultObject）; 到现在为止还挺好？ 3分钟教程：通用集合，树模型除了处理简单的Bean风格的POJO之外，您还可以处理JDK List，Maps： 12345Map &lt; String，Integer &gt; scoreByName = mapper 。readValue（jsonSource，Map 。类）;List &lt; String &gt; names = mapper 。readValue（jsonSource，列表。类）;//显然可以写出 mapper。writeValue（ new File（ “ names.json ”），names）; 只要JSON结构匹配，类型就很简单。如果您有POJO值，则需要指明实际类型（注意：对于具有Listetc类型的POJO属性，这不是必需的）： 123Map &lt; String，ResultValue &gt; results = mapper 。readValue（jsonSource， 新 TypeReference &lt; 地图&lt; 字符串，ResultValue &gt; &gt;（）&#123;&#125;）;//为什么要额外工作？Java Type Erasure否则会阻止类型检测 （注意：无论通用类型如何，序列化都不需要额外的努力） 可是等等！还有更多！ 虽然处理Maps，Lists和其他“简单”对象类型（字符串，数字，布尔值）可能很简单，但对象遍历可能很麻烦。这就是Jackson’s Tree模型可以派上用场的地方： 1234567891011121314151617//可以读作通用的JsonNode，如果它可以是Object或Array; 或者，//如果已知为Object，则为ObjectNode，如果是array，ArrayNode等：ObjectNode root = mapper。readTree（ “ stuff.json ”）;字符串名称 = root。得到（ “名字”）。asText（）;int age = root。得到（ “年龄”）。asInt中（）;//也可以修改：这会将子对象添加为属性&apos;other&apos;，设置属性&apos; type&apos;root。与（ “其他”）。put（ “ type ”， “ student ”）;String json = mapper。writeValueAsString（根）;//与上面一样，我们最终得到像&apos;json&apos;字符串：// &#123; // “name”：“Bob”，“age”：13，// “other”：&#123; // “type”：“学生“ // &#125; // &#125; 树模型比数据绑定更方便，特别是在结构高度动态或不能很好地映射到Java类的情况下 SpringMVC 图片上传操作待定1234567891011CommonsMultipartFile shopImg = null; CommonsMultipartResolver commonsMultipartResolver = new CommonsMultipartResolver( request.getSession().getServletContext()); if (commonsMultipartResolver.isMultipart(request)) &#123; MultipartHttpServletRequest multipartHttpServletRequest = (MultipartHttpServletRequest) request; shopImg = (CommonsMultipartFile) multipartHttpServletRequest.getFile(&quot;shopImg&quot;); &#125; else &#123; modelMap.put(&quot;success&quot;, false); modelMap.put(&quot;errMsg&quot;, &quot;图片上传不能为空&quot;); return modelMap; &#125; 9 SUIMobile http://m.sui.taobao.org/ http://m.sui.taobao.org/getting-started/ 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;我的生活&lt;/title&gt; &lt;meta name="viewport" content="initial-scale=1, maximum-scale=1"&gt; &lt;link rel="shortcut icon" href="/favicon.ico"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;link rel="stylesheet" href="//g.alicdn.com/msui/sm/0.6.2/css/sm.min.css"&gt; &lt;link rel="stylesheet" href="//g.alicdn.com/msui/sm/0.6.2/css/sm-extend.min.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="page-group"&gt; &lt;div class="page page-current"&gt; &lt;!-- 你的html代码 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type='text/javascript' src='//g.alicdn.com/sj/lib/zepto/zepto.min.js' charset='utf-8'&gt;&lt;/script&gt; &lt;script type='text/javascript' src='//g.alicdn.com/msui/sm/0.6.2/js/sm.min.js' charset='utf-8'&gt;&lt;/script&gt; &lt;script type='text/javascript' src='//g.alicdn.com/msui/sm/0.6.2/js/sm-extend.min.js' charset='utf-8'&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 店铺注册之JS 实现 1 10 店铺类别区域信息的获取123public interface ShopService &#123; ShopExcution addShop(TbShop tbShop, CommonsMultipartFile ShopImg);&#125; 1234public interface ShopCategoryService &#123; //查询TbShopCategory List&lt;TbShopCategory&gt; findAllByParentIdAndShopCategoryId(TbShopCategory tbShopCategoryCondition);&#125; 123 //查询 TbShopCategory 用mybatispluginshelp2.4开发升级的 //4-8店铺类别区域信息的获取List&lt;TbShopCategory&gt; findAllByParentIdAndShopCategoryId(@Param("TbShopCategoryCondition") TbShopCategory TbShopCategoryCondition); 12345678&lt;select id="findAllByParentIdAndShopCategoryId" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List"/&gt; from tb_shop_category where parent_id=#&#123;TbShopCategoryCondition.parent.shopCategoryId&#125; ORDER BY priority DESC &lt;/select&gt; 1234567891011121314151617181920Controller层的实现private Map&lt;String, Object&gt; getShopInitInfo(Integer id) &#123;// Map&lt;String, Object&gt; modelMap = new HashMap&lt;String, Object&gt;();// List&lt;TbShopCategory&gt; shopCategoryList = new ArrayList&lt;TbShopCategory&gt;();// List&lt;TbArea&gt; areaList = new ArrayList&lt;TbArea&gt;();// try &#123;// shopCategoryList = shopCategoryService// .getShopCategoryList(id);//// areaList = areaService.getAreaList();// &#125; catch (Exception e) &#123;// modelMap.put("success", false);// modelMap.put("errMsg", e.toString());// &#125;// modelMap.put("shopCategoryList", shopCategoryList);// modelMap.put("areaList", areaList);// modelMap.put("success", true);//// return modelMap;// &#125; 11 AreaService123456public interface AreaService &#123; @Servicepublic interface AreaService &#123; List&lt;TbArea&gt; findAllArea();&#125; 12345678910@Servicepublic class AreaServiceImpl implements AreaService &#123; @Autowired private TbAreaMapper tbAreaMapper; @Override public List&lt;TbArea&gt; findAllArea() &#123; return tbAreaMapper.findAll(); &#125;&#125; 12AreaController123456789101112131415161718192021@Controller@RequestMapping("/superadmin")public class AreaContorller &#123; @Autowired private AreaService areaService; @RequestMapping("/listarea") public Map&lt;String, Object&gt; listArea() &#123; Map&lt;String, Object&gt; modelMap = new HashMap&lt;String, Object&gt;(); List&lt;TbArea&gt; allArea = new ArrayList&lt;TbArea&gt;(); try &#123; allArea = areaService.findAllArea(); modelMap.put("rows", allArea); modelMap.put("total", allArea.size()); &#125; catch (Exception e) &#123; modelMap.put("success", false); modelMap.put("errMsg", e.toString()); &#125; return modelMap; &#125;&#125; #13使用 SpringBoot + kaptcha 生成、校对 验证码 https://blog.csdn.net/larger5/article/details/79522105 https://www.jianshu.com/p/1f2f7c47e812 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012、pom（SpringBoot+thymeleaf+web+kaptcha ） 注意引入 kaptcha 的 Maven 依赖 &lt;!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; 3、KaptchaConfig即 kaptcha 的配置文件package com.cun.conf;import java.util.Properties;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;import com.google.code.kaptcha.impl.DefaultKaptcha;import com.google.code.kaptcha.util.Config;@Componentpublic class KaptchaConfig &#123; @Bean public DefaultKaptcha getDefaultKaptcha() &#123; com.google.code.kaptcha.impl.DefaultKaptcha defaultKaptcha = new com.google.code.kaptcha.impl.DefaultKaptcha(); Properties properties = new Properties(); // 图片边框 properties.setProperty("kaptcha.border", "yes"); // 边框颜色 properties.setProperty("kaptcha.border.color", "105,179,90"); // 字体颜色 properties.setProperty("kaptcha.textproducer.font.color", "red"); // 图片宽 properties.setProperty("kaptcha.image.width", "110"); // 图片高 properties.setProperty("kaptcha.image.height", "40"); // 字体大小 properties.setProperty("kaptcha.textproducer.font.size", "30"); // session key properties.setProperty("kaptcha.session.key", "code"); // 验证码长度 properties.setProperty("kaptcha.textproducer.char.length", "4"); // 字体 properties.setProperty("kaptcha.textproducer.font.names", "宋体,楷体,微软雅黑"); Config config = new Config(properties); defaultKaptcha.setConfig(config); return defaultKaptcha; &#125;&#125; 4、KaptchaController验证码控制层package com.cun.controller;import java.awt.image.BufferedImage;import java.io.ByteArrayOutputStream;import javax.imageio.ImageIO;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.google.code.kaptcha.impl.DefaultKaptcha;@Controllerpublic class KaptchaController &#123; /** * 1、验证码工具 */ @Autowired DefaultKaptcha defaultKaptcha; /** * 2、生成验证码 * @param httpServletRequest * @param httpServletResponse * @throws Exception */ @RequestMapping("/defaultKaptcha") public void defaultKaptcha(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; byte[] captchaChallengeAsJpeg = null; ByteArrayOutputStream jpegOutputStream = new ByteArrayOutputStream(); try &#123; // 生产验证码字符串并保存到session中 String createText = defaultKaptcha.createText(); httpServletRequest.getSession().setAttribute("rightCode", createText); // 使用生产的验证码字符串返回一个BufferedImage对象并转为byte写入到byte数组中 BufferedImage challenge = defaultKaptcha.createImage(createText); ImageIO.write(challenge, "jpg", jpegOutputStream); &#125; catch (IllegalArgumentException e) &#123; httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND); return; &#125; // 定义response输出类型为image/jpeg类型，使用response输出流输出图片的byte数组 captchaChallengeAsJpeg = jpegOutputStream.toByteArray(); httpServletResponse.setHeader("Cache-Control", "no-store"); httpServletResponse.setHeader("Pragma", "no-cache"); httpServletResponse.setDateHeader("Expires", 0); httpServletResponse.setContentType("image/jpeg"); ServletOutputStream responseOutputStream = httpServletResponse.getOutputStream(); responseOutputStream.write(captchaChallengeAsJpeg); responseOutputStream.flush(); responseOutputStream.close(); &#125; /** * 3、校对验证码 * @param httpServletRequest * @param httpServletResponse * @return */ @RequestMapping("/imgvrifyControllerDefaultKaptcha") public ModelAndView imgvrifyControllerDefaultKaptcha(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) &#123; ModelAndView andView = new ModelAndView(); String rightCode = (String) httpServletRequest.getSession().getAttribute("rightCode"); String tryCode = httpServletRequest.getParameter("tryCode"); System.out.println("rightCode:"+rightCode+" ———— tryCode:"+tryCode); if (!rightCode.equals(tryCode)) &#123; andView.addObject("info", "错误的验证码"); andView.setViewName("index"); &#125; else &#123; andView.addObject("info", "登录成功"); andView.setViewName("success"); &#125; return andView; &#125; @RequestMapping("/toIndex") public String toIndex() &#123; return "index"; &#125;&#125; 5、application.yml SpringBoot 核心配置文件server: port: 80 context-path: / 6、主界面 index.html&lt;!DOCTYPE html&gt;&lt;!-- thymeleaf 提示功能 --&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head lang="en"&gt;&lt;meta charset="UTF-8"&gt;&lt;/meta&gt;&lt;title&gt;hello&lt;/title&gt;&lt;!-- 引入BootStrap --&gt;&lt;link rel="stylesheet" href="../bootstrap3/css/bootstrap-theme.min.css" /&gt;&lt;link rel="stylesheet" href="../bootstrap3/css/bootstrap.min.css" /&gt;&lt;script type="text/javascript" src="../bootstrap3/js/jquery-1.11.2.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../bootstrap3/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;style type="text/css"&gt;body &#123; padding: 10px&#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 提示 --&gt; &lt;h3 th:text="$&#123;info&#125;"&gt;&lt;/h3&gt; &lt;div&gt; &lt;!-- 后面添加参数起到清除缓存作用 --&gt; &lt;img alt="验证码" onclick="this.src='/defaultKaptcha?d='+new Date()*1" src="/defaultKaptcha" /&gt; &lt;/div&gt; &lt;form action="imgvrifyControllerDefaultKaptcha" &gt; &lt;input type="text" name="tryCode" /&gt; &lt;input type="submit" value="提交" class="btn btn-success"&gt;&lt;/input&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 7、验证成功界面 success.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;/meta&gt;&lt;title&gt;验证成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;验证成功&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; https://www.jianshu.com/p/1f2f7c47e812 14 SpringBoot 整合日志文件 https://www.cnblogs.com/zhangjianbing/p/8992897.html https://blog.csdn.net/ws_kfxd/article/details/8466559 1 依赖12345678910111213141516171819dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 店铺信息编辑值dao开发]]></content>
      <categories>
        <category>重要</category>
      </categories>
      <tags>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot小D课堂]]></title>
    <url>%2F2018%2F12%2F22%2FSpring%20Boot%2FSpringBoot%E5%B0%8FD%E8%AF%BE%E5%A0%82%2F</url>
    <content type="text"><![CDATA[1、零基础快速入门SpringBoot2.0 (5节课)1、SpringBoot2.x课程全套介绍和高手系列知识点​ 简介：介绍SpringBoot2.x课程大纲章节​ java基础，jdk环境，maven基础 2、SpringBoot2.x依赖环境和版本新特性说明简介：讲解新版本依赖环境和springboot2新特性概述 1、依赖版本jdk8以上, Springboot2.x用JDK8, 因为底层是 Spring framework5, 2、安装maven最新版本，maven3.2以上版本，下载地址 ：https://maven.apache.org/download.cgi 3、Eclipse或者IDE 4、新特性 5、翻译工具：https://translate.google.cn/ 6、springbootGitHub地址：https://github.com/spring-projects/spring-boot 7、springboot官方文档：https://spring.io/guides/gs/spring-boot/ ​ 3、快速创建SpringBoot2.x应用之手工创建web应用简介：使用Maven手工创建SpringBoot2.x应用 手工创建:https://projects.spring.io/spring-boot/#quick-start 官方推荐包命名接口，不要使用默认 defaultPackage 官方文档: https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-using-the-default-package 例子： com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java 4、快速创建SpringBoot2.x应用之工具类自动创建web应用简介：使用构建工具自动生成项目基本架构​ 1、工具自动创建:http://start.spring.io/ 5、SpringBoot2.x的依赖默认Maven版本​ 简介：讲解SpringBoot2.x的默认Maven依赖版本​ 1、官网地址​ https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#appendix-dependency-versions 2、SpringBoot接口Http协议开发实战 8节课1、SpringBoot2.xHTTP请求配置讲解 简介：SpringBoot2.xHTTP请求注解讲解和简化注解配置技巧 1、@RestController and @RequestMapping是springMVC的注解，不是springboot特有的 2、@RestController = @Controller+@ResponseBody 3、@SpringBootApplication = @Configuration+@EnableAutoConfiguration+@ComponentScan localhost:8080 2、开发接口必备工具之PostMan接口调试工具介绍和使用​ 简介：模拟Http接口测试工具PostMan安装和讲解 1、接口调试工具安装和基本使用 2、下载地址：https://www.getpostman.com/ ​ 3、SpringBoot基础HTTP接口GET请求实战​ 简介:讲解springboot接口，http的get请求，各个注解使用​ 1、GET请求​ 1、单一参数@RequestMapping(path = “/{id}”, method = RequestMethod.GET)​ 1) public String getUser(@PathVariable String id ) {}​​ 2）@RequestMapping(path = “/{depid}/{userid}”, method = RequestMethod.GET) 可以同时指定多个提交方法​ getUser(@PathVariable(“depid”) String departmentID,@PathVariable(“userid”) String userid)​​ 3）一个顶俩​ @GetMapping = @RequestMapping(method = RequestMethod.GET)​ @PostMapping = @RequestMapping(method = RequestMethod.POST)​ @PutMapping = @RequestMapping(method = RequestMethod.PUT)​ @DeleteMapping = @RequestMapping(method = RequestMethod.DELETE)​​ 4）@RequestParam(value = “name”, required = true)​ 可以设置默认值，比如分页​ 4)@RequestBody 请求体映射实体类 需要指定http头为 content-type为application/json charset=utf-8 5）@RequestHeader 请求头，比如鉴权 @RequestHeader(&quot;access_token&quot;) String accessToken 6）HttpServletRequest request自动注入获取参数 4、SpringBoot基础HTTP接口POST,PUT,DELETE请求实战​ 简介：讲解http请求post，put, delete提交方式 5、常用json框架介绍和Jackson返回结果处理​ 简介：介绍常用json框架和注解的使用，自定义返回json结构和格式 1、常用框架 阿里 fastjson,谷歌gson等 JavaBean序列化为Json，性能：Jackson &gt; FastJson &gt; Gson &gt; Json-lib 同个结构 Jackson、FastJson、Gson类库各有优点，各有自己的专长 空间换时间，时间换空间 2、jackson处理相关自动 指定字段不返回：@JsonIgnore 指定日期格式：@JsonFormat(pattern=&quot;yyyy-MM-dd hh:mm:ss&quot;,locale=&quot;zh&quot;,timezone=&quot;GMT+8&quot;) 空字段不返回：@JsonInclude(Include.NON_NUll) 指定别名：@JsonProperty 6、SpringBoot2.x目录文件结构讲解​ 简介：讲解SpringBoot目录文件结构和官方推荐的目录规范 1、目录讲解 src/main/java：存放代码 src/main/resources static: 存放静态文件，比如 css、js、image, （访问方式 http://localhost:8080/js/main.js） templates:存放静态页面jsp,html,tpl config:存放配置文件,application.properties resources: 2、引入依赖 Thymeleaf &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 注意：如果不引人这个依赖包，html文件应该放在默认加载文件夹里面， 比如resources、static、public这个几个文件夹，才可以访问 3、同个文件的加载顺序,静态资源文件 Spring Boot 默认会挨个从 META/resources &gt; resources &gt; static &gt; public 里面找是否存在相应的资源，如果有则直接返回。 4、默认配置 1）官网地址：https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content 2）spring.resources.static-locations = classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ 5、静态资源文件存储在CDN 7、SpringBoot2.x文件上传实战​ 简介：讲解HTML页面文件上传和后端处理实战​ 1、讲解springboot文件上传 MultipartFile file，源自SpringMVC​​ 1）静态页面直接访问：localhost:8080/index.html​ 注意点：​ 如果想要直接访问html页面，则需要把html放在springboot默认加载的文件夹下面​ 2）MultipartFile 对象的transferTo方法，用于文件保存（效率和操作比原先用FileOutStream方便和高效）​​ 访问路径 http://localhost:8080/images/39020dbb-9253-41b9-8ff9-403309ff3f19.jpeg ​ 8、jar包方式运行web项目的文件上传和访问处理（核心知识）​ 简介：讲解SpingBoot2.x使用 java -jar运行方式的图片上传和访问处理 1、文件大小配置，启动类里面配置 @Bean public MultipartConfigElement multipartConfigElement() { MultipartConfigFactory factory = new MultipartConfigFactory(); //单个文件最大 factory.setMaxFileSize(&quot;10240KB&quot;); //KB,MB /// 设置总上传数据总大小 factory.setMaxRequestSize(&quot;1024000KB&quot;); return factory.createMultipartConfig(); } 2、打包成jar包，需要增加maven依赖 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 如果没加相关依赖，执行maven打包，运行后会报错:no main manifest attribute, in XXX.jar GUI：反编译工具，作用就是用于把class文件转换成java文件 3、文件上传和访问需要指定磁盘路径 application.properties中增加下面配置 1) web.images-path=/Users/jack/Desktop 2) spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,classpath:/test/,file:${web.upload-path} 4、文件服务器：fastdfs，阿里云oss，nginx搭建一个简单的文件服务器 3.SpringBoot热部署devtool和配置文件自动注入实战 3节课1、SpringBoot2.x使用Dev-tool热部署​ 简介:介绍什么是热部署，使用springboot结合dev-tool工具，快速加载启动应用 官方地址：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools 核心依赖包： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 添加依赖后，在ide里面重启应用，后续修改后马上可以生效 classloader 不被热部署的文件 1、/META-INF/maven, /META-INF/resources, /resources, /static, /public, or /templates 2、指定文件不进行热部署 spring.devtools.restart.exclude=static/**,public/** 3、手工触发重启 spring.devtools.restart.trigger-file=trigger.txt 改代码不重启，通过一个文本去控制 https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools-restart-exclude 注意点：生产环境不要开启这个功能，如果用java -jar启动，springBoot是不会进行热部署的 2、SpringBoot2.x配置文件讲解​ 简介：SpringBoot2.x常见的配置文件 xml、yml、properties的区别和使用 xml、properties、json、yaml 1、常见的配置文件 xx.yml, xx.properties， 1)YAML（Yet Another Markup Language） 写 YAML 要比写 XML 快得多(无需关注标签或引号) 使用空格 Space 缩进表示分层，不同层次之间的缩进可以使用不同的空格数目 注意：key后面的冒号，后面一定要跟一个空格,树状结构 application.properties示例 server.port=8090 server.session-timeout=30 server.tomcat.max-threads=0 server.tomcat.uri-encoding=UTF-8 application.yml示例 server: port: 8090 session-timeout: 30 tomcat.max-threads: 0 tomcat.uri-encoding: UTF-8 2、默认示例文件仅作为指导。 不要将整个内容复制并粘贴到您的应用程序中，只挑选您需要的属性。 3、参考：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#common-application-properties 如果需要修改，直接复制对应的配置文件，加到application.properties里面 3、SpringBoot注解把配置文件自动映射到属性和实体类实战​ 简介：讲解使用@value注解配置文件自动映射到属性和实体类​​ 1、配置文件加载​ 方式一​ 1、Controller上面配置​ @PropertySource({“classpath:resource.properties”})​ 2、增加属性​ @Value(“${test.name}”)​ private String name;​​ 方式二：实体类配置文件​ 步骤：​ 1、添加 @Component 注解；​ 2、使用 @PropertySource 注解指定配置文件位置；​ 3、使用 @ConfigurationProperties 注解，设置相关属性；​​ 4、必须 通过注入IOC对象Resource 进来 ， 才能在类中使用获取的配置文件值。​ @Autowired​ private ServerSettings serverSettings;​ 例子： @Configuration @ConfigurationProperties(prefix=”test”) @PropertySource(value=”classpath:resource.properties”) public class ServerConstant { 常见问题： 1、配置文件注入失败，Could not resolve placeholder 解决：根据springboot启动流程，会有自动扫描包没有扫描到相关注解, 默认Spring框架实现会从声明@ComponentScan所在的类的package进行扫描，来自动注入， 因此启动类最好放在根路径下面，或者指定扫描包范围 spring-boot扫描启动类对应的目录和子目录 2、注入bean的方式，属性名称和配置文件里面的key一一对应，就用加@Value 这个注解 如果不一样，就要加@value(&quot;${XXX}&quot;) 4、Springboot2.0单元测试进阶实战和自定义异常处理. 5节课1、@SpringBootTest单元测试实战​ 简介：讲解SpringBoot的单元测试​ 1、引入相关依赖​ ​ ​ org.springframework.boot​ spring-boot-starter-test​ test​ 2、使用 @RunWith(SpringRunner.class) //底层用junit SpringJUnit4ClassRunner @SpringBootTest(classes={XdclassApplication.class})//启动整个springboot工程 public class SpringBootTests { } 2、SpringBoot测试进阶高级篇之MockMvc讲解​ 简介:讲解MockMvc类的使用和模拟Http请求实战 1、增加类注解 @AutoConfigureMockMvc @SpringBootTest(classes={XdclassApplication.class}) 2、相关API perform：执行一个RequestBuilder请求 andExpect：添加ResultMatcher-&gt;MockMvcResultMatchers验证规则 andReturn：最后返回相应的MvcResult-&gt;Response 3、SpringBoot2.x个性化启动banner设置和debug日志​ 简介：自定义应用启动的趣味性日志图标和查看调试日志 1、启动获取更多信息 java -jar xxx.jar --debug 2、修改启动的banner信息 1）在类路径下增加一个banner.txt，里面是启动要输出的信息 2）在applicatoin.properties增加banner文件的路径地址 spring.banner.location=banner.txt 3）官网地址 https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-banners 4、SpringBoot2.x配置全局异常实战​ 讲解：服务端异常讲解和SpringBoot配置全局异常实战 1、默认异常测试 int i = 1/0，不友好 2、异常注解介绍 @ControllerAdvice 如果是返回json数据 则用 RestControllerAdvice,就可以不加 @ResponseBody //捕获全局异常,处理所有不可知的异常 @ExceptionHandler(value=Exception.class) ​ 5、SpringBoot2.x配置全局异常返回自定义页面​ 简介：使用SpringBoot自定义异常和错误页面跳转实战 1、返回自定义异常界面，需要引入thymeleaf依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2、resource目录下新建templates,并新建error.html ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;error.html&quot;); modelAndView.addObject(&quot;msg&quot;, e.getMessage()); return modelAndView; https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-error-handling 5、SpringBoot部署war项目到tomcat9和启动原理讲解 2节课1、SpringBoot启动方式讲解和部署war项目到tomcat9简介：SpringBoot常见启动方式讲解和部署war项目Tomcat 1、ide启动 2、jar包方式启动 maven插件: &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 如果没有加，则执行jar包 ，报错如下 java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar no main manifest attribute, in spring-boot-demo-0.0.1-SNAPSHOT.jar 如果有安装maven 用 mvn spring-boot:run 项目结构 example.jar | +-META-INF | +-MANIFEST.MF +-org | +-springframework | +-boot | +-loader | +-&lt;spring boot loader classes&gt; +-BOOT-INF +-classes | +-mycompany | +-project | +-YourClasses.class +-lib +-dependency1.jar +-dependency2.jar 目录结构讲解 https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#executable-jar-jar-file-structure 3、war包方式启动 1)在pom.xml中将打包形式 jar 修改为war &lt;packaging&gt;war&lt;/packaging&gt; 构建项目名称 &lt;finalName&gt;xdclass_springboot&lt;/finalName&gt; 2)tocmat下载 https://tomcat.apache.org/download-90.cgi 3)修改启动类 public class XdclassApplication extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { return application.sources(XdclassApplication.class); } public static void main(String[] args) throws Exception { SpringApplication.run(XdclassApplication.class, args); } } 4)打包项目，启动tomcat 4、启动容器介绍和第三方测试数据讲解 使用Jmter测试工具测试性能，QPS,TPS，RT https://examples.javacodegeeks.com/enterprise-java/spring/tomcat-vs-jetty-vs-undertow-comparison-of-spring-boot-embedded-servlet-containers/ 2、SpringBoot2.x启动原理概述​ 简介：讲解SpringBoot启动流程概述和基本加载案例 6、SpringBoot拦截器实战和 Servlet3.0自定义Filter、Listener 4节课加入小D课堂技术交流答疑群：Q群：699347262 1、深入SpringBoot2.x过滤器Filter和使用Servlet3.0配置自定义Filter实战(核心知识)​ 简介:讲解SpringBoot里面Filter讲解和使用Servlet3.0配置自定义Filter实战​​ filter简单理解：人—&gt;检票员（filter）—&gt; 景点​​ 1、SpringBoot启动默认加载的Filter​ characterEncodingFilter​ hiddenHttpMethodFilter​ httpPutFormContentFilter​ requestContextFilter​​ 2、Filter优先级​ Ordered.HIGHEST_PRECEDENCE Ordered.LOWEST_PRECEDENCE 低位值意味着更高的优先级 Higher values are interpreted as lower priority 自定义Filter，避免和默认的Filter优先级一样，不然会冲突 注册Filter的bean FilterRegistrationBean 同模块里面有相关默认Filter web-&gt;servlet-&gt;filter 3、自定义Filter 1）使用Servlet3.0的注解进行配置 2）启动类里面增加 @ServletComponentScan，进行扫描 3）新建一个Filter类，implements Filter，并实现对应的接口 4) @WebFilter 标记一个类为filter，被spring进行扫描 urlPatterns：拦截规则，支持正则 6）控制chain.doFilter的方法的调用，来实现是否通过放行 不放行，web应用resp.sendRedirect(&quot;/index.html&quot;); 场景：权限控制、用户登录(非前端后端分离场景)等 1、官网地址：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-embedded-container-servlets-filters-listeners 2、Servlet3.0的注解自定义原生Servlet实战​ 讲解：使用 Servlet3.0的注解自定义原生Servlet和Listener​ 1、自定义原生Servlet @WebServlet(name = &quot;userServlet&quot;,urlPatterns = &quot;/test/customs&quot;) public class UserServlet extends HttpServlet{ @Override public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().print(&quot;custom sevlet&quot;); resp.getWriter().flush(); resp.getWriter().close(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 3、Servlet3.0的注解自定义原生Listener监听器实战​ 简介：监听器介绍和Servlet3.0的注解自定义原生Listener监听器实战 1、自定义Listener(常用的监听器 servletContextListener、httpSessionListener、servletRequestListener) @WebListener public class RequestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { // TODO Auto-generated method stub System.out.println(&quot;======requestDestroyed========&quot;); } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(&quot;======requestInitialized========&quot;); } 4、SpringBoot2.X自定义拦截器实战及新旧配置对比(核心知识)​ 简介: 讲解拦截器使用，Spingboot2.x新版本配置拦截拦截器和旧版本SpringBoot配置拦截器区别讲解​​ 1、@Configuration​ 继承WebMvcConfigurationAdapter(SpringBoot2.X之前旧版本)​​ SpringBoot2.X 新版本配置拦截器 implements WebMvcConfigurer​​ 2、自定义拦截器 HandlerInterceptor​ preHandle：调用Controller某个方法之前​ postHandle：Controller之后调用，视图渲染之前，如果控制器Controller出现了异常，则不会执行此方法​ afterCompletion：不管有没有异常，这个afterCompletion都会被调用，用于资源清理​ 3、按照注册顺序进行拦截，先注册，先被拦截 拦截器不生效常见问题： 1）是否有加@Configuration 2）拦截路径是否有问题 ** 和 * 3）拦截器最后路径一定要 “/**”， 如果是目录的话则是 /*/ Filter 是基于函数回调 doFilter()，而Interceptor则是基于AOP思想 Filter在只在Servlet前后起作用，而Interceptor够深入到方法前后、异常抛出前后等 依赖于Servlet容器即web应用中，而Interceptor不依赖于Servlet容器所以可以运行在多种环境。 在接口调用的生命周期里，Interceptor可以被多次调用，而Filter只能在容器初始化时调用一次。 Filter和Interceptor的执行顺序 过滤前-&gt;拦截前-&gt;action执行-&gt;拦截后-&gt;过滤后 7 SpringBoot常用Starter介绍和整合模板引擎Freemaker、thymeleaf 4节课1、SpringBoot Starter讲解​ 简介：介绍什么是SpringBoot Starter和主要作用 1、官网地址：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-starter 2、starter主要简化依赖用的 spring-boot-starter-web -&gt;里面包含多种依赖 3、几个常用的starter spring-boot-starter-activemq spring-boot-starter-aop spring-boot-starter-data-redis spring-boot-starter-freemarker spring-boot-starter-thymeleaf spring-boot-starter-webflux ​ 2、SpringBoot2.x常见模板引擎讲解和官方推荐使用​ 简介：介绍常用的SpringBoot2.x模板引擎和官方推荐案例 1、JSP（后端渲染，消耗性能） Java Server Pages 动态网页技术,由应用服务器中的JSP引擎来编译和执行，再将生成的整个页面返回给客户端 可以写java代码 持表达式语言（el、jstl） 内建函数 JSP-&gt;Servlet(占用JVM内存)permSize javaweb官方推荐 springboot不推荐 https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-jsp-limitations 2、Freemarker FreeMarker Template Language（FTL） 文件一般保存为 xxx.ftl 严格依赖MVC模式，不依赖Servlet容器（不占用JVM内存） 内建函数 3、Thymeleaf (主推) 轻量级的模板引擎（负责逻辑业务的不推荐，解析DOM或者XML会占用多的内存） 可以直接在浏览器中打开且正确显示模板页面 直接是html结尾，直接编辑 xdlcass.net/user/userinfo.html 社会工程学 伪装 3、SpringBoot2.x整合模板引擎freemarker实战​ 简介：SpringBoot2.x整合模板引擎freemarker实战 1、Freemarker相关maven依赖 &lt;!-- 引入freemarker模板引擎的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; 2、Freemarker基础配置 # 是否开启thymeleaf缓存,本地为false，生产建议为true spring.freemarker.cache=false spring.freemarker.charset=UTF-8 spring.freemarker.allow-request-override=false spring.freemarker.check-template-location=true #类型 spring.freemarker.content-type=text/html spring.freemarker.expose-request-attributes=true spring.freemarker.expose-session-attributes=true #文件后缀 spring.freemarker.suffix=.ftl #路径 spring.freemarker.template-loader-path=classpath:/templates/ 3、建立文件夹 1)src/main/resources/templates/fm/user/ 2)建立一个index.ftl 3)user文件夹下面建立一个user.html 4、简单测试代码编写和访问 4、SpringBoot2.x整合模板引擎thymeleaf实战​ 讲解：SpringBoot2.x整合模板引擎thymeleaf实战 官网地址：https://www.thymeleaf.org/doc/articles/thymeleaf3migration.html 1、thymeleaf相关maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2、thymeleaf基础配置 #开发时关闭缓存,不然没法看到实时页面 spring.thymeleaf.cache=false spring.thymeleaf.mode=HTML5 #前缀 spring.thymeleaf.prefix=classpath:/templates/ #编码 spring.thymeleaf.encoding=UTF-8 #类型 spring.thymeleaf.content-type=text/html #名称的后缀 spring.thymeleaf.suffix=.html 3、建立文件夹 1)src/main/resources/templates/tl/ 2)建立一个index.html 4、简单测试代码编写和访问 注意：$表达式只能写在th标签内部 快速入门：https://www.thymeleaf.org/doc/articles/standarddialect5minutes.html 8 数据库操作之整合Mybaties和事务讲解 5节课1、SpringBoot2.x持久化数据方式介绍​​ 简介：介绍近几年常用的访问数据库的方式和优缺点​​ 1、原始java访问数据库​ 开发流程麻烦​ 1、注册驱动/加载驱动​ Class.forName(“com.mysql.jdbc.Driver”)​ 2、建立连接​ Connection con = DriverManager.getConnection(“jdbc:mysql://localhost:3306/dbname”,”root”,”root”);​ 3、创建Statement​​ 4、执行SQL语句​ 5、处理结果集 6、关闭连接，释放资源 2、apache dbutils框架 比上一步简单点 官网:https://commons.apache.org/proper/commons-dbutils/ 3、jpa框架 spring-data-jpa jpa在复杂查询的时候性能不是很好 4、Hiberante 解释：ORM：对象关系映射Object Relational Mapping 企业大都喜欢使用hibernate 5、Mybatis框架 互联网行业通常使用mybatis 不提供对象和关系模型的直接映射,半ORM 2、SpringBoot2.x整合Mybatis3.x注解实战​ 简介：SpringBoot2.x整合Mybatis3.x注解配置实战 1、使用starter, maven仓库地址：http://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter 2、加入依赖(可以用 http://start.spring.io/ 下载) &lt;!-- 引入starter--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL的JDBC驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 引入第三方数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; 3、加入配置文件 #mybatis.type-aliases-package=net.xdclass.base_project.domain #可以自动识别 #spring.datasource.driver-class-name =com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/movie?useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.username =root spring.datasource.password =password #如果不使用默认的数据源 （com.zaxxer.hikari.HikariDataSource） spring.datasource.type =com.alibaba.druid.pool.DruidDataSource 加载配置，注入到sqlSessionFactory等都是springBoot帮我们完成 4、启动类增加mapper扫描 @MapperScan(&quot;net.xdclass.base_project.mapper&quot;) 技巧：保存对象，获取数据库自增id @Options(useGeneratedKeys=true, keyProperty=&quot;id&quot;, keyColumn=&quot;id&quot;) 4、开发mapper 参考语法 http://www.mybatis.org/mybatis-3/zh/java-api.html 5、sql脚本 CREATE TABLE `user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(128) DEFAULT NULL COMMENT &apos;名称&apos;, `phone` varchar(16) DEFAULT NULL COMMENT &apos;用户手机号&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;创建时间&apos;, `age` int(4) DEFAULT NULL COMMENT &apos;年龄&apos;, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8; 相关资料： http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/#Configuration https://github.com/mybatis/spring-boot-starter/tree/master/mybatis-spring-boot-samples 整合问题集合： https://my.oschina.net/hxflar1314520/blog/1800035 https://blog.csdn.net/tingxuetage/article/details/80179772 3、SpringBoot2.x整合Mybatis3.x增删改查实操和控制台打印SQL语句​ 讲解:SpringBoot2.x整合Mybatis3.x增删改查实操, 控制台打印sql语句​​ 1、控制台打印sql语句​ #增加打印sql语句，一般用于本地开发测试​ mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl​​ 2、增加mapper代码​ @Select(“SELECT FROM user”)​ @Results({​ @Result(column = “create_time”,property = “createTime”) //javaType = java.util.Date.class​ })​ List getAll();​​ @Select(“SELECT FROM user WHERE id = #{id}”)​ @Results({​ @Result(column = “create_time”,property = “createTime”)​ })​ User findById(Long id);​ @Update(“UPDATE user SET name=#{name} WHERE id =#{id}”) void update(User user); @Delete(&quot;DELETE FROM user WHERE id =#{userId}&quot;) void delete(Long userId); 3、增加API @GetMapping(&quot;find_all&quot;) public Object findAll(){ return JsonData.buildSuccess(userMapper.getAll()); } @GetMapping(&quot;find_by_Id&quot;) public Object findById(long id){ return JsonData.buildSuccess(userMapper.findById(id)); } @GetMapping(&quot;del_by_id&quot;) public Object delById(long id){ userMapper.delete(id); return JsonData.buildSuccess(); } @GetMapping(&quot;update&quot;) public Object update(String name,int id){ User user = new User(); user.setName(name); user.setId(id); userMapper.update(user); return JsonData.buildSuccess(); } 4、事务介绍和常见的隔离级别，传播行为​​ 简介：讲解什么是数据库事务，常见的隔离级别和传播行为​​ 1、介绍什么是事务，单机事务，分布式事务处理等​​ 2、讲解场景的隔离级别​ Serializable： 最严格，串行处理，消耗资源大​ Repeatable Read：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据​ Read Committed：大多数主流数据库的默认事务等级​ Read Uncommitted：保证了读取过程中不会读取到非法数据。 3、讲解常见的传播行为 PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务,最常见的选择。 PROPAGATION_SUPPORTS--支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY--支持当前事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW--新建事务，如果当前存在事务，把当前事务挂起, 两个事务之间没有关系，一个异常，一个提交，不会同时回滚 PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER--以非事务方式执行，如果当前存在事务，则抛出异常 5、SpringBoot整合mybatis之事务处理实战​ 简介：SpringBoot整合Mybatis之事务处理实战​ 1、service逻辑引入事务 @Transantional(propagation=Propagation.REQUIRED) 2、service代码 @Override @Transactional public int addAccount() { User user = new User(); user.setAge(9); user.setCreateTime(new Date()); user.setName(&quot;事务测试&quot;); user.setPhone(&quot;000121212&quot;); userMapper.insert(user); int a = 1/0; return user.getId(); } 9 SpringBoot2.x整合Redis实战 4节课​ 1、分布式缓存Redis介绍​ 简介:讲解为什么要用缓存和介绍什么是Redis，新手练习工具​​ 1、redis官网 https://redis.io/download​​ 2、新手入门redis在线测试工具：http://try.redis.io/ 2、源码编译安装Redis4.x​ 简介：使用源码安装Redis4.x和配置外网访问 1、快速安装 https://redis.io/download#installation wget http://download.redis.io/releases/redis-4.0.9.tar.gz tar xzf redis-4.0.9.tar.gz cd redis-4.0.9 make 启动服务端：src/redis-server 启动客户端：src/redis-cli 2、默认是本地访问的，需要开放外网访问 1）打开redis.conf文件在NETWORK部分修改 注释掉bind 127.0.0.1可以使所有的ip访问redis 修改 protected-mode，值改为no 3、SpringBoot2.x整合redis实战讲解 简介：使用springboot-starter整合reids实战 1、官网：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-redis 集群文档：https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#cluster 2、springboot整合redis相关依赖引入 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 3、相关配置文件配置 #=========redis基础配置========= spring.redis.database=0 spring.redis.host=127.0.0.1 spring.redis.port=6390 # 连接超时时间 单位 ms（毫秒） spring.redis.timeout=3000 #=========redis线程池设置========= # 连接池中的最大空闲连接，默认值也是8。 spring.redis.pool.max-idle=200 #连接池中的最小空闲连接，默认值也是0。 spring.redis.pool.min-idle=200 # 如果赋值为-1，则表示不限制；pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。 spring.redis.pool.max-active=2000 # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时 spring.redis.pool.max-wait=1000 4、常见redistemplate种类讲解和缓存实操(使用自动注入) 1、注入模板 @Autowired private StirngRedisTemplate strTplRedis 2、类型String，List,Hash,Set,ZSet 对应的方法分别是opsForValue()、opsForList()、opsForHash()、opsForSet()、opsForZSet() 4、Redis工具类封装讲解和实战​ 简介：高效开发方式 Redis工具类封装讲解和实战​ 1、常用客户端 https://redisdesktop.com/download​ 2、封装redis工具类并操作 10 SpringBoot整合定时任务和异步任务处理 3节课加入小D课堂技术交流答疑群：Q群：699347262 1、SpringBoot定时任务schedule讲解​ 简介：讲解什么是定时任务和常见定时任务区别 1、常见定时任务 Java自带的java.util.Timer类 timer:配置比较麻烦，时间延后问题 timertask:不推荐 2、Quartz框架 配置更简单 xml或者注解 3、SpringBoot使用注解方式开启定时任务 1）启动类里面 @EnableScheduling开启定时任务，自动扫描 2）定时任务业务类 加注解 @Component被容器扫描 3）定时执行的方法加上注解 @Scheduled(fixedRate=2000) 定期执行一次 2、SpringBoot常用定时任务配置实战​ 简介：SpringBoot常用定时任务表达式配置和在线生成器 1、cron 定时任务表达式 @Scheduled(cron=&quot;*/1 * * * * *&quot;) 表示每秒 1）crontab 工具 https://tool.lu/crontab/ 2、fixedRate: 定时多久执行一次（上一次开始执行时间点后xx秒再次执行；） 3、fixedDelay: 上一次执行结束时间点后xx秒再次执行 4、fixedDelayString: 字符串形式，可以通过配置文件指定 3、SpringBoot2.x异步任务实战（核心知识）​ 简介：讲解什么是异步任务，和使用SpringBoot2.x开发异步任务实战​ 1、什么是异步任务和使用场景：适用于处理log、发送邮件、短信……等​ 下单接口-&gt;查库存 100​ 余额校验 150​ 风控用户100​ …. 2、启动类里面使用@EnableAsync注解开启功能，自动扫描 3、定义异步任务类并使用@Component标记组件被容器扫描,异步方法加上@Async 注意点： 1）要把异步任务封装到类里面，不能直接写到Controller 2）增加Future&lt;String&gt; 返回结果 AsyncResult&lt;String&gt;(&quot;task执行完成&quot;); 3）如果需要拿到结果 需要判断全部的 task.isDone() 4、通过注入方式，注入到controller里面，如果测试前后区别则改为同步则把Async注释掉 11 Logback日志框架介绍和SpringBoot整合实战 2节课加入小D课堂技术交流答疑群：Q群：699347262 1、新日志框架LogBack介绍​ 简介：日志介绍和新日志框架Logback讲解 1.常用处理java的日志组件 slf4j,log4j,logback,common-logging 等 2、logback介绍：基于Log4j基础上大量改良，不能单独使用，推荐配合日志框架SLF4J来使用 logback当前分成三个模块：logback-core,logback-classic和logback-access; logback-core是其它两个模块的基础模块 3、Logback的核心对象： Logger：日志记录器 Appender：指定日志输出的目的地，目的地可以是控制台，文件 Layout：日志布局 格式化日志信息的输出 ​​ 4、日志级别：DEBUG &lt; INFO &lt; WARN &lt; ERROR​​ ===========log4j示例===========​ ### 设置###​ log4j.rootLogger = debug,stdout,D,E​​ ### 输出信息到控制抬 ###​ log4j.appender.stdout = org.apache.log4j.ConsoleAppender​ log4j.appender.stdout.Target = System.out​ log4j.appender.stdout.layout = org.apache.log4j.PatternLayout​ log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n​ ### 输出DEBUG 级别以上的日志到=D://logs/error.log ### log4j.appender.D = org.apache.log4j.DailyRollingFileAppender log4j.appender.D.File = D://logs/log.log log4j.appender.D.Append = true log4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayout log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [ %t:%r ] - [ %p ] %m%n ### 输出ERROR 级别以上的日志到=D://logs/error.log ### log4j.appender.E = org.apache.log4j.DailyRollingFileAppender log4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = true log4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayout log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [ %t:%r ] - [ %p ] %m%n ===========logback============ 4、Log4j日志转换为logback在线工具（支持log4j.properties转换为logback.xml,不支持 log4j.xml转换为logback.xml） https://logback.qos.ch/translator/ 2、SpringBoot2.x日志讲解和自定义Logback配置实战​ 简介：讲解SpringBoot2.x整合Logback配置实战 1、官网介绍：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-logging 各个组件案例：https://logback.qos.ch/manual/index.html 2、分析SpringBoot启动日志 1）默认情况下，Spring Boot将日志输出到控制台 3、整合Logback实战 1）创建 日志文件logback-spring.xml，官方推荐 -spring.xml结尾 默认加载加载配置顺序 logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy 注释： &lt;configuration&gt; 子节点 &lt;appender&gt;&lt;/appender&gt; &lt;logger&gt;&lt;/logger&gt; &lt;root&gt;&lt;/root&gt;(要加在最后) 12章 搜索框架ElasticSearch介绍和整合SpringBoot 4节课1、搜索引擎知识和搜索框架elasticsearch基本介绍​ 简介：通过京东电商 介绍什么是搜索引擎，和开源搜索框架ElasticSearch6.x新特性介绍 前言：介绍ES的主要特点和使用场景，新特性讲解 mysql：like 模糊，性能问题, solr:针对企业，Lucene elasticsearch：针对数据量特别大，PB,TB 纯java开发，springboot使用，5.6版本 es升级4-&gt;5版本，改动大，但是5版本后，改动不大 elasticSearch主要特点 1、特点：全文检索，结构化检索，数据统计、分析，接近实时处理，分布式搜索(可部署数百台服务器)，处理PB级别的数据 搜索纠错，自动完成 2、使用场景：日志搜索，数据聚合，数据监控，报表统计分析 3、国内外使用者：维基百科，Stack Overflow，GitHub 新特性讲解 1、6.2.x版本基于Lucene 7.x，更快，性能进一步提升,对应的序列化组件，升级到Jackson 2.8 mysql：database table rocord es : index type（只能存在一个) document 2、推荐使用5.0版本推出的Java REST/HTTP客户端，依赖少，比Transport使用更方便，在基准测试中，性能并不输于Transport客户端， 在5.0到6.0版本中，每次有对应的API更新, 文档中也说明，推荐使用这种方式进行开发使用,所有可用节点间的负载均衡 在节点故障和特定响应代码的情况下进行故障转移,失败的连接处罚（失败的节点是否重试取决于失败的连续次数;失败的失败次数越多，客户端在再次尝试同一节点之前等待的时间越长） 3、(重要)不再支持一个索引库里面多个type，6.x版本已经禁止一个index里面多个type，所以一个index索引库只能存在1个type 官方文档： 1、6.0更新特性 https://www.elastic.co/guide/en/elasticsearch/reference/6.0/release-notes-6.0.0.html#breaking-java-6.0.0 2、6.1更新特性 https://www.elastic.co/guide/en/elasticsearch/reference/6.1/release-notes-6.1.0.html 2、快熟部署ElastcSearch5.6.x​ 简介：讲解为什么不用ES6.x版本，及本地快速安装ElasticSeach和场景问题处理​​ 配置JDK1.8​ 使用wget 下载elasticsearch安装包​ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.8.tar.gz​ 解压​ tar -zxvf elasticsearch-5.6.8.tar.gz​ 官网：https://www.elastic.co/products/elasticsearch​​ 外网访问配置：​ config目录下面elasticsearch.yml​ 修改为 network.host: 0.0.0.0 配置es出现相关问题处理（阿里云、腾讯云，亚马逊云安装问题集合）： 1、问题一 Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c5330000, 986513408, 0) failed; error=&apos;Cannot allocate memory&apos; (errno=12) # # There is insufficient memory for the Java Runtime Environment to continue. # Native memory allocation (mmap) failed to map 986513408 bytes for committing reserved memory. # An error report file with more information is saved as: # /usr/local/software/temp/elasticsearch-6.2.2/hs_err_pid1912.log 解决：内存不够，购买阿里云的机器可以动态增加内存 2、问题二 [root@iZwz95j86y235aroi85ht0Z bin]# ./elasticsearch [2018-02-22T20:14:04,870][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [] uncaught exception in thread [main] org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:125) ~[elasticsearch-6.2.2.jar:6.2.2] at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:112) ~[elasticsearch-6.2.2.jar:6.2.2] at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-6.2.2.jar:6.2.2] at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) ~[elasticsearch-cli-6.2.2.jar:6.2.2] 解决：用非root用户 添加用户：useradd -m 用户名 然后设置密码 passwd 用户名 3、问题三 ./elasticsearch Exception in thread &quot;main&quot; java.nio.file.AccessDeniedException: /usr/local/software/temp/elasticsearch-6.2.2/config/jvm.options 解决：权限不够 chmod 777 -R 当前es目录 常见配置问题资料：https://www.jianshu.com/p/c5d6ec0f35e0 3、ElasticSearch5.6.8测试数据准备​ 简介: ElasticSearch5.6.x简单测试​ 1、步骤 https://www.elastic.co/guide/en/elasticsearch/reference/5.6/index.html​ 2、使用POSTMAN 工具 基础 查看集群状态：localhost:9200/_cat/health?v 查看索引列表：localhost:9200/_cat/indices?v 4、SpringBoot2.x整合elasticsearch5.6.x​ 简介：SpringBoot2.x整合elasticSearch5.6.8实战 Spring Data Elasticsearch文档地址 https://docs.spring.io/spring-data/elasticsearch/docs/3.0.6.RELEASE/reference/html/ 版本说明：SpringBoot整合elasticsearch https://github.com/spring-projects/spring-data-elasticsearch/wiki/Spring-Data-Elasticsearch---Spring-Boot---version-matrix 1、添加maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; 2、接口继承ElasticSearchRepository,里面有很多默认实现 注意点： 索引名称记得小写，类属性名称也要小写 新建实体对象article 加上类注解 @Document(indexName = &quot;blog&quot;, type = &quot;article&quot;) 3、配置文件：ELASTICSEARCH (ElasticsearchProperties) ​ spring.data.elasticsearch.cluster-name=elasticsearch # Elasticsearch cluster name.​ spring.data.elasticsearch.cluster-nodes=localhost:9300 # Comma-separated list of cluster node addresses.​ spring.data.elasticsearch.repositories.enabled=true # Whether to enable Elasticsearch repositories.​​ 4、QueryBuilder使用​ https://www.elastic.co/guide/en/elasticsearch/client/java-api/1.3/query-dsl-queries.html​ //单个匹配，搜索name为jack的文档 QueryBuilder queryBuilder = QueryBuilders.matchQuery(“title”, “搜”); 4、查看es数据 查看索引信息：http://localhost:9200/_cat/indices?v 查看某个索引库结构：http://localhost:9200/blog 查看某个对象：http://localhost:9200/blog/article/1 13 消息队列介绍和SpringBoot2.x整合RockketMQ、ActiveMQ 9节课加入小D课堂技术交流答疑群：Q群：699347262 1、JMS介绍和使用场景及基础编程模型​ 简介：讲解什么是小写队列，JMS的基础知识和使用场景​ 1、什么是JMS: Java消息服务（Java Message Service),Java平台中关于面向消息中间件的接口 2、JMS是一种与厂商无关的 API，用来访问消息收发系统消息，它类似于JDBC(Java Database Connectivity)。这里，JDBC 是可以用来访问许多不同关系数据库的 API 3、使用场景： 1）跨平台 2）多语言 3）多项目 4）解耦 5）分布式事务 6）流量控制 7）最终一致性 8）RPC调用 上下游对接，数据源变动-&gt;通知下属 4、概念 JMS提供者：Apache ActiveMQ、RabbitMQ、Kafka、Notify、MetaQ、RocketMQ JMS生产者(Message Producer) JMS消费者(Message Consumer) JMS消息 JMS队列 JMS主题 JMS消息通常有两种类型：点对点（Point-to-Point)、发布/订阅（Publish/Subscribe） 5、编程模型 MQ中需要用的一些类 ConnectionFactory ：连接工厂，JMS 用它创建连接 Connection ：JMS 客户端到JMS Provider 的连接 Session： 一个发送或接收消息的线程 Destination ：消息的目的地;消息发送给谁. MessageConsumer / MessageProducer： 消息接收者，消费者 2、ActiveMQ5.x消息队列基础介绍和安装​​ 简介：介绍ActiveMQ5.x消息队列基础特性和本地快速安装​ 特点：​ 1）支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议​ 2）支持许多高级功能，如消息组，虚拟目标，通配符和复合目标​ 3) 完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息​ 4) Spring支持，ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置​ 5) 支持在流行的J2EE服务器（如TomEE，Geronimo，JBoss，GlassFish和WebLogic）中进行测试​ 6) 使用JDBC和高性能日志支持非常快速的持久化​ …​​ 1、下载地址：http://activemq.apache.org/activemq-5153-release.html​ 2、快速开始：http://activemq.apache.org/getting-started.html​ 3、如果我们是32位的机器，就双击win32目录下的activemq.bat,如果是64位机器，则双击win64目录下的activemq.bat​ 4、bin目录里面启动 选择对应的系统版本和位数，activeMQ start 启动​ 5、启动后访问路径http://127.0.0.1:8161/​​ 6、用户名和密码默认都是admin​ 7、官方案例集合​ https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples​ 面板：​ Name：队列名称。​ Number Of Pending Messages：等待消费的消息个数。​ Number Of Consumers：当前连接的消费者数目​ Messages Enqueued：进入队列的消息总个数，包括出队列的和待消费的，这个数量只增不减。​ Messages Dequeued：已经消费的消息数量。 3、SpringBoot2.x整合ActiveMQ实战之点对点消息(p2p)​​ 简介:SpringBoot2.x整合ActiveMQ实战之点对点消息​​ 1、官网地址：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-activemq​​ 2、加入依赖​ ​ ​ org.springframework.boot​ spring-boot-starter-activemq​ ​ org.apache.activemq activemq-pool 3、application.properties配置文件配置 #整合jms测试，安装在别的机器，防火墙和端口号记得开放 spring.activemq.broker-url=tcp://127.0.0.1:61616 #集群配置 #spring.activemq.broker-url=failover:(tcp://localhost:61616,tcp://localhost:61617) spring.activemq.user=admin spring.activemq.password=admin #下列配置要增加依赖 spring.activemq.pool.enabled=true spring.activemq.pool.max-connections=100 4、springboot启动类 @EnableJms，开启支持jms 5、模拟请求 localhost:8080/api/v1/order?msg=12312321321312 6、消费者：实时监听对应的队列 @JmsListener(destination = &quot;order.queue&quot;) ​ 4、SpringBoot整合ActiveMQ实战之发布订阅模式(pub/sub)​ 简介：SpringBoot整合ActiveMQ实战之发布订阅模式(pub/sub),及同时支持点对点和发布订阅模型 1、需要加入配置文件，支持发布订阅模型，默认只支持点对点 #default point to point spring.jms.pub-sub-domain=true 注意点： 1、默认消费者并不会消费订阅发布类型的消息，这是由于springboot默认采用的是p2p模式进行消息的监听 修改配置：spring.jms.pub-sub-domain=true 2、@JmsListener如果不指定独立的containerFactory的话是只能消费queue消息 修改订阅者container：containerFactory=&quot;jmsListenerContainerTopic&quot; //需要给topic定义独立的JmsListenerContainer @Bean public JmsListenerContainerFactory&lt;?&gt; jmsListenerContainerTopic(ConnectionFactory activeMQConnectionFactory) { DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory(); bean.setPubSubDomain(true); bean.setConnectionFactory(activeMQConnectionFactory); return bean; } 在配置文件里面，注释掉 #spring.jms.pub-sub-domain=true 5、RocketMQ4.x消息队列介绍​ 简介：阿里开源消息队列 RocketMQ4.x介绍和新概念讲解 1、Apache RocketMQ作为阿里开源的一款高性能、高吞吐量的分布式消息中间件 2、特点 1)在高压下1毫秒内响应延迟超过99.6％。 2)适合金融类业务，高可用性跟踪和审计功能。 3)支持发布订阅模型，和点对点 4）支持拉pull和推push两种消息模式 5)单一队列百万消息 6)支持单master节点，多master节点，多master多slave节点 ... 3、概念 Producer:消息生产者 Producer Group:消息生产者组，发送同类消息的一个消息生产组 Consumer:消费者 Consumer Group:消费同个消息的多个实例 Tag:标签，子主题（二级分类）,用于区分同一个主题下的不同业务的消息 Topic:主题 Message：消息 Broker：MQ程序，接收生产的消息，提供给消费者消费的程序 Name Server：给生产和消费者提供路由信息，提供轻量级的服务发现和路由 3、官网地址：http://rocketmq.apache.org/ 学习资源： 1）http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/ 2）https://www.jianshu.com/p/453c6e7ff81c 6、RocketMQ4.x本地快速部署​ 简介:RocketMQ4.x本地快速部署 1、安装前提条件(推荐) 64bit OS, Linux/Unix/Mac 64bit JDK 1.8+; 2、快速开始 http://rocketmq.apache.org/docs/quick-start/ 下载安装包：https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.2.0/rocketmq-all-4.2.0-bin-release.zip 路径：/Users/jack/Desktop/person/springboot/资料/第13章/第5课/rocketmq-all-4.2.0-bin-release/bin 3、解压压缩包 1）进入bin目录，启动namesrv nohup sh mqnamesrv &amp; 2) 查看日志 tail -f nohup.out 结尾：The Name Server boot success. serializeType=JSON 表示启动成功 3、启动broker nohup sh mqbroker -n 127.0.0.1:9876 &amp; 4)、关闭nameserver broker执行的命令 sh mqshutdown namesrv sh mqshutdown broker 7、RoekerMQ4.x可视化控制台讲解​ 简介：RoekerMQ4.x可视化控制台讲解 1、下载 https://github.com/apache/rocketmq-externals 2、编译打包 mvn clean package -Dmaven.test.skip=true 3、target目录 通过java -jar的方式运行 4、无法连接获取broker信息 1）修改配置文件,名称路由地址为 namesrvAddr，例如我本机为 2）src/main/resources/application.properties rocketmq.config.namesrvAddr=192.168.0.101:9876 5、默认端口 localhost:8080 6、注意： 在阿里云，腾讯云或者虚拟机，记得检查端口号和防火墙是否启动 8、Springboot2.x整合RocketMQ4.x实战上集​ 简介：Springboot2.x整合RocketMQ4.x实战，加入相关依赖，开发生产者代码​​ 启动nameser和broker​​ 1、加入相关依赖​ ​ org.apache.rocketmq​ rocketmq-client​ ${rocketmq.version}​ ​ ​ org.apache.rocketmq​ rocketmq-common​ ${rocketmq.version}​ 2、application.properties加入配置文件 # 消费者的组名 apache.rocketmq.consumer.PushConsumer=orderConsumer # 生产者的组名 apache.rocketmq.producer.producerGroup=Producer # NameServer地址 apache.rocketmq.namesrvAddr=127.0.0.1:9876 3、开发MsgProducer /** * 生产者的组名 */ @Value(&quot;${apache.rocketmq.producer.producerGroup}&quot;) private String producerGroup; /** * NameServer 地址 */ @Value(&quot;${apache.rocketmq.namesrvAddr}&quot;) private String namesrvAddr; private DefaultMQProducer producer ; ​​ public DefaultMQProducer getProducer(){​ return this.producer;​ }​​ @PostConstruct​ public void defaultMQProducer() {​ //生产者的组名​ producer = new DefaultMQProducer(producerGroup);​ //指定NameServer地址，多个地址以 ; 隔开​ //如 producer.setNamesrvAddr(“192.168.100.141:9876;192.168.100.142:9876;192.168.100.149:9876”);​ producer.setNamesrvAddr(namesrvAddr);​ producer.setVipChannelEnabled(false);​​ try {​ /*​ Producer对象在使用之前必须要调用start初始化，只能初始化一次​ */​ producer.start();​ } catch (Exception e) { e.printStackTrace(); } // producer.shutdown(); 一般在应用上下文，关闭的时候进行关闭，用上下文监听器 } 9、Springboot2.x整合RocketMQ4.x实战下集​ 简介：Springboot2.x整合RocketMQ4.x实战，开发消费者代码，常见问题处理 1、创建消费者 问题： 1、Caused by: org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;172.17.42.1:10911&gt; failed 2、com.alibaba.rocketmq.client.exception.MQClientException: Send [1] times, still failed, cost [1647]ms, Topic: TopicTest1, BrokersSent: [broker-a, null, null] 3、org.apache.rocketmq.client.exception.MQClientException: Send [3] times, still failed, cost [497]ms, Topic: TopicTest, BrokersSent: [chenyaowudeMacBook-Air.local, chenyaowudeMacBook-Air.local, chenyaowudeMacBook-Air.local] 解决：多网卡问题处理 1、设置producer: producer.setVipChannelEnabled(false); 2、编辑ROCKETMQ 配置文件：broker.conf（下列ip为自己的ip） namesrvAddr = 192.168.0.101:9876 brokerIP1 = 192.168.0.101 4、DESC: service not available now, maybe disk full, CL: 解决：修改启动脚本runbroker.sh，在里面增加一句话即可： JAVA_OPT=&quot;${JAVA_OPT} -Drocketmq.broker.diskSpaceWarningLevelRatio=0.98&quot; （磁盘保护的百分比设置成98%，只有磁盘空间使用率达到98%时才拒绝接收producer消息） 常见问题处理： https://blog.csdn.net/sqzhao/article/details/54834761 https://blog.csdn.net/mayifan0/article/details/67633729 https://blog.csdn.net/a906423355/article/details/78192828 14 高级篇幅之SpringBoot多环境配置 1节课1、SpringBoot多环境配置介绍和项目实战（核心知识）​ 简介：SpringBoot介绍多环境配置和使用场景 1、不同环境使用不同配置 例如数据库配置，在开发的时候，我们一般用开发数据库，而在生产环境的时候，我们是用正式的数据 2、配置文件存放路径 classpath根目录的“/config”包下 classpath的根目录下 3、spring boot允许通过命名约定按照一定的格式(application-{profile}.properties)来定义多个配置文件 15 高级篇幅之SpringBoot2.0响应式编程 4节课 1、SprinBoot2.x响应式编程简介​ 简介:讲解什么是reactive响应式编程和使用的好处 1、基础理解： 依赖于事件，事件驱动(Event-driven) 一系列事件称为“流” 异步 非阻塞 观察者模式 网上的一个例子： int b= 2; int c=3 int a = b+c //命令式编程后续b和c变化，都不影响a b=5; int b= 2; int c= 3 int a = b+c //响应式编程中，a的变化，会和b、c的变化而变化（事件驱动） b=5; 2、官网：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-webflux SpingBoot2底层是用spring5,开始支持响应式编程，Spring又是基于Reactor试下响应式。 ​ 学习资料 1、reactive-streams学习资料：http://www.reactive-streams.org/ 2、web-flux相关资料：https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux 2、SpringBoot2.x响应式编程webflux介绍​ 简介：讲解SpringBoot2.x响应式编程介绍 Mono、Flux对象和优缺点​​ 1、Spring WebFlux是Spring Framework 5.0中引入的新的反应式Web框架​ 与Spring MVC不同，它不需要Servlet API，完全异步和非阻塞，并 通过Reactor项目实现Reactive Streams规范。​ RxJava 2、Flux和Mono User List&lt;User&gt; 1）简单业务而言：和其他普通对象差别不大，复杂请求业务，就可以提升性能 2）通俗理解： Mono 表示的是包含 0 或者 1 个元素的异步序列 mono-&gt;单一对象 User redis-&gt;用户ID-》唯一的用户Mono&lt;User&gt; Flux 表示的是包含 0 到 N 个元素的异步序列 flux-&gt;数组列表对象 List&lt;User&gt; redis-&gt;男性用户-&gt;Flux&lt;User&gt; Flux 和 Mono 之间可以进行转换 3、Spring WebFlux有两种风格：基于功能和基于注解的。基于注解非常接近Spring MVC模型，如以下示例所示： 第一种： @RestController @RequestMapping（“/ users”） public class MyRestController { @GetMapping（“/ {user}”） public Mono &lt;User&gt; getUser（ @PathVariable Long user）{ // ... } @GetMapping（“/ {user} / customers”） public Flux &lt;Customer&gt; getUserCustomers（ @PathVariable Long user）{ // ... } @DeleteMapping（“/ {user}”） public Mono &lt;User&gt; deleteUser（ @PathVariable Long user）{ // ... } } 第二种： 路由配置与请求的实际处理分开 @Configuration public class RoutingConfiguration { @Bean public RouterFunction &lt;ServerResponse&gt; monoRouterFunction（UserHandler userHandler）{ return route（GET（ “/ {user}”）.and（accept（APPLICATION_JSON）），userHandler :: getUser） .andRoute（GET（“/ {user} / customers”）.and（accept（APPLICATION_JSON）），userHandler :: getUserCustomers） .andRoute（DELETE（“/ {user}”）.and（accept（APPLICATION_JSON）），userHandler :: deleteUser）; } } @Component public class UserHandler { 公共 Mono &lt;ServerResponse&gt; getUser（ServerRequest请求）{ // ... } public Mono &lt;ServerResponse&gt; getUserCustomers（ServerRequest request）{ // ... } 公共 Mono &lt;ServerResponse&gt; deleteUser（ServerRequest请求）{ // ... } } 4、Spring WebFlux应用程序不严格依赖于Servlet API，因此它们不能作为war文件部署，也不能使用src/main/webapp目录 5、可以整合多个模板引擎 除了REST Web服务外，您还可以使用Spring WebFlux提供动态HTML内容。Spring WebFlux支持各种模板技术，包括Thymeleaf，FreeMarker 3、SpringBoot2.x webflux实战​ 简介:webflux响应式编程实战​​ 1、WebFlux中，请求和响应不再是WebMVC中的ServletRequest和ServletResponse，而是ServerRequest和ServerResponse​​ 2、加入依赖，如果同时存在spring-boot-starter-web，则会优先用spring-boot-starter-web​ ​ org.springframework.boot​ spring-boot-starter-webflux​ ​​ 测试​ localhost:8080/api/v1/user/test​ 3、启动方式默认是Netty,8080端口 ​ 4、参考：https://spring.io/blog/2016/04/19/understanding-reactive-types 4、WebFlux客户端WebClient讲解​ 简介：讲解SpringBoot2.x WebFlux客户端WebClient的介绍和使用​ 1、反应式客户端 官网地址：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-webclient 16 高级篇幅之SpringBoot2.0服务器端主动推送SSE技术讲解 2节课加入小D课堂技术交流答疑群：Q群：699347262 1、服务端推送常用技术介绍​ 简介：服务端常用推送技术介绍，如websocket，sse轮询等​ 1、客户端轮询:ajax定时拉取 2、服务端主动推送:WebSocket 全双工的，本质上是一个额外的tcp连接，建立和关闭时握手使用http协议，其他数据传输不使用http协议 更加复杂一些，适用于需要进行复杂双向数据通讯的场景 3、服务端主动推送:SSE (Server Send Event) html5新标准，用来从服务端实时推送数据到浏览器端， 直接建立在当前http连接上，本质上是保持一个http长连接，轻量协议 简单的服务器数据推送的场景，使用服务器推送事件 学习资料：http://www.w3school.com.cn/html5/html_5_serversentevents.asp 2、SpringBoot2.x服务端主动推送SSE​ 简介：讲解SpringBoot2.x服务端主动推送Sever-Send-Events​​ 1、localhost:8080/index.html 2、需要把response的类型 改为 text/event-stream，才是sse的类型 17 高级篇幅之云服务器介绍和部署生产环境实战 5节课1、阿里云服务器介绍和使用讲解​ 简介：阿里云服务器介绍和使用讲解 2、阿里云Linux服务器部署JDK8实战​ 简介：在阿里云服务器上安装JDK8和配置环境变量 lnux下使用wget下载jdk8: 进到目录/usr/local/software 配置环境变量 vim /etc/profile 加入 export JAVA_HOME=/usr/local/software/jdk8 export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export JAVA_HOME PATH CLASSPATH 使用 source /etc/profile 让配置立刻生效 3、阿里云服务器SpringBoot2.x生产环境部署实战​ 简介：讲解SpringBoot生产环境部署和常见注意事项​​​ 1、去除相关生产环境没用的jar​ 比如热部署dev-tool​​ 2、本地maven打包成jar包​ mvn clean package -Dmaven.test.skip=true 跳过测试​​ 3、服务器安装jdk，上传Jar包​ 上传工具：​ windows:​ winscp​ securtyCRT​ mac：​ filezilla​ ssh root@120.79.160.143​ 访问路径 http://120.79.160.143:8080/api/v1/user/find​ java -jar xxxx.jar 守护进程、系统服务、shell脚本 打包指定配置文件 1、使用maven的profiles 2、使用springboot的profile=active 访问不了 1、阿里云防火墙是否开启，可以选择关闭，关闭是不安全的，可以选择开放端口 2、阿里云的安全访问组，开启对应的端口，如果应用是以80端口启动，则默认可以访问 4、成熟的互联网公司应该有的架构 本地提交生产代码-&gt;gitlab仓库-&gt;Jenkins自动化构建-&gt;运维或者开发人员发布 4、SpringBoot2.x监控Actuator实战上集​ 简介：讲解SpringBoot使用actuator监控配置和使用 可用性：100%，99.9% 1、介绍什么是actuator 官方介绍： Spring Boot包含许多附加功能，可帮助您在将应用程序投入生产时监视和管理应用程序。 可以选择使用HTTP端点或JMX来管理和监控您的应用程序，自动应用于审计，健康和指标收集; 一句话：springboot提供用于监控和管理生产环境的模块 官方文档：https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#production-ready 2、加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 3、加入上述依赖后，访问几个url /actuator/health /actuator/info /actuator 5、SpringBoot2.x监控Actuator实战下集及生产环境建议（核心知识)​ 简介：SpringBoot2.x监控Actuator实战下集及生产环境建议，SpringBoot新旧版本区别 注意点: 网上的资料大多数没有讲到访问的前缀 端点基础路径由 / 调整到 /actuator 如：/info调整为/actuator/info /actuator/xxx 1、只能访问几个url 1）需要在配置文件中加入下列配置 management.endpoints.web.exposure.include=* 2）官网说明：https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-actuator 原因： 出于安全考虑，除/ health和/ info之外的所有执行器默认都是禁用的。 management.endpoints.web.exposure.include属性可用于启用执行器 2、建议 在设置management.endpoints.web.exposure.include之前，请确保暴露的执行器不包含敏感信息和/ 或通过将其放置在防火墙进行控制，不对外进行使用 禁用的端点将从应用程序上下文中完全删除。如果您只想更改端点所暴露的技术，请改用 include和exclude属性 。 例子： 开启全部：management.endpoints.web.exposure.include=* 开启某个：management.endpoints.web.exposure.include=metrics 关闭某个：management.endpoints.web.exposure.exclude=metrics 或者用springadmin进行管理 相关资料：https://www.cnblogs.com/ityouknow/p/8440455.html 或者用自己编写脚本监控 CPU、内存、磁盘、nginx的http响应状态码200,404,5xx 3、介绍常用的几个 /health 查看应用健康指标 /actuator/metrics 查看应用基本指标列表 /actuator/metrics/{name} 通过上述列表，查看具体 查看具体指标 /actuator/env 显示来自Spring的 ConfigurableEnvironment的属性]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2018%2F12%2F21%2FRedis%2FReids%2F</url>
    <content type="text"><![CDATA[Jredies 参照杨开整的书 注意Netty不要使用默认的 要换成书里面的 1 JedisPoolUtil123456789101112131415161718192021222324252627282930313233343536373839404142package com.atguigu.redis.test;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;public class JedisPoolUtil &#123; private static volatile JedisPool jedisPool = null; private JedisPoolUtil()&#123;&#125; public static JedisPool getJedisPoolInstance() &#123; if(null == jedisPool) &#123; synchronized (JedisPoolUtil.class) &#123; if(null == jedisPool) &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxActive(1000); poolConfig.setMaxIdle(32); poolConfig.setMaxWait(100*1000); poolConfig.setTestOnBorrow(true); jedisPool = new JedisPool(poolConfig,"127.0.0.1",6379); &#125; &#125; &#125; return jedisPool; &#125; public static void release(JedisPool jedisPool,Jedis jedis) &#123; if(null != jedis) &#123; jedisPool.returnResourceObject(jedis); &#125; &#125; &#125; TestAPI123456789101112131415161718192021222324package com.atguigu.redis.test;import java.util.Set;import redis.clients.jedis.Jedis;public class TestAPI &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis("127.0.0.1",6379); jedis.set("k1","v1"); jedis.set("k2","v2"); jedis.set("k3","v3"); System.out.println(jedis.get("k3")); Set&lt;String&gt; sets = jedis.keys("*"); System.out.println(sets.size()); //后续请参考脑图，家庭作业，敲一遍...... &#125;&#125; TestMS1234567891011121314151617package com.atguigu.redis.test;import redis.clients.jedis.Jedis;public class TestMS &#123; public static void main(String[] args) &#123; Jedis jedis_M = new Jedis("127.0.0.1",6379); Jedis jedis_S = new Jedis("127.0.0.1",6380); jedis_S.slaveof("127.0.0.1",6379); jedis_M.set("class","1122V2"); String result = jedis_S.get("class"); System.out.println(result); &#125;&#125; TestPing1234567891011package com.atguigu.redis.test;import redis.clients.jedis.Jedis;public class TestPing &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis("127.0.0.1",6379); System.out.println(jedis.ping()); &#125;&#125; TestPool12345678910111213141516171819202122232425262728package com.atguigu.redis.test;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;public class TestPool &#123; public static void main(String[] args) &#123; JedisPool jedisPool = JedisPoolUtil.getJedisPoolInstance(); JedisPool jedisPool2 = JedisPoolUtil.getJedisPoolInstance(); System.out.println(jedisPool == jedisPool2); Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); jedis.set("aa","bb"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; JedisPoolUtil.release(jedisPool, jedis); &#125; &#125;&#125; TestTX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.atguigu.redis.test;import redis.clients.jedis.Jedis;import redis.clients.jedis.Transaction;public class TestTX &#123; public boolean transMethod() throws InterruptedException &#123; Jedis jedis = new Jedis("127.0.0.1", 6379); int balance;// 可用余额 int debt;// 欠额 int amtToSubtract = 10;// 实刷额度 jedis.watch("balance"); //jedis.set("balance","5");//此句不该出现，讲课方便。模拟其他程序已经修改了该条目 Thread.sleep(7000); balance = Integer.parseInt(jedis.get("balance")); if (balance &lt; amtToSubtract) &#123; jedis.unwatch(); System.out.println("modify"); return false; &#125; else &#123; System.out.println("***********transaction"); Transaction transaction = jedis.multi(); transaction.decrBy("balance", amtToSubtract); transaction.incrBy("debt", amtToSubtract); transaction.exec(); balance = Integer.parseInt(jedis.get("balance")); debt = Integer.parseInt(jedis.get("debt")); System.out.println("*******" + balance); System.out.println("*******" + debt); return true; &#125; &#125; /** * 通俗点讲，watch命令就是标记一个键，如果标记了一个键， * 在提交事务前如果该键被别人修改过，那事务就会失败，这种情况通常可以在程序中 * 重新再尝试一次。 * 首先标记了键balance，然后检查余额是否足够，不足就取消标记，并不做扣减； * 足够的话，就启动事务进行更新操作， * 如果在此期间键balance被其它人修改， 那在提交事务（执行exec）时就会报错， * 程序中通常可以捕获这类错误再重新执行一次，直到成功。 * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; TestTX test = new TestTX(); boolean retValue = test.transMethod(); System.out.println("main retValue-------: " + retValue); &#125; &#125; 笔记 脑图mind]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F12%2F21%2FGit%20Maven%20%2FGit%2F</url>
    <content type="text"><![CDATA[GitHub创建仓库提示代码123456echo &quot;# 项目名&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@github.com:qiubaiying/项目名.gitgit push -u origin master 若仓库存在直接push: 12git remote add origin git@github.com:qiubaiying/test.gitgit push -u origin master 常用操作创建仓库（初始化)123456在当前指定目录下创建git init新建一个仓库目录git init [project-name]克隆一个远程项目git clone [url] ##添加文件到缓存区 12345添加所有变化的文件 git add .添加名称指定文件git add text.txt 配置123设置提交代码时的用户信息git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 提交123456789101112131415161718提交暂存区到仓库区git commit -m &quot;msg&quot;# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] ##标签Tags 1234567891011121314151617181920212223添加标签 在当前commitgit tag -a v1.0 -m &apos;xxx&apos; 添加标签 在指定commitgit tag v1.0 [commit]查看git tag删除git tag -d V1.0删除远程taggit push origin :refs/tags/[tagName]推送git push origin --tags拉取git fetch origin tag V1.0新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archives]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf]]></title>
    <url>%2F2018%2F12%2F19%2FJSP%20Servlet%20Thyme%2FThymeleaf%2F</url>
    <content type="text"><![CDATA[#Thymeleaf中取值 reservation：$. {reservations}其中${reservations}的值是modeandview里面的 #reservation的值是随 便起的变量 放在reservation里面 –表格 123456 . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/]]></content>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html]]></title>
    <url>%2F2018%2F12%2F19%2FHTML%2BCSS%2BJS%2FHTML%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F15%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[邪不压正找到你让子弹飞你好 之华人不彪悍枉少年#我不是药神仙 影一本好书功夫来电狂响]]></content>
  </entry>
  <entry>
    <title><![CDATA[for 循环]]></title>
    <url>%2F2018%2F12%2F15%2Fjava%E5%9F%BA%E7%A1%80%2Ffor%E5%BE%AA%E7%8E%AF%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[for 循环 大圈套小圈#1.1for循环思想 123456789public class code4 &#123; public static void main(String[] args) &#123; for (int x = 0; x &lt; 3; x++) &#123; for (int y = 0; y &lt; 4; y++) &#123; System.out.println("ok"); &#125; &#125; &#125;&#125; 读第一个for循环初始化一个x 变量x=0： ​ 先执行x=0; 执行x&lt;3满足条件—&gt; 执行第二个for循环语句初始化一个变量y=0; ​ 先执行y=0;执行y&lt;4满足条件–&gt;打印一次ok 当内循环没有结束时循环出不去执行–&gt;y++;打印四次ok； y++=4时候y&lt;4不成立 跳出循环 y在内存中消失 –&gt;执行–x++ 满足条件 又产生一个y=0,内循环继续循环四次 所以一共打印12个ok #1.2验证doc命令行 123456789101112131415161718public class code5 &#123;/** * for循环基本思想demo1 * 输出： * ***** * ***** * ***** * ***** */ public static void main(String[] args) &#123; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; i 控制行 第一个for循环 j控制列 第二个for循环 （每一列的个数） #1.3验证doc命令行 123456789101112131415161718public class code6 &#123; /** 输出doc界面： * ***** * **** * *** * ** * * */ public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = i; j &lt; 5; j++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; 分析： #1.4验证doc 123456789101112131415161718public class code7 &#123; /** * * * ** * *** * **** * ***** */ public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; #1.5验证doc⭐️ 1234567891011121314151617public class code8 &#123; /** * 54321 * 5432 * 543 * 54 * 5 */ public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 5; j &gt; i; j--) &#123; System.out.print(j); &#125; System.out.println(); &#125; &#125;&#125; int j=5 j&gt;i j– 其中j—是关键 123456789101112131415161718public class code9 &#123; /** * 1 * 22 * 333 * 4444 * 55555 */ public static void main(String[] args) &#123; for (int i = 1; i &lt;= 5; i++) &#123; for (int j = 1; j &lt;=i; j++) &#123; System.out.print(i); &#125; System.out.println(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526public class code10 &#123; /** * * * * * * * * -* * * * * --* * * * ---* * * ----* * 由两个图形组成一个由向下的*组成 * 一个由向上的——组成 */ public static void main(String[] args) &#123; for (int i = 1; i &lt;= 5; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(" "); &#125; for (int z = i; z&lt;=5 ; z++) &#123; System.out.print("* "); &#125;System.out.println(); &#125; &#125;&#125; 分析： #1.6作 业：打印 123456789101112131415161718public class code8 &#123; /** * 54321 * 5432 * 543 * 54 * 5 */ public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 5; j &gt;i; j--) &#123; System.out.print(j); &#125;System.out.println(); &#125; &#125;&#125; 分析： 规律：for内循环 如果ji 并且让j– 1234567891011121314151617public class code9 &#123; /** * 1 * 22 * 333 * 4444 * 55555 */ public static void main(String[] args) &#123; for (int i = 1; i &lt;=5; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.print(i); &#125;System.out.println(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%89%8D%E7%AB%AF%2FJquery%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[1.获取Jquery对象1234567&lt;input type="text" id="username" value="jack"/&gt;&lt;script type="text/javascript"&gt; //jquery获得数据 语法$&#123;"选择器"&#125;==Jquery（"选择器"） var usernmae = $("#username"); //val() 函数 用于获得value属性的值 jack alert(usernmae.val());&lt;/script&gt; 2.Jquery与Dom对象的互相转换12345678910111213141516171819202122&lt;input type="text" id="username" value="jack"/&gt;&lt;script type="text/javascript"&gt; //Jquery对象和Dom对象的转换 //1。使用Javascripe获取value的值 var username = document.getElementById("username"); alert(username.value);//jack用的是属性 //2。将dom对象 转换为Jquery对象 //# 语法：$(dom对象) //# 建议 ：Jquery对象变量名字 建议以$开头 var $username = $(username); alert($username.val()); //3.将jquery对象转为Dom对象 //3.1 Jquery对象内部使用数组存放所有的数据 可以通过数组的下标获取（索引） var username2 = $username[0]; alert(username2.value); //3.2Jquery提供函数get()转换为dom对象 var username3 = $username.get(0); alert(username3.value);&lt;/script&gt; 3. 选择器3.1 基本选择器【重要】 id ,id选择器 通过id 值获得元素 element，标签选择器 通过标签名获得元素 .class 类选择器 通过class值获得元素。注意：使用点开头 s1,s2,… 多选择器，将多个选择器的结果添加一个数组中。 123456789101112131415161718192021&lt;script type="text/javascript"&gt; //window.onload=function()&#123;...&#125;匿名函数 //jquery 页面加载--&gt;function()匿名函数 $(document).ready(function () &#123; &#125;); //id选择器 为id绑定一个事件 然后传递一个函数 $("#btn1").click(function () &#123; $("#one").css("background-color", "#ff0") &#125;); //类选择器 $(".btn2").click(function () &#123; $(".one").css("background-color", "#ff0"); &#125;); //元素选择器 $("div").background = "#ff2";&lt;/script&gt;&lt;input type="button" id="btn1" value="选择id为one的元素"&gt;&lt;input type="button" class="btn2" value="选择id为one的元素"&gt; 3.2层级选择器 3.3基本过滤选择器——“：关键字“ 123456789101112131415161718192021222324252627&lt;label for="username"&gt;&lt;/label&gt;&lt;input type="text" id="username" value="jack"/&gt;&lt;script type="text/javascript"&gt; // &lt;input type="text" value="请输入账号" defaultValue="请输入账号"&gt; $("input[type='text']").on("blur focus", function () &#123; //1.获得默认值 var attr = $(this).attr("defaultValue"); //2.判断是否获得焦点 if ($(this).is(":focus")) &#123; //2.1 获得焦点，清空value值 ，this 当前执行对象 是dom对象用$(this)转为jquery对象 if ($(this).val() === attr) &#123; $(this).val(""); &#125; &#125; else &#123; //2.2失去焦点 设置默认值 if ($(this).val() === "") &#123; $(this).val(attr); &#125; &#125; &#125;);&lt;/script&gt;&lt;label&gt; &lt;input type="text" value="请输入账号" defaultValue="请输入账号"&gt; &lt;input type="text" value="请输入账号" defaultValue="请输入密码"&gt;&lt;/label&gt;&lt;/body&gt;&lt;/html&gt; 3.4内容过滤 3.5可见性过滤 （重要） 123456789101112*/// &lt;input type="button" value="选取所有可见的div元素" id="bt1"&gt;$("#b1").click(function () &#123; $("div:hidden").css("background-color", "#ff0");&#125;);// &lt;input type="button" value="选取所有不可见的元素利用jquery中的show（）将他们显示出来" id="bt2"&gt;$("#bt2").click(function () &#123; $("div:hidden").css("background-color", "#ff0");&#125;); 3.6实战 3.7属性选择器（掌握） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="js/jquery-2.1.0.js"&gt;&lt;/script&gt; &lt;!--1 ⭐️&lt;input type="button" value="选取含有属性title的div元素" id="btn1"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn1").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title]").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--2&lt;input type="button" value="选取属性title值等于"test"的div元素" id="btn2"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn2").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title='test']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--3 &lt;input type="button" value="选取属性title值不等于"test"的div元素（没有title属性的也会被选中）" id="btn3"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn2").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title！='test']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--4 &lt;input type="button" value="选取属性title值 以"te"开始的div元素（没有title属性的也会被选中）" id="btn4"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn2").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title^='te']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--5 &lt;input type="button" value="选取属性title值 以"est"结束的div元素（没有title属性的也会被选中）" id="btn5"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn2").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title$='est']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--6 &lt;input type="button" value="选取属性title值 含有"es"的div元素（没有title属性的也会被选中）" id="btn5"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn2").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[title*='es']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt; &lt;!--⭐️7&lt;input type="button" value="组合属性选择器 首先选取有属性id的div元素。然后在结果中 选取title 值含有"es"的元素"）" id="btn5"/&gt;--&gt; &lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#btn5").click(function () &#123; //&lt;xx title=""&gt; &lt;xxx title="yyy"&gt; &lt;xxx title&gt; $("div[id][title*='es']").css("background-color", "#fff0"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt; 3.8选择器 （子元素过滤） 123456789101112131415&lt;!--1 &lt;input type="button" value="选取每个class为one的div父元素下的第2个子元素" id="btn1"&gt;--&gt; &lt;script type="text/javascript"&gt; $("btn1").click(function () &#123; //子元素 选择使用前提 表达式前面必须是元素 如：$(div:nth-child(2)) //如果元素上添加 条件 必须使用空格 如$("div[class='one'] :nth-child(2)") $("div[class='one'] :nth-child(2)").css("background-color", "#ff0"); $("div.one :nth-child(2)").css("background-color", "#ff0"); &#125;); /** * 对比： * $("div.one") 所有的div自己的样式为one * $("div .one") 所有的div中后代元素 样式为one 空格 */ &lt;/script&gt; 123456789101112131415161718192021222324&lt;script type="text/javascript"&gt; $("btn1").click(function () &#123; $("div.one :first-child").css("background-color", "#ff0"); &#125;); &lt;/script&gt; &lt;!--&lt;input type="button" value="如果class为one的div父元素下的第一个子元素 " id="bt4"&gt;--&gt; &lt;script type="text/javascript"&gt; $("btn4").click(function () &#123; $("div.one :first-child").css("background-color", "#ff0"); &#125;); &lt;/script&gt; &lt;!--&lt;input type="button" value="如果class为one的div父元素下的最后一个子元素 " id="bt4"&gt;--&gt; &lt;script type="text/javascript"&gt; $("btn4").click(function () &#123; $("div.one :last-child").css("background-color", "#ff0"); &#125;); &lt;/script&gt; &lt;!--&lt;input type="button" value="如果class为one的div父元素下的仅仅只有一个子元素 " id="bt4"&gt;--&gt; &lt;script type="text/javascript"&gt; $("btn4").click(function () &#123; $("div.one :only-child").css("background-color", "#ff0"); &#125;); &lt;/script&gt; 3.9表单过滤选择器 4 表单对象属性过滤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 &lt;script src="js/jquery-2.1.0.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //1. &lt;button id="btn1"&gt;对表单内 可用input enable 赋值操作.&lt;/button&gt; $(document).ready(function () &#123; $("input:enabled").val("enabled"); &#125;); // 2 &lt;button id="btn2"&gt;对表单内 不可用input 赋值操作.&lt;/button&gt; $(document).ready(function () &#123; $("input:disabled").val("disabled"); &#125;); // 3 &lt;button id="btn3"&gt;获取多选框选中的个数.&lt;/button&gt; // &lt;input type="checkbox" name="newsletter" checked="checked" value="test1"/&gt;test1 $(document).ready(function () &#123; var s1 = $("[name='newsletter']:checked").length; // var s2 = $("[name='newsletter']:checked").size(); alert(s1) &#125;); // &lt;button id="btn4"&gt;获取下拉框选中的内容.&lt;/button&gt; $(":selected").each(function () &#123; //val()获得&lt;option &gt;如果没有value值 将获得text的值 //html（）获得标签体的内容 $("#selectDivId").append($(this).val()); // $("#selectDivId").append($(this).html()); &#125;); &lt;/script&gt; ------------ ------------ ------------ ------------ ------------ &lt;/head&gt;&lt;body&gt;&lt;h3&gt; 表单对象属性过滤选择器.&lt;/h3&gt;&lt;button type="reset"&gt;重置所有表单元素&lt;/button&gt;&lt;input type="checkbox" id="isreset" checked="checked"/&gt;&lt;label for="isreset"&gt;点击下列按钮时先自动重置页面&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;&lt;button id="btn1"&gt;对表单内 可用input 赋值操作.&lt;/button&gt;&lt;button id="btn2"&gt;对表单内 不可用input 赋值操作.&lt;/button&gt;&lt;button id="btn3"&gt;获取多选框选中的个数.&lt;/button&gt;&lt;button id="btn4"&gt;获取下拉框选中的内容.&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;可用元素：&lt;input name="add" value="可用文本框"/&gt; &lt;br/&gt;不可用元素：&lt;input name="email" disabled="disabled" value="不可用文本框"/&gt;&lt;br/&gt;可用元素： &lt;input name="che" value="可用文本框"/&gt;&lt;br/&gt;不可用元素：&lt;input name="name" disabled="disabled" value="不可用文本框"/&gt;&lt;br/&gt;&lt;br/&gt;多选框：&lt;br/&gt;&lt;input type="checkbox" name="newsletter" checked="checked" value="test1"/&gt;test1&lt;input type="checkbox" name="newsletter" value="test2"/&gt;test2&lt;input type="checkbox" name="newsletter" value="test3"/&gt;test3&lt;input type="checkbox" name="newsletter" checked="checked" value="test4"/&gt;test4&lt;input type="checkbox" name="newsletter" value="test5"/&gt;test5&lt;div id="checkboxDivId"&gt;&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;下拉列表1：&lt;br/&gt;&lt;select name="test" multiple="multiple" style="height:100px"&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option selected="selected"&gt;湖南&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option selected="selected"&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;&lt;br/&gt;下拉列表2：&lt;br/&gt;&lt;select name="test2"&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option&gt;湖南&lt;/option&gt; &lt;option selected="selected"&gt;北京&lt;/option&gt; &lt;option&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;&lt;br/&gt;&lt;div id="selectDivId"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5 选择器案例1234567891011121314151617181920 &lt;script type="text/javascript"&gt; $(document).ready(function () &#123;//从第5个开始 不要最后一个控制显示和隐藏 //1 隐藏 var $allLi = $("li:gt(4):not(:last)"); $allLi.hide();//2 点击显示 $("span").click(function () &#123; //$allLi.show(); // $allLi.toggle(); if ($allLi.is(":hidden")) &#123; $allLi.show(); $(this).html("隐藏"); &#125; else &#123; $allLi.hide(); $(this).html("显示"); &#125; &#125;); &#125;); &lt;/script&gt; 6 属性 CSS 123456789&lt;script type="text/javascript"&gt; $(document).ready(function () &#123; //1.设置姓名文本框不可用 // &lt;input type="text" name="username" class="textClass" value="jack"/&gt; $("[name='username']").attr("disabled", "disabled"); // 2 .设置姓名文本框可用 移除属性 $("[name='username']").removeAttr("disabled"); &#125;);&lt;/script&gt; CSS 类 123456789 //text /html alert($("div").text());// 未满18慎进 alert($("div").html());//&lt;a&gt;未满18慎进&lt;/a&gt;alert($("div").html());//&lt;a&gt;未满18慎进&lt;/a&gt; $("div").text("&lt;a href='Demo5.html'&gt;你点我呀&lt;/a&gt;");// 未满18慎进 $("div").html("&lt;a href='Demo5.html'&gt;你点我呀&lt;/a&gt;");//&lt;a&gt;未满18慎进&lt;/a&gt; &#125;);&lt;/script&gt; 7 CSS12345678/设置CSS $("div").css(&#123; "width": "200px", "height": "222px", "font-size": "60px", "color": "#f00", &#125;); 8 文档处理8.1 内部插入「掌握」 实战： 8.2 外部插入「掌握」 实战： 8.3 删除 「掌握」 1234567891011121314&lt;script type="text/javascript"&gt; //将city移除 在追加到body后面 //1.绑定事件 $(document).ready(function () &#123; //2.绑定数据 $("#city").data("ithe", "厉害"); //1。移除 var $city = $("#city").remove(); //var $city = $("#city").detach();//保留绑定的事件 //2 追加 $("body").append($city); //3 获得绑定的数据 alert($("#city").data("ithe")); &#125;); 9.文档处理 克隆 替换包裹 Day 02 123456789101112131415&lt;script type="text/javascript"&gt; $(document).ready(function () &#123; $("#left1").click(function () &#123; $("#leftSelectId option:first").appendTo("#rightSelectId") &#125;); $("#left2").click(function () &#123; //选中哪一个 就过哪一个 $("#leftSelectId option:selected").appendTo("#rightSelectId") &#125;); $("#left3").click(function () &#123; $("#leftSelectId option").appendTo("#rightSelectId") &#125;); &#125;); &lt;/script&gt; 10 筛选过滤 选择器可以完成功能 筛选提供相同的函数 查找 串联 将多条语句改成一条 得瑟代码 案例：QQ分组 11 事件常见事件 页面加载 事件绑定[重要] 委派 切换 12 动画效果 13 Ajax「重要 掌握」 异步刷新 Load()函数1234567891011121314151617181920212223242526$(function () &#123; $("input").click(function () &#123; var url = "/"; var params = &#123;"username": "jack", "password": "1234"&#125;; /** * load()函数 必须使用jquery对象 * 格式load(url,[data],[callback]) * 参数1：url 请求路径 * 参数2：data 请求参数 * 参数3：callback 回调函数 * *如果没有请求参数 发送的GET请求 * *如果有请求参数 发送的POST请求 请求没有中文乱码； *回调函数的参数 * ：参数1 data响应数据 load()永远获得字符串 如果需要使用 * 必须手动转换成json格式； * */ $(this).load(url, params, function (data) &#123; //转换JSON对象 var jsonData = eval("(" + data + ")"); alert(jsonData.message); &#125;); &#125;); &#125;) $.post $.$.get1234567891011121314151617181920212223242526272829303132 /** * $.get() 全局函数 发送get请求 * *格式 jquery.get(URl,[data],[callback],[type]) * *参数4 type * *GET请求不适合发送中文数据 存放请求的中文乱码 * 必须手动解码 new String(username,getBytes("ISO-8859-1",UTF-8")) 响应数据 如果使用application/json；charset=UTF-8,jquery自动将数据转换JSON对象 响应数据 如果使用text/html；charset=UTF-8 ，回调函数获得字符串数据 需要手动转换 使用"参数4" 设置"json" Jquery将字符串 转换为json对象 */ $.get(url, params, function () &#123; alert(data); &#125;, "json"); /** * post()全局函数 发送post请求 * * 格式：jquery.post(url,data[],[callback],[type]) $.post(url,params,function(data)&#123; alert(data); &#125;,"json") */ $.post(utl, params, function (data) &#123; alert(data); &#125;, "json") &#125;);&#125;) $.ajax()$ 1234567891011121314151617181920212223242526272829$(function () &#123; $("input").click(function () &#123; /** * 4.$.ajax() 底层功能最强大的 * 格式 Jquery.ajax（[settings]） * 参数 settings:设置所有的参数 * url:发送请求的地址 * data:发送到服务器的数据 请求参数， * type: 请求方式（"POST"或"GET"）， * * success:成功的回调函数 * error 错误函数 * dateType:响应数据类型 */ $.ajax(&#123; "url": "/", "data": "params", "type": "POST", "success": function (data) &#123; alert(data); &#125;, "error": function () &#123; alert("服务器繁忙") &#125;, "dateType": "json" &#125;); &#125;); &#125;) 处理实战123456789101112131415161718192021222324252627282930313233343536373839&lt;script type="text/javascript"&gt; $(function () &#123; // &lt;input id="h01" type="button" value="1只能点击一次，之后失效"/&gt; $("#h01").one("click.a", function () &#123; alert("你只能看到我一次");//继续点击失效 &#125;); // &lt;input id="h02" type="button" value="2可以点击多次"/&gt; $("#h02").bind("click.b", function () &#123; alert("每次都是你"); &#125;); // &lt;input id="h03" type="button" value="3解绑2"/&gt; $("#h03").click(function () &#123; $("#h02").unbind("click.b"); &#125;); // &lt;input type="button" value="4 添加一个按钮，样式为myClass，且拥有相同的事件" class="myClass"/&gt; $(".myClass").live("click", function () &#123; $("body").append("&lt;input type='button' class='myClass'&gt;") &#125;); // &lt;input id="h05" type="button" value="5 解绑4"/&gt; $("#h05").click(function () &#123; $(".myClass").die("click"); &#125;); //切换 $(function () &#123; $("#e01").toggle(function () &#123; alert("报数1"); &#125;, function () &#123; alert("报数2"); &#125;); $("#e02").hover(function () &#123; $("#divMsg").html("over"); &#125;, function () &#123; $("#divMsg").html("out"); &#125;) &#125;) &#125;); &lt;/script&gt; 14 其他表单序列化 事件冒泡 浏览器默认的动作行为 Jquery文档1.8.3]]></content>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯随笔]]></title>
    <url>%2F2018%2F12%2F14%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[一些笔记1.Java整型与字符串相互转换(转) ####1如何将字串 String 转换成整数 int? 有两个方法: 1) int i = Integer.parseInt([String]); ​ i = Integer.parseInt([String],[int radix]); 2). int i = Integer.valueOf(my_str).intValue(); 注: 字串转成 Double, Float, L #####2 如何将整数 int 转换成字串 String ? A. 有叁种方法: 1.) String s = String.valueOf(i); 2.) String s = Integer.toString(i); 3.) String s = “” + i; 注: Double, Float, Long 转成字串的方法大同小异. &amp;&amp; : 逻辑与 当前仅当两个操作数都为真的时候条件才为真|| ： 逻辑或 如果任何两个操作数任何一个为真 条件为真]]></content>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F12%2F13%2FMybatis%2F%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[—]]></content>
  </entry>
  <entry>
    <title><![CDATA[类加载器]]></title>
    <url>%2F2018%2F12%2F12%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%20%2F</url>
    <content type="text"><![CDATA[1.ClassLoader##1.1什么是类加载器]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC 及bean容器 注入]]></title>
    <url>%2F2018%2F12%2F10%2FSpring%2F4.SpringBean%20%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1 Spring Bean 装配之Bean的定义及其作用域的注解实现 ​ &lt; context:component-scan&gt; 例子123&lt;context:component-scan base-package="bean.BeanAnnotation"&gt; &lt;context:component-scan/&gt; 1234567package bean;@Componentpublic class BeanAnnotation &#123; public void say()&#123; System,out.print("Hello Spring"); &#125;&#125; 1234 @Test BeanAnnotation bean=super.getBean("beanAnnotation");//类名小写 bean.say("This is Tese");&#125; 2 Spring装配 基于java容器的注解说明 @importResource和@Value 123456789public class MyDriverManager &#123; public MyDriverManager(String url, String userName, String password) &#123; System.out.print(url); System.out.print(userName); System.out.print(password); &#125;&#125; 123456789101112131415161718@Configuration@ImportResource("classpath:config.xml")public class StoreConfig &#123; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; @Bean public MyDriverManager myDriverManager() &#123; return new MyDriverManager(url, username, password); &#125;&#125; 12345678public class Test &#123; @Test public void testMyDreiverManager() &#123; MyDriverManager myDriverManager = super.getBean("myDriverManager"); myDriverManager.getClass().getName(); &#125;&#125; 123jdbc.password=rootjdbc.url=127.0.0.1jdbc.username=root 3@Bean 和@Scope 4基于泛型的自动装配 Aware 和Autowiring]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F12%2F10%2Fjava%E5%9F%BA%E7%A1%80%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031public class ClassDemo1 &#123; public static void main(String[] args) &#123; // Foo的实例对象如何表示 Foo foo1 = new Foo();// foo1就表示出来了 // Foo 这个类 也是个实例对象 ，Class类的实列对象 如何表示呢 // 任何一个类都是Class的实列对象 这个实列对象有三种表示方式 /** * c1 c2表示了Foo类的类类型（class type） * 万事万物皆对象 * 类也是对象 是Class类的实列对象 * 这个对象我们称为该类的lei lei */ // 第一种表示方式---&gt;实际在告诉我们任何一个类都以一个隐含的静态成员 Class c1=Foo.class; // 第二种表示方式--&gt;已经知道该类的对象通过getClass方法 Class c2 = foo1.getClass(); //第三种方式 Class c3=Class.forName("com.package.Foo") &#125; // 我们完全可以通过类类型创建该类的对象实列 // --&gt;通过c1 or c2 创建Foo的实例 Foo foo = (Foo) c1.newInstance();foo.print(); class Foo &#123; void print() &#123; &#125; &#125;&#125; 123456789101112131415161718package com.imooc.reflect;public class ClassDemo2 &#123; public static void main(String[] args) &#123; Class c1 = int.class;//int 的类类型 Class c2 = String.class;//String类的类类型 String类字节码（自己发明的) Class c3 = double.class; Class c4 = Double.class; Class c5 = void.class; System.out.println(c1.getName()); System.out.println(c2.getName()); System.out.println(c2.getSimpleName());//不包含包名的类的名称 System.out.println(c5.getName()); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.imooc.reflect;public class ClassDemo1 &#123; public static void main(String[] args) &#123; //Foo的实例对象如何表示 Foo foo1 = new Foo();//foo1就表示出来了. //Foo这个类 也是一个实例对象，Class类的实例对象,如何表示呢 //任何一个类都是Class的实例对象，这个实例对象有三种表示方式 //第一种表示方式---&gt;实际在告诉我们任何一个类都有一个隐含的静态成员变量class Class c1 = Foo.class; //第二中表达方式 已经知道该类的对象通过getClass方法 Class c2 = foo1.getClass(); /*官网 c1 ,c2 表示了Foo类的类类型(class type) * 万事万物皆对象， * 类也是对象，是Class类的实例对象 * 这个对象我们称为该类的类类型 * */ //不管c1 or c2都代表了Foo类的类类型，一个类只可能是Class类的一个实例对象 System.out.println(c1 == c2); //第三种表达方式 Class c3 = null; try &#123; c3 = Class.forName("com.imooc.reflect.Foo"); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(c2==c3); //我们完全可以通过类的类类型创建该类的对象实例----&gt;通过c1 or c2 or c3创建Foo的实例对象 try &#123; Foo foo = (Foo)c1.newInstance();//需要有无参数的构造方法 foo.print(); &#125; catch (InstantiationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;class Foo&#123; void print()&#123; System.out.println("foo"); &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.imooc.reflect;import java.lang.reflect.Method;public class BeanUtil &#123; /** * 根据标准javaBean对象的属性名获取其属性值 * * @param obj * @param propertyName * @return */ public static Object getValueByPropertyName(Object obj, String propertyName) &#123; // 1.根据属性名称就可以获取其get方法 String getMethodName = "get" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1); //2.获取方法对象 Class c = obj.getClass(); try &#123; //get方法都是public的且无参数 Method m= c.getMethod(getMethodName); //3 通过方法的反射操作方法 Object value = m.invoke(obj); return value; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.imooc.reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ClassUtil &#123; /** * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数) * @param obj 该对象所属类的信息 */ public static void printClassMethodMessage(Object obj)&#123; //要获取类的信息 首先要获取类的类类型 Class c = obj.getClass();//传递的是哪个子类的对象 c就是该子类的类类型 //获取类的名称 System.out.println("类的名称是:"+c.getName()); /* * Method类，方法对象 * 一个成员方法就是一个Method对象 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限 */ Method[] ms = c.getMethods();//c.getDeclaredMethods() for(int i = 0; i &lt; ms.length;i++)&#123; //得到方法的返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName()+" "); //得到方法的名称 System.out.print(ms[i].getName()+"("); //获取参数类型---&gt;得到的是参数列表的类型的类类型 Class[] paramTypes = ms[i].getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125; /** * 获取成员变量的信息 * @param obj */ public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); /* * 成员变量也是对象 * java.lang.reflect.Field * Field类封装了关于成员变量的操作 * getFields()方法获取的是所有的public的成员变量的信息 * getDeclaredFields获取的是该类自己声明的成员变量的信息 */ //Field[] fs = c.getFields(); Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; //得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName+" "+fieldName); &#125; &#125; /** * 打印对象的构造函数的信息 * @param obj */ public static void printConMessage(Object obj)&#123; Class c = obj.getClass(); /* * 构造函数也是对象 * java.lang. Constructor中封装了构造函数的信息 * getConstructors获取所有的public的构造函数 * getDeclaredConstructors得到所有的构造函数 */ //Constructor[] cs = c.getConstructors(); Constructor[] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName()+"("); //获取构造函数的参数列表---&gt;得到的是参数列表的类类型 Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 Rabbit MQ 老师源代码]]></title>
    <url>%2F2018%2F12%2F05%2FRabbitMQ%2Fquickstart%2F</url>
    <content type="text"><![CDATA[慕课网 Rabbit MQ 老师源代码12345678910111213141516171819202122232425262728public class Procuder &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 通过Channel发送数据 for(int i=0; i &lt; 5; i++)&#123; String msg = &quot;Hello RabbitMQ!&quot;; //1 exchange 2 routingKey channel.basicPublish(&quot;&quot;, &quot;test001&quot;, null, msg.getBytes()); &#125; //5 记得要关闭相关的连接 channel.close(); connection.close(); &#125;&#125; quickstart12345678910111213141516171819202122232425262728293031package com.example.rabbitmq.start;import org.springframework.boot.SpringApplication;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class Procuder &#123; // 生产端Procuder http://94.191.24.33:15672/#/ public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;94.191.24.33&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); // 2.通过连接工厂创建连接connectionFactory.newConnection(); Connection connection = connectionFactory.newConnection(); // 3.通过connection创建一个Channel Channel channel = connection.createChannel(); // 4.通过Channel发送数据 String msg = &quot;Hello RabbitMQ&quot;; // channel.basicPublish(exchange, routingKey, props, body); channel.basicPublish(&quot;&quot;, &quot;test001&quot;, null, msg.getBytes()); channel.close(); connection.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.rabbitmq.start;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import com.rabbitmq.client.QueueingConsumer;import com.rabbitmq.client.QueueingConsumer.Delivery;public class Consumer &#123; @SuppressWarnings(&quot;deprecation&quot;) public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory，并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;94.191.24.33&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); // 2.通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); // 3 通过连接工厂创建连接 Channel channel = connection.createChannel(); // 4.申明（创建）一个队列 String queueName = &quot;test001&quot;; // channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments) channel.queueDeclare(&quot;test001&quot;, true, false, false, null); // 5.创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); /** * 6.设置channel # channel.basicConsume(queue,autoAck, autoAck) # 1：queue：队列的名字 * 2.autoAck：是否自动签收 3:autoAck：具体的消费者对象 */ channel.basicConsume(queueName, true, queueingConsumer); // 7.获取消息 while (true) &#123; Delivery delivery = queueingConsumer.nextDelivery(); byte[] body = delivery.getBody(); String msg = new String(delivery.getBody());// 获取消息 System.out.println(&quot;消费端&quot; + msg); &#125; &#125;&#125;//String string =new String(delivery.getBody()); 12345678910111213141516171819202122232425262728293031323334353637public class Consumer &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 声明（创建）一个队列 String queueName = &quot;test001&quot;; channel.queueDeclare(queueName, true, false, false, null); //5 创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); //6 设置Channel channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; //7 获取消息 Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费端: &quot; + msg); //Envelope envelope = delivery.getEnvelope(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829public class Procuder &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 通过Channel发送数据 for(int i=0; i &lt; 5; i++)&#123; String msg = &quot;Hello RabbitMQ!&quot;; //1 exchange 2 routingKey channel.basicPublish(&quot;&quot;, &quot;test001&quot;, null, msg.getBytes()); &#125; //5 记得要关闭相关的连接 channel.close(); connection.close(); &#125;&#125; apiack1234567891011121314151617181920212223242526272829public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_ack_exchange&quot;; String queueName = &quot;test_ack_queue&quot;; String routingKey = &quot;ack.#&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); // 手工签收 必须要关闭 autoAck = false channel.basicConsume(queueName, false, new MyConsumer(channel)); &#125;&#125; 1234567891011121314151617181920212223242526272829public class MyConsumer extends DefaultConsumer &#123; private Channel channel ; public MyConsumer(Channel channel) &#123; super(channel); this.channel = channel; &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;body: &quot; + new String(body)); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if((Integer)properties.getHeaders().get(&quot;num&quot;) == 0) &#123; channel.basicNack(envelope.getDeliveryTag(), false, true); &#125; else &#123; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_ack_exchange&quot;; String routingKey = &quot;ack.save&quot;; for(int i =0; i&lt;5; i ++)&#123; Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;(); headers.put(&quot;num&quot;, i); AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .deliveryMode(2) .contentEncoding(&quot;UTF-8&quot;) .headers(headers) .build(); String msg = &quot;Hello RabbitMQ ACK Message &quot; + i; channel.basicPublish(exchange, routingKey, true, properties, msg.getBytes()); &#125; &#125;&#125; confirm1234567891011121314151617181920212223242526272829303132333435363738public class Consumer &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 获取C onnection Connection connection = connectionFactory.newConnection(); //3 通过Connection创建一个新的Channel Channel channel = connection.createChannel(); String exchangeName = &quot;test_confirm_exchange&quot;; String routingKey = &quot;confirm.#&quot;; String queueName = &quot;test_confirm_queue&quot;; //4 声明交换机和队列 然后进行绑定设置, 最后制定路由Key channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); //5 创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费端: &quot; + msg); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Producer &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 获取C onnection Connection connection = connectionFactory.newConnection(); //3 通过Connection创建一个新的Channel Channel channel = connection.createChannel(); //4 指定我们的消息投递模式: 消息的确认模式 channel.confirmSelect(); String exchangeName = &quot;test_confirm_exchange&quot;; String routingKey = &quot;confirm.save&quot;; //5 发送一条消息 String msg = &quot;Hello RabbitMQ Send confirm message!&quot;; channel.basicPublish(exchangeName, routingKey, null, msg.getBytes()); //6 添加一个确认监听 channel.addConfirmListener(new ConfirmListener() &#123; @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException &#123; System.err.println(&quot;-------no ack!-----------&quot;); &#125; @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException &#123; System.err.println(&quot;-------ack!-----------&quot;); &#125; &#125;); &#125;&#125; Consumer123456789101112131415161718192021222324252627public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_consumer_exchange&quot;; String routingKey = &quot;consumer.#&quot;; String queueName = &quot;test_consumer_queue&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); channel.basicConsume(queueName, true, new MyConsumer(channel)); &#125;&#125; 123456789101112131415161718public class MyConsumer extends DefaultConsumer &#123; public MyConsumer(Channel channel) &#123; super(channel); &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;consumerTag: &quot; + consumerTag); System.err.println(&quot;envelope: &quot; + envelope); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); &#125;&#125; 12345678910111213141516171819202122232425public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_consumer_exchange&quot;; String routingKey = &quot;consumer.save&quot;; String msg = &quot;Hello RabbitMQ Consumer Message&quot;; for(int i =0; i&lt;5; i ++)&#123; channel.basicPublish(exchange, routingKey, true, null, msg.getBytes()); &#125; &#125;&#125; dlx12345678910111213141516171819202122232425262728293031323334353637public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); // 这就是一个普通的交换机 和 队列 以及路由 String exchangeName = &quot;test_dlx_exchange&quot;; String routingKey = &quot;dlx.#&quot;; String queueName = &quot;test_dlx_queue&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); Map&lt;String, Object&gt; agruments = new HashMap&lt;String, Object&gt;(); agruments.put(&quot;x-dead-letter-exchange&quot;, &quot;dlx.exchange&quot;); //这个agruments属性，要设置到声明队列上 channel.queueDeclare(queueName, true, false, false, agruments); channel.queueBind(queueName, exchangeName, routingKey); //要进行死信队列的声明: channel.exchangeDeclare(&quot;dlx.exchange&quot;, &quot;topic&quot;, true, false, null); channel.queueDeclare(&quot;dlx.queue&quot;, true, false, false, null); channel.queueBind(&quot;dlx.queue&quot;, &quot;dlx.exchange&quot;, &quot;#&quot;); channel.basicConsume(queueName, true, new MyConsumer(channel)); &#125;&#125; 123456789101112131415public class MyConsumer extends DefaultConsumer &#123; public MyConsumer(Channel channel) &#123; super(channel); &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;consumerTag: &quot; + consumerTag); System.err.println(&quot;envelope: &quot; + envelope); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); &#125; 123456789101112131415161718192021222324252627282930public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_dlx_exchange&quot;; String routingKey = &quot;dlx.save&quot;; String msg = &quot;Hello RabbitMQ DLX Message&quot;; for(int i =0; i&lt;1; i ++)&#123; AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .deliveryMode(2) .contentEncoding(&quot;UTF-8&quot;) .expiration(&quot;10000&quot;) .build(); channel.basicPublish(exchange, routingKey, true, properties, msg.getBytes()); &#125; &#125;&#125; exchange–direct123456789101112131415161718192021222324252627282930313233343536373839404142public class Consumer4DirectExchange &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory() ; connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); connectionFactory.setAutomaticRecoveryEnabled(true); connectionFactory.setNetworkRecoveryInterval(3000); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_direct_exchange&quot;; String exchangeType = &quot;direct&quot;; String queueName = &quot;test_direct_queue&quot;; String routingKey = &quot;test.direct&quot;; //表示声明了一个交换机 channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null); //表示声明了一个队列 channel.queueDeclare(queueName, false, false, false, null); //建立一个绑定关系: channel.queueBind(queueName, exchangeName, routingKey); //durable 是否持久化消息 QueueingConsumer consumer = new QueueingConsumer(channel); //参数：队列名称、是否自动ACK、Consumer channel.basicConsume(queueName, true, consumer); //循环获取消息 while(true)&#123; //获取消息，如果没有消息，这一步将会一直阻塞 Delivery delivery = consumer.nextDelivery(); String msg = new String(delivery.getBody()); System.out.println(&quot;收到消息：&quot; + msg); &#125; &#125;&#125; 1234567891011121314151617181920212223242526public class Producer4DirectExchange &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 创建Connection Connection connection = connectionFactory.newConnection(); //3 创建Channel Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_direct_exchange&quot;; String routingKey = &quot;test.direct111&quot;; //5 发送 String msg = &quot;Hello World RabbitMQ 4 Direct Exchange Message 111 ... &quot;; channel.basicPublish(exchangeName, routingKey , null , msg.getBytes()); &#125; &#125; Exchange-fanout12345678910111213141516171819202122232425262728293031323334353637public class Consumer4FanoutExchange &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory() ; connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); connectionFactory.setAutomaticRecoveryEnabled(true); connectionFactory.setNetworkRecoveryInterval(3000); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_fanout_exchange&quot;; String exchangeType = &quot;fanout&quot;; String queueName = &quot;test_fanout_queue&quot;; String routingKey = &quot;&quot;; //不设置路由键 channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null); channel.queueDeclare(queueName, false, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); //durable 是否持久化消息 QueueingConsumer consumer = new QueueingConsumer(channel); //参数：队列名称、是否自动ACK、Consumer channel.basicConsume(queueName, true, consumer); //循环获取消息 while(true)&#123; //获取消息，如果没有消息，这一步将会一直阻塞 Delivery delivery = consumer.nextDelivery(); String msg = new String(delivery.getBody()); System.out.println(&quot;收到消息：&quot; + msg); &#125; &#125;&#125; 123456789101112131415161718192021222324252627public class Producer4FanoutExchange &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 创建Connection Connection connection = connectionFactory.newConnection(); //3 创建Channel Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_fanout_exchange&quot;; //5 发送 for(int i = 0; i &lt; 10; i ++) &#123; String msg = &quot;Hello World RabbitMQ 4 FANOUT Exchange Message ...&quot;; channel.basicPublish(exchangeName, &quot;&quot;, null , msg.getBytes()); &#125; channel.close(); connection.close(); &#125; &#125; Exchange -topic123456789101112131415161718192021222324252627282930313233343536373839404142public class Consumer4TopicExchange &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory() ; connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); connectionFactory.setAutomaticRecoveryEnabled(true); connectionFactory.setNetworkRecoveryInterval(3000); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_topic_exchange&quot;; String exchangeType = &quot;topic&quot;; String queueName = &quot;test_topic_queue&quot;; //String routingKey = &quot;user.*&quot;; String routingKey = &quot;user.*&quot;; // 1 声明交换机 channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null); // 2 声明队列 channel.queueDeclare(queueName, false, false, false, null); // 3 建立交换机和队列的绑定关系: channel.queueBind(queueName, exchangeName, routingKey); //durable 是否持久化消息 QueueingConsumer consumer = new QueueingConsumer(channel); //参数：队列名称、是否自动ACK、Consumer channel.basicConsume(queueName, true, consumer); //循环获取消息 while(true)&#123; //获取消息，如果没有消息，这一步将会一直阻塞 Delivery delivery = consumer.nextDelivery(); String msg = new String(delivery.getBody()); System.out.println(&quot;收到消息：&quot; + msg); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031public class Producer4TopicExchange &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 创建Connection Connection connection = connectionFactory.newConnection(); //3 创建Channel Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_topic_exchange&quot;; String routingKey1 = &quot;user.save&quot;; String routingKey2 = &quot;user.update&quot;; String routingKey3 = &quot;user.delete.abc&quot;; //5 发送 String msg = &quot;Hello World RabbitMQ 4 Topic Exchange Message ...&quot;; channel.basicPublish(exchangeName, routingKey1 , null , msg.getBytes()); channel.basicPublish(exchangeName, routingKey2 , null , msg.getBytes()); channel.basicPublish(exchangeName, routingKey3 , null , msg.getBytes()); channel.close(); connection.close(); &#125; &#125; limit1234567891011121314151617181920212223242526272829303132public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_qos_exchange&quot;; String queueName = &quot;test_qos_queue&quot;; String routingKey = &quot;qos.#&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); //1 限流方式 第一件事就是 autoAck设置为 false channel.basicQos(0, 1, false); channel.basicConsume(queueName, false, new MyConsumer(channel)); &#125;&#125; 123456789101112131415161718192021222324public class MyConsumer extends DefaultConsumer &#123; private Channel channel ; public MyConsumer(Channel channel) &#123; super(channel); this.channel = channel; &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;consumerTag: &quot; + consumerTag); System.err.println(&quot;envelope: &quot; + envelope); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125;&#125; 123456789101112131415161718192021222324public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_qos_exchange&quot;; String routingKey = &quot;qos.save&quot;; String msg = &quot;Hello RabbitMQ QOS Message&quot;; for(int i =0; i&lt;5; i ++)&#123; channel.basicPublish(exchange, routingKey, true, null, msg.getBytes()); &#125; &#125;&#125; message123456789101112131415161718192021222324252627282930313233343536373839public class Consumer &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 声明（创建）一个队列 String queueName = &quot;test001&quot;; channel.queueDeclare(queueName, true, false, false, null); //5 创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); //6 设置Channel channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; //7 获取消息 Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费端: &quot; + msg); Map&lt;String, Object&gt; headers = delivery.getProperties().getHeaders(); System.err.println(&quot;headers get my1 value: &quot; + headers.get(&quot;my1&quot;)); //Envelope envelope = delivery.getEnvelope(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940public class Procuder &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;(); headers.put(&quot;my1&quot;, &quot;111&quot;); headers.put(&quot;my2&quot;, &quot;222&quot;); AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .deliveryMode(2) .contentEncoding(&quot;UTF-8&quot;) .expiration(&quot;10000&quot;) .headers(headers) .build(); //4 通过Channel发送数据 for(int i=0; i &lt; 5; i++)&#123; String msg = &quot;Hello RabbitMQ!&quot;; //1 exchange 2 routingKey channel.basicPublish(&quot;&quot;, &quot;test001&quot;, properties, msg.getBytes()); &#125; //5 记得要关闭相关的连接 channel.close(); connection.close(); &#125;&#125; returnlistener12345678910111213141516171819202122232425262728293031323334public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_return_exchange&quot;; String routingKey = &quot;return.#&quot;; String queueName = &quot;test_return_queue&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); QueueingConsumer queueingConsumer = new QueueingConsumer(channel); channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费者: &quot; + msg); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_return_exchange&quot;; String routingKey = &quot;return.save&quot;; String routingKeyError = &quot;abc.save&quot;; String msg = &quot;Hello RabbitMQ Return Message&quot;; channel.addReturnListener(new ReturnListener() &#123; @Override public void handleReturn(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;---------handle return----------&quot;); System.err.println(&quot;replyCode: &quot; + replyCode); System.err.println(&quot;replyText: &quot; + replyText); System.err.println(&quot;exchange: &quot; + exchange); System.err.println(&quot;routingKey: &quot; + routingKey); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); &#125; &#125;); channel.basicPublish(exchange, routingKeyError, true, null, msg.getBytes()); //channel.basicPublish(exchange, routingKeyError, true, null, msg.getBytes());&#125;&#125;]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[千峰RabbitMQ 老师源代码]]></title>
    <url>%2F2018%2F12%2F05%2FRabbitMQ%2F%E5%8D%83%E5%B3%B0%20Rabbit%20MQ%20%E8%80%81%E5%B8%88%E6%BA%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[千峰 Rabbit MQ 老师源代码hello123456789101112131415161718192021public class Recver &#123; private final static String QUEUE = &quot;testhello&quot;;//队列的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE,false,false,false,null); QueueingConsumer consumer =new QueueingConsumer(channel);//定义一个消费者,QueueingConsumer已经过时,建议使用DefaultConsumer子类 //接收消息 ,参数2 是自动确认 channel.basicConsume(QUEUE, true, consumer); while (true) &#123; //获取消息 QueueingConsumer.Delivery delivery = consumer.nextDelivery();//如果没有消息会等待,有的话就获取执行然后销毁,是一次性的 String message = new String(delivery.getBody()); System.out.println(message); &#125; &#125;&#125; 123456789101112131415161718192021222324public class Sender &#123; private final static String QUEUE = &quot;testhello&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; //获取连接 Connection connection = ConnextionUtil.getConnection(); //创建通道 Channel channel = connection.createChannel(); //声明队列,如果队列存在则什么都不做,如果不存在才创建 // 参数1 队列的名字 //参数2 是否持久化队列,我们的队列模式是在内存中的,如果 rabbitmq 重启会丢失,如果我们设置为 true, 则会保存到 erlang 自带的数据库中,重启后会重新读取 //参数3 是否排外,有两个作用,第一个当我们的连接关闭后是否会自动删除队列,作用二 是否私有当天前队列,如果私有了,其他通道不可以访问当前队列,如果为 true, 一般是一个队列只适用于一个消费者的时候 //参数4 是够自动删除 //参数5 我们的一些其他参数 channel.queueDeclare(QUEUE, false, false, false, null); //发送内容 channel.basicPublish(&quot;&quot;,QUEUE,null,&quot;发送的消息&quot;.getBytes()); //关闭连接 channel.close(); connection.close(); &#125;&#125; persist1234567891011121314151617181920public class Recver &#123; private static String EXCHANGE_NAME = &quot;testpersist&quot;; private static String QUEUE_NAME = &quot;testpersistqueue&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;, true, false, null); //声明持久化的队列 channel.queueDeclare(QUEUE_NAME, true, false, false, null); channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,&quot;abc&quot;); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;收到消息:&quot;+new String(body)); &#125; &#125;; channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 12345678910111213141516public class Sender &#123; private static String EXCHANGE_NAME = &quot;testpersist&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); //声明持久化的交换机 channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;, true, false, null); //声明持久化消息 channel.basicPublish(EXCHANGE_NAME, &quot;abc&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, &quot;持久化的消息&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; publish123456789101112131415161718192021222324public class Recver1 &#123; private final static String EXCHANGE_NAME = &quot;testexchange&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testpubqueue1&quot;, false, false, false,null); //绑定队列到交换机 channel.queueBind(&quot;testpubqueue1&quot;, EXCHANGE_NAME, &quot;&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者11111111:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testpubqueue1&quot;, false, consumer); &#125;&#125; 1234567891011121314151617181920public class Recver2 &#123; private final static String EXCHANGE_NAME = &quot;testexchange&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testpubqueue2&quot;, false, false, false,null); //绑定队列到交换机 channel.queueBind(&quot;testpubqueue2&quot;, EXCHANGE_NAME, &quot;&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者2222222:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testpubqueue2&quot;, false, consumer); &#125;&#125; 1234567891011121314public class Sender &#123; private final static String EXCHANGE_NAME = &quot;testexchange&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);//定义一个交换机,类型是fanout,也就是发布订阅模式 //发布订阅模式的,因为消息是先发到交换机中,而交换机是没有保存功能的,所以如果没有消费者,消息会丢失 channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, &quot;发布订阅模式的消息&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; ##route 12345678910111213141516171819202122232425public class Recver1 &#123; private final static String EXCHANGE_NAME = &quot;testeoute&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testroutequeue1&quot;, false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 // 绑定队列到交换机,绑定自己的关键字 key 为key,注意在绑定到指定路由(交换机)的时候,该路由必须存在,也就是我们必须先由发送者创建一个路由才可以 channel.queueBind(&quot;testroutequeue1&quot;, EXCHANGE_NAME, &quot;key1&quot;); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind(&quot;testroutequeue1&quot;, EXCHANGE_NAME, &quot;key2&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者11111111:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testroutequeue1&quot;, false, consumer); &#125;&#125; 1234567891011121314151617181920212223public class Recver2 &#123; private final static String EXCHANGE_NAME = "testeoute";//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare("testroutequeue2", false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 channel.queueBind("testroutequeue2", EXCHANGE_NAME, "key1"); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind("testroutequeue2", EXCHANGE_NAME, "key3"); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println("消费者22222:"+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume("testroutequeue2", false, consumer); &#125;&#125; 123456789101112public class Sender &#123; private final static String EXCHANGE_NAME = &quot;testeoute&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);//定义路由格式的交换机 channel.basicPublish(EXCHANGE_NAME, &quot;key3&quot;, null, &quot;路由消息&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; ##spring 12345678910 */public class MyConsumer &#123; /** * 用于接收消息 * @param message */ public void test(String message) &#123; System.err.println(message); &#125;&#125; 12345678public class SpringTest &#123; public static void main(String[] args) throws Exception&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); RabbitTemplate template = context.getBean(RabbitTemplate.class); template.convertAndSend(&quot;spring 的消息&quot;); ((ClassPathXmlApplicationContext) context).destroy(); &#125;&#125; spring212345678@Component(&quot;confirmCallBackListener&quot;)public class ConfirmCallBackListener implements RabbitTemplate.ConfirmCallback &#123; @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; System.err.println(&quot;确认回调 ack==&quot;+ack+&quot; cause==&quot;+cause); &#125;&#125; 12345678910 @Component(&quot;publishUtil&quot;)public class PublishUtil &#123; @Autowired private AmqpTemplate amqpTemplate; public void send(String exchange, String routingkey, Object message) &#123; amqpTemplate.convertAndSend(exchange,routingkey,message ); &#125;&#125; 1234567891011121314151617181920@Component(&quot;receiveConfirmTestListener&quot;)public class ReceiveConfirmTestListener implements ChannelAwareMessageListener &#123; /** * 收到消息的时候执行的监听 * @param message * @param channel * @throws Exception */ @Override public void onMessage(Message message, Channel channel) throws Exception &#123; try &#123; System.err.println(&quot;消费者收到了消息&quot; + message); channel.basicAck(message.getMessageProperties().getDeliveryTag(),false); &#125;catch (Exception e)&#123; e.printStackTrace(); channel.basicAck(message.getMessageProperties().getDeliveryTag(),false); &#125; &#125;&#125; 12345678 @Component(&quot;returnCallBackListener&quot;)public class ReturnCallBackListener implements RabbitTemplate.ReturnCallback &#123; @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) &#123; System.err.println(&quot;失败 message==&quot;+new String(message.getBody())+&quot; replyCode==&quot;+replyCode+&quot; replyText&quot;+replyText+&quot; exchange&quot;+exchange+&quot; routingKey&quot;+routingKey); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext2.xml&quot;&#125;)public class TestMain &#123; @Autowired private PublishUtil publishUtil; private static String exChange = &quot;DIRECT_EX&quot;;//交换机 private static String queue = &quot;CONFIRM_TEST&quot;; /** * EXCHANGE QUEUE都对, confirm 会执行, ack=true * @throws Exception */ @Test public void test1() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange, queue, message); Thread.sleep(2000); &#125; /** * EXCHANGE错误 QUEUE对, confirm 会执行, ack=false * @throws Exception */ @Test public void test2() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange+&quot;!&quot;, queue, message); Thread.sleep(2000); &#125; /** * EXCHANGE对的 QUEUE错的,confirm 会执行 act=true, 失败会执行 * @throws Exception */ @Test public void test3() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange, queue+&quot;1&quot;, message); Thread.sleep(2000); &#125; /** * EXCHANGE QUEUE都是错的 confirm 会执行,但是ack=false * @throws Exception */ @Test public void test4() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange+&quot;`&quot;, queue+&quot;1&quot;, message); Thread.sleep(2000); &#125; topic123456789101112131415161718192021222324 public class Recver1 &#123; private final static String EXCHANGE_NAME = &quot;testtopic&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testtopicqueue1&quot;, false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 channel.queueBind(&quot;testtopicqueue1&quot;, EXCHANGE_NAME, &quot;key.*&quot;); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind(&quot;testtopicqueue1&quot;, EXCHANGE_NAME, &quot;abc.#&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者11111111:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testtopicqueue1&quot;, false, consumer); &#125;&#125; 1234567891011121314151617181920212223public class Recver2 &#123; private final static String EXCHANGE_NAME = &quot;testtopic&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testtopicqueue2&quot;, false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 channel.queueBind(&quot;testtopicqueue2&quot;, EXCHANGE_NAME, &quot;key.#&quot;); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind(&quot;testtopicqueue2&quot;, EXCHANGE_NAME, &quot;abc.#&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者22222:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testtopicqueue2&quot;, false, consumer); &#125;&#125; 1234567891011121314public class Sender &#123; private final static String EXCHANGE_NAME = &quot;testtopic&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange,声明为 topic 也就是通配符类型 channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;); //发送 abc.1.2数据,凡是能匹配到这个关键词的都会收到 channel.basicPublish(EXCHANGE_NAME, &quot;abc.1.2&quot;, null, &quot;topic 模式消息111&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; util123456789101112 public class ConnextionUtil &#123; public static Connection getConnection () throws Exception&#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.3.233&quot;);//设置 server 的地址 connectionFactory.setPort(5672); connectionFactory.setUsername(&quot;test&quot;); connectionFactory.setPassword(&quot;test&quot;); connectionFactory.setVirtualHost(&quot;/test&quot;); return connectionFactory.newConnection();//创建一个新的连接 &#125;&#125; work12345678910111213141516171819202122232425262728293031public class Recver1 &#123; private final static String QUEUE = &quot;testwork&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE,false,false,false,null); // 同一时刻服务器只会发一条消息给消费者,只有当前消费者将消息处理完成后才会获取到下一条消息 //注释掉后可以获取多条消息,但是会一条一条处理 channel.basicQos(1);//告诉服务器,在我们没有确认当前消息完成之前,不要给我发新的消息 DefaultConsumer consumer =new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //当我们收到消息的时候调用 System.out.println(&quot;消费者1 收到的内容是:&quot;+new String(body)); //确认 try &#123; Thread.sleep(10);//模拟耗时 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false);//参数2,false 为确认收到消息, true 为拒接收到消息 &#125; &#125;; //注册消费者, 参数2 手动确认,代表我们收到消息后需要手动告诉服务器,我收到消息了 channel.basicConsume(QUEUE,false,consumer); &#125;&#125; 1234567891011121314151617181920212223242526272829public class Recver2 &#123; private final static String QUEUE = &quot;testwork&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE,false,false,false,null); channel.basicQos(1);//告诉服务器,在我们没有确认当前消息完成之前,不要给我发新的消息 DefaultConsumer consumer =new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //当我们收到消息的时候调用 System.out.println(&quot;消费者2 收到的内容是:&quot;+new String(body)); try &#123; Thread.sleep(300);//模拟耗时 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //确认 channel.basicAck(envelope.getDeliveryTag(), false);//参数2,false 为确认收到消息, true 为拒接收到消息 &#125; &#125;; //注册消费者, 参数2 手动确认,代表我们收到消息后需要手动告诉服务器,我收到消息了 channel.basicConsume(QUEUE,false,consumer); &#125;&#125; 123456789101112131415161718192021222324252627 public class Sender &#123; private final static String QUEUE = &quot;testwork&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; //获取连接 Connection connection = ConnextionUtil.getConnection(); //创建通道 Channel channel = connection.createChannel(); //声明队列,如果队列存在则什么都不做,如果不存在才创建 // 参数1 队列的名字 //参数2 是否持久化队列,我们的队列模式是在内存中的,如果 rabbitmq 重启会丢失,如果我们设置为 true, 则会保存到 erlang 自带的数据库中,重启后会重新读取 //参数3 是否排外,有两个作用,第一个当我们的连接关闭后是否会自动删除队列,作用二 是否私有当天前队列,如果私有了,其他通道不可以访问当前队列,如果为 true, 一般是一个队列只适用于一个消费者的时候 //参数4 是够自动删除 //参数5 我们的一些其他参数 channel.queueDeclare(QUEUE, false, false, false, null); for (int i = 0; i &lt; 100; i++) &#123; //发送内容 channel.basicPublish(&quot;&quot;,QUEUE,null,(&quot;发送的消息&quot;+i).getBytes()); &#125; //关闭连接 channel.close(); connection.close(); &#125;&#125; resourceapplication.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xsi:schemaLocation="http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.7.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"&gt; &lt;!--1 定义连接工厂--&gt; &lt;rabbit:connection-factory id="connectionFactory" host="192.168.3.233" port="5672" username="test" password="test" virtual-host="/test"/&gt; &lt;!--消息是发送到交换机还是队列--&gt; &lt;!--定义 rabbitmq 的模板 queue="" 如果发送到队列则写队列 exchange="" 如果发送到交换机则写交换机 routing-key="" 定义路由的关键字 --&gt; &lt;rabbit:template id="template" connection-factory="connectionFactory" exchange="fanoutExchange" /&gt; &lt;rabbit:admin connection-factory="connectionFactory"/&gt; &lt;!--定义队列--&gt; &lt;rabbit:queue name="myQueue" auto-declare="true"/&gt; &lt;!--定义交换机--&gt; &lt;rabbit:fanout-exchange name="fanoutExchange" auto-declare="true"&gt; &lt;!--将队列绑定到交换机--&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="myQueue"&gt; &lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:fanout-exchange&gt;&lt;!--定义监听容易,当收到消息的时候会执行内部的配置--&gt; &lt;rabbit:listener-container connection-factory="connectionFactory"&gt;&lt;!--定义到底哪个类里面的什么方法用于处理收到的消息--&gt; &lt;rabbit:listener ref="consumer" method="test" queue-names="myQueue"/&gt; &lt;/rabbit:listener-container&gt; &lt;!--定义消费者--&gt; &lt;bean id="consumer" class="com.qianfeng.spring.MyConsumer"/&gt;&lt;!-- &lt;rabbit:direct-exchange name="directExchange" durable="true" auto-delete="false"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="myQueue" key="key1"&gt; &lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:direct-exchange&gt;--&gt; &lt;!-- &lt;rabbit:topic-exchange name="topicExchange" durable="true" auto-delete="false"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding pattern="dfasfsd.*" queue="myQueue"/&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:topic-exchange&gt;--&gt;&lt;/beans&gt; application2.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.7.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;context:component-scan base-package="com.qianfeng"/&gt; &lt;bean id="jsonMessageConverter" class="org.springframework.amqp.support.converter.Jackson2JsonMessageConverter" /&gt; &lt;!-- 􏰽􏰾RabbitMQ􏰙􏰆􏰇􏴜􏴡 publisher-confirms 􏰒􏵠􏱈􏱉, publisher-confirms 为 true的情况下 确认失败等回调才会执行 􏵡􏳚􏰀􏰔􏵈􏵉--&gt; &lt;rabbit:connection-factory id="connectionFactory" host="192.168.3.233" port="5672" username="test" password="test" virtual-host="/test" publisher-confirms="true" /&gt; &lt;rabbit:admin connection-factory="connectionFactory" /&gt; &lt;!-- 􏰬􏱊􏵞􏱯􏰽􏵢􏴿􏰩 --&gt;&lt;!-- mandatory􏳅􏳆􏲬􏳿true,return callback􏰶􏴟􏵣 --&gt; &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" confirm-callback="confirmCallBackListener" return-callback="returnCallBackListener" mandatory="true"/&gt; &lt;rabbit:queue name="CONFIRM_TEST" /&gt; &lt;rabbit:direct-exchange name="DIRECT_EX" id="DIRECT_EX" &gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="CONFIRM_TEST" /&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:direct-exchange&gt; &lt;!-- 􏴁􏳿consumer, 􏰿􏱀􏰙􏴛􏲇queue􏰙􏱚􏱖􏳲􏲘 --&gt; &lt;rabbit:listener-container connection-factory="connectionFactory" acknowledge="manual" &gt; &lt;rabbit:listener queues="CONFIRM_TEST" ref="receiveConfirmTestListener" /&gt;&lt;/rabbit:listener-container&gt;&lt;/beans&gt; 1234567log4j.rootLogger=DEBUG,A1log4j.logger.com.taotao = DEBUGlog4j.logger.org.mybatis = DEBUGlog4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c]-[%p] %m%n]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消费生产与消费]]></title>
    <url>%2F2018%2F12%2F05%2FRabbitMQ%2F4%E6%B6%88%E8%B4%B9%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9%2F</url>
    <content type="text"><![CDATA[1.加入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;scope&gt;3.6.5&lt;/scope&gt; &lt;/dependency&gt; 2.编码实战2.1Productor12345678910111213141516171819202122public class Procuder &#123; // 生产端Procuder http://94.191.24.33:15672/#/ public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost("94.191.24.33"); connectionFactory.setPort(15672); connectionFactory.setVirtualHost("/"); // 2.通过连接工厂创建连接connectionFactory.newConnection(); Connection connection = connectionFactory.newConnection(); // 3.通过connection创建一个Channel Channel channel = connection.createChannel(); // 4.通过Channel发送数据 String msg = "Hello RabbitMQ"; //channel.basicPublish(exchange, routingKey, props, body); channel.basicPublish("", "test001", null, msg.getBytes()); channel.close(); connection.close(); &#125; 2.2.Consumer12345678910111213141516171819202122232425262728293031323334353637public class Consumer &#123; public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory，并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost("94.191.24.33"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost("/"); // 2.通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); // 3 通过连接工厂创建连接 Channel channel = connection.createChannel(); // 4.申明（创建）一个队列 String queueName = "test001"; // channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments) channel.queueDeclare("test001", true, false, false, null); // 5.创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); /** * 6.设置channel # channel.basicConsume(queue,autoAck, autoAck) # 1：queue：队列的名字 * 2.autoAck：是否自动签收 3:autoAck：具体的消费者对象 */ channel.basicConsume(queueName, true, queueingConsumer); //7.获取消息 while (true) &#123; Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody());// 获取消息 System.out.println("消费端" + msg); &#125; &#125;&#125; 2.3 启动程序看管控台 2.4 方法的API3.一些基础]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java引用传递]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[基本数据类型（show（）方法出栈 栈里面只有成员变量）123456789101112package 引用传递;//基本数据类型参数传递public class Demo &#123; public static void main(String[] args) &#123; int x = 3; show(x);//⭐️x=3 show（）方法出栈 栈里面只有3 System.out.println("x=" + x); &#125; public static void show(int x) &#123; x = 4; &#125;&#125; 123456789101112package 引用传递;//基本数据类型参数传递public class Demo &#123; public static void main(String[] args) &#123; int x = 3; show(x);// 答案x=4 执行的是show 里面的方法 &#125; public static void show(int x) &#123; x = 4; System.out.println("x=" + x); &#125;&#125; 引用数据类型参数传递 1234567891011121314package 引用传递;//引用数据类型public class Demo2 &#123; int x = 3; public static void main(String[] args) &#123; Demo2 demo2 = new Demo2(); demo2.x=9; show(demo2);// ⭐️ x=4 System.out.println(demo2.x); &#125; public static void show(Demo2 d) &#123; d.x = 4; &#125;&#125; 总结 引用数据类型传递详解 栈内存：保存所有的对象名称 d(保存了引用堆内存空间的地址） 堆内存空间。保存具体对象的具体属性 全局数据区：保存static类型的属性 全局代码区：保存所有的方法定义 java的引用传递 同一块堆内存空间，同时被多个栈内存指向，不同的栈可以修改同一块堆内存空间的地址 123456789101112131415161718192021222324252627282930313233package 引用传递;class Demo1 &#123; private int data = 10; public Demo1() &#123; &#125; public Demo1(int data) &#123; this.data = data; &#125; public int getData() &#123; return this.data; &#125; public void setData(int data) &#123; this.data = data; &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; Demo1 demo1 = new Demo1(); fun(demo1);// System.out.println(demo1.getData());//30 &#125; public static void fun(Demo1 temp) &#123; // 接受引用 temp.setData(30);// 修改属性内容 &#125;&#125; https://blog.csdn.net/lym152898/article/details/54411956]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ管控台]]></title>
    <url>%2F2018%2F12%2F04%2FRabbitMQ%2F3.%E7%AE%A1%E6%8E%A7%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[不积跬步 无以至千里 养成写博客理解的习惯#博客在学习的时候写 看最好的视频 写做好的博客 cheerUP]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbit MQ命令总结]]></title>
    <url>%2F2018%2F12%2F04%2FRabbitMQ%2FRabbit%20MQ%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[命令总结 RabbitMQ不积跬步无以至千里1.lsof -i :5672 查看有没有启动成功 2.rabbitmq 3.rabbitmqctl list_queues 查看所有队列的名称 4.rabbitmqctl list_vhosts 5.rabbitmqctl status 查看当前节点的状态]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaSE 总结 IO 集合 线程]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1.集合]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[java反射机制完全详解#1.反射源头 —Class类 1.1 取得Class类对象 ⭐️1234567public class Demo &#123; public static void main(String[] args) &#123; Date date = new Date(); Class&lt;? extends Date&gt; class1 = date.getClass();//取得class类对象 System.out.println(class1);//class java.util.Date &#125;&#125; 12345678//利用类.class获得反射的是实例划对象public class Demo1 &#123; public static void main(String[] args) &#123; Date date = new Date(); Class&lt;? extends Date&gt; class1 = java.util.Date.class ;//取得class类对象 System.out.println(class1);//class java.util.Date &#125;&#125; 12345678//利用Class类提供的方法实例化对向public class Demo2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class&lt;?&gt; forName = Class.forName("java.util.Date"); System.out.println(forName);//class java.util.Date &#125;&#125; #2.利用反射实例化对象 2.1public T newInstacne ⭐️⭐️123456789101112131415161718public class Demo3 &#123; public Demo3() &#123; System.out.println("^^^^"); &#125; public String toString() &#123; return "######"; &#125;&#125;-------------------------------------------------------------------------------- public class Demo4 &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; class1 = Class.forName("反射.Demo3"); Object object = class1.newInstance();// 实例化对象 // Demo3 demo3=new Demo3();//调用无参构造 System.out.println(class1); System.out.println(object); &#125;&#125; 2.2。工厂设计模式 3.取得类继承结构 123456789101112131415161718192021222324252627public class Demo3 extends Object implements Serializable &#123; public Demo3() &#123; System.out.println("^^^^"); &#125; public String toString() &#123; return "######"; &#125;&#125;-------------------------------------------------------------------------------- public class Demo4 &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; class1 = Class.forName("反射.Demo3"); class1.getName();// 包名.类名 class1.getPackage();// package 包名 class1.getPackage().getName();// 包名 class1.getSimpleName();// 类名 class1.getSuperclass().getName();// 父类的包名 Class&lt;?&gt;[] icls = class1.getInterfaces();// [Ljava.lang.Class;@6bf256fa for (int i = 0; i &lt; icls.length; i++) &#123; System.out.println(icls[i].getSimpleName());//Serializable &#125; 4.反射取得构造方法（invoke） 5.反射取得方法 ⭐️⭐️⭐️ 1234567891011121314public class Demo5 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; getMethodDemo(); &#125; // 获取指定Class中的公共函数 public static void getMethodDemo() throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = Class.forName(&quot;反射.Persion&quot;); Method[] methods = clazz.getMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; System.out.println(methods[i]); &#125; &#125; 6.Invoke –]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于java的容器注解 @Bean⭐️]]></title>
    <url>%2F2018%2F12%2F04%2FSpring%2F3.java%E5%AE%B9%E5%99%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/196 后续更新 1.实战 总结]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean装配 基于xml形式]]></title>
    <url>%2F2018%2F12%2F04%2FSpring%2F5.bean%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Spring Awre 123456789public class MoocApplicationContext implements ApplicationContextAware &#123; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println("MoocApplicationContext : " + applicationContext.getBean("moocApplicationContext").hashCode()); &#125; &#125; 1234567891011121314151617public class MoocBeanName implements BeanNameAware, ApplicationContextAware &#123; private String beanName; @Override public void setBeanName(String name) &#123; this.beanName = name; System.out.println("MoocBeanName : " + name); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println("setApplicationContext : " + applicationContext.getBean(this.beanName).hashCode()); &#125;&#125; Autowiring 1234567public class AutoWiringDAO &#123; public void say(String word) &#123; System.out.println("AutoWiringDAO : " + word); &#125;&#125; 12345678910111213141516171819public class AutoWiringService &#123; private AutoWiringDAO autoWiringDAO; public AutoWiringService(AutoWiringDAO autoWiringDAO) &#123; System.out.println("AutoWiringService"); this.autoWiringDAO = autoWiringDAO; &#125; public void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) &#123; System.out.println("setAutoWiringDAO"); this.autoWiringDAO = autoWiringDAO; &#125; public void say(String word) &#123; this.autoWiringDAO.say(word); &#125;&#125; 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-autowire="constructor"&gt; &lt;bean id="autoWiringService" class="com.imooc.autowiring.AutoWiringService" &gt;&lt;/bean&gt; &lt;bean class="com.imooc.autowiring.AutoWiringDAO" &gt;&lt;/bean&gt; &lt;/beans&gt;]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP]]></title>
    <url>%2F2018%2F12%2F04%2FSpring%2F7.SpringAOP%2F</url>
    <content type="text"><![CDATA[—-]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC 及bean容器 注入]]></title>
    <url>%2F2018%2F12%2F04%2FSpring%2F1.SpringIOC%2F</url>
    <content type="text"><![CDATA[1.IOC及Bean容器 ​ 2.Spring 注入 &lt;必须要有get/set方法&gt; &lt; property name=”” ref=””&gt;⭐️ * name= 当前Bean中class所在的类的注入的属性的 成员变量名 * ref=表示引用 下一个的ID值 ** &lt;必须要有构造器方法&gt; 3.实战–IOC3.1传统的new 方式实现接口编程​ 3.2使用Bean开发 3.2 set注入1.Dao层 2.service层 3.3 构造方法注入]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbit MQ 命令行与管控台]]></title>
    <url>%2F2018%2F12%2F03%2FRabbitMQ%2F2.%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8E%E7%AE%A1%E6%8E%A7%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435rabbitmqctl stop_app：关闭应用rabbitmqctl stop_app：启动应用rabbitmqctlstatus：节点状态rabbitmqctladd_user username password：添加用户rabbitmqctllist_users：列出所有用户rabbitmqctldelete_user username：删除用户rabbitmqctl clear_permissions -p vhostpath username ：清楚用户权限rabbitmqctladd_vhost vhostpath：创建虚拟主机rabbitmqctllist_vhost：列出所有虚拟主机rabbitmqctllist_permissions -p vhostpath：列出虚拟主机所有权限rabbitmqctldelete_vhost vhostpath：删除虚拟主机rabbitmqctllist_queues：查看所有队列信息rabbitmqctl -p vhostpath purge_queue blue：清除队列里的消息rabbitmqctlreset：移除所有数据，要在rabbitmqctlstop_app之后使用rabbitmqctl join_cluster [--ram]：组成集群命令rabbitmqctlcluster_status：查看集群状态rabbitmqctlchange_cluster_node_type disc |ram：修改集群节点的存储模式rabbitmqctlforget_cluster_node_ [--offline] ：忘记节点（摘除节点）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux安装RabbitMQ]]></title>
    <url>%2F2018%2F12%2F03%2FRabbitMQ%2F1.RabbitMQ%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在基于RPM的Linux上安装（RHEL，CentOS，Fedora，openSUSE） 1.下载Erlang https://www.erlang-solutions.com/resources/download.html ❌❌❌ http://www.rabbitmq.com/releases/erlang/ ☑️☑️☑️ 2 下载RabbitMQ服务器、 # #方法一：Wget +地址方法二：在终端中输入命令: scp 待上传文件名 linux用户名@服务器IP:存放到服务器的哪个位置 :~ fa 3.安装scoket 123456789101112131415161718192021222324## RabbitMQ 参考资料慕课网老师讲义 准备：yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz下载：wget www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpmwget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpmwget www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm配置文件：vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;&quot;guest&quot;&gt;&gt;,只保留guest服务启动和停止：启动 rabbitmq-server start &amp;停止 rabbitmqctl app_stop管理插件：rabbitmq-plugins enable rabbitmq_management访问地址：http://192.168.11.76:15672/]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识RabbitMQ]]></title>
    <url>%2F2018%2F12%2F03%2FRabbitMQ%2F0.RabbitMQ%2F</url>
    <content type="text"><![CDATA[http://www.rabbitmq.com/#features 安装顺序 ：先是erlang 然后是 socat 然后是rabbitmq Linux安装：]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2F2018%2F12%2F02%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E5%B8%B8%E7%94%A8maven%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;7.0.64&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mybatis.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mybatis.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt;&lt;/dependency&gt;&lt;-- JSON 序列化工具--&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;!--&lt;scope&gt;runtime&lt;/scope&gt;--&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;20.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- id加密解密 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hashids&lt;/groupId&gt; &lt;artifactId&gt;hashids&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- ftpclient --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- file upload --&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis pager --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- alipay 阿里支付--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-configuration&lt;/groupId&gt; &lt;artifactId&gt;commons-configuration&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt;&lt;/dependency&gt;&lt;redis 客户端 jedis&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器linux awd云]]></title>
    <url>%2F2018%2F12%2F02%2FLinux%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[登录Linux云服务器浏览器 WebShell 方式登录 支持复制粘贴、中文输入法，需要开启 SSH 端口（TCP:22） 立即登录 标准登录方式 使用 Windows 系统的电脑 1、下载安装 Windows SSH 和 Telnet 客户端工具 Putty。 下载Putty 2、用户名： root，Host： 94.191.24.33 3、按照 Putty 使用帮助进行登录。 Putty 密码方式使用帮助 使用 Linux/Mac OS X 系统的电脑（使用密码登录） 1、打开 SSH 客户端（Mac可使用系统自带的终端） 2、输入 ssh -q -l root -p 22 94.191.24.33 3、输入 CVM 实例密码进行登录。 使用 Linux/Mac OS X 系统的电脑（使用密钥登录） 1、打开 SSH 客户端（Mac可使用系统自带的终端）。 2、查找您云服务器关联的 SSH 密钥文件本地存放地址。 3、您的密钥必须不公开可见，SSH 才能工作。请使用此命令： chmod 400 [密钥文件路径]。 4、输入命令： ssh [-i 密钥文件路径] root@94.191.24.33。 浏览器 VNC 方式登录 不推荐 暂不支持复制粘贴、中文输入法。 立即登录 提示：采用VNC方式登录，请务必开启 MFA 二次验证提高安全保障级别 git@gitee.com:GoodMrY/mmall_learning.git git@gitee.com:GoodMrY/mmall_learning.gitgit@gitee.com:GoodMrY/mmall_learning.gitgit@gitee.com:GoodMrY/mmall_learning.gitgit@gitee.com:GoodMrY/mmall_learning.git]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F01%2FLinux%2FLinux%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F30%2FLinux%2FLinux%E5%AE%89%E8%A3%85Tomcat%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[linux安装JDK1.7 cento7]]></title>
    <url>%2F2018%2F11%2F30%2FLinux%2FLinux%E5%AE%89%E8%A3%85JDK%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2018%2F11%2F30%2FLinux%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux SSH Mac1.下载 淘宝 用户名dongguakeji 密码dongguakeji2.mac远程访问SSH 不再sudoers文件中此事将被报告 （dongguakeji密码不能使用）–解决 使用root登陆分配权限 3.使用root登陆 远程SSH连接Linux centos7 使用root访问 关闭防火墙 11.你要改用iptables的话，需要安装iptables服务 sudo yum install iptables-services CentOS 7.0默认使用的是firewall作为防火墙，这里改为 iptables防火墙步骤。 firewall-cmd –state. #查看默认防火墙状态 （关闭后显示notrunning，开启后显示running） [root@localhost ~]#firewall-cmd –state not running 关闭防火墙： systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 4.Linux下ip设置 https://blog.csdn.net/qq_34924407/article/details/79967650. Centos7中查看IP命令：IP add https://blog.csdn.net/tuntun1120/article/details/65443757 虚拟机下CentOS7开启SSH连接 4.切换网络模式选择 然后重新编辑⭐️ 虚拟主机–&gt;网络适配器——&gt;侨界模式—&gt;复制物理网络连接转台然后重新编辑IP 变成下面这样 总结：1.先检查SSH 服务开没开 2.检查22 端口的状态 3.看网络互相通过ping看看是不是有64type的回应 4。资料在收藏夹里面 还有慕课的视频Linux]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker镜像加速]]></title>
    <url>%2F2018%2F11%2F11%2FDocker%2FDocker%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[emmm。。。为什么图片可以使用 网上的地址？ https://www.jianshu.com/p/94c6e44ebd3c 不要使用https前缀， 负责会提示证书错误， Version requires:- Docker for MAC version: docker version STEPS:- Open docker -&gt;preference -&gt;Daemon-&gt;basic-&gt;Registry mirrors 添加： http://registry.docker-cn.com Note：不要使用https前缀， 负责会提示证书错误， “registry-mirrors” : No certs for egitstry.docker.com 导致dockerrestart failed。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker上传到腾讯云服务器上]]></title>
    <url>%2F2018%2F11%2F11%2FDocker%2FDocker%E4%B8%8A%E4%BC%A0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[https://cloud.tencent.com/document/product/457/9117 腾讯云 https://study.163.com/course/courseLearn.htm?courseId=1006018194#/learn/video?lessonId=1053398787&amp;courseId=1006018194 小D课堂 先选择容器服务 123sudo docker login --username=[username] ccr.ccs.tencentyun.com sudo docker login --username=100007660104 ccr.ccs.tencentyun.com 100007660104sad username:腾讯云账号，开通时已注册。输入密码后即登录完成。 ##注意 用户名 不是QQ号登陆的密码而是仓库的用户名 第一次自动生成 ####密码输入的时候先输入电脑root密码 z ###再输入密码yhp836143 12$ sudo docker tag [ImageId] ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号]$ sudo docker push ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号] 12$ sudo docker tag 5fc4ede68fcd ccr.ccs.tencentyun.com/freemana2017/atcrod:latest$ sudo docker push ccr.ccs.tencentyun.com/freemana2017/atcrod:latest 密码输入 z 因为是sudo 使用镜像—-下载镜像 小D课堂 第62讲 mac远程登陆腾讯云服务器 然后在腾讯云服务器上使用push命令拉去镜像 然后使用run命令运行镜像 最后改成公网访问镜像 登陆到腾讯云的实验室 安装Docker环境 在本机上登陆SSH 然后搭建Docker环境 ### https://cloud.tencent.com/developer/labs/lab/10054/console 在本机上远程腾讯云 搭建Docker环境 登录到镜像仓库，需输入密码。 1$ sudo docker login --username=[username] ccr.ccs.tencentyun.com 下载镜像。 sudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latest 1$ sudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latest ⭐️Docker：Cannot connect to the Docker daemon. Is the docker daemon running on this host? https://www.w3cschool.cn/kxqhmy/suzagdn1.html 查看是否存在进程： 1$ ps aux |grep docker1 停止进程 1$sudo service docker stop1 重启docker： 1$dockerd Docker在云服务器上的安装 https://www.jianshu.com/p/ea3078dae4fb 简书 1.登陆到服务器上面 通过终端 或者云主机登陆 2.开始操作 3.https://docs.docker.com/install/linux/docker-ce/centos/#uninstall-old-versions 官网 Docker的安装方式—腾讯云服务器上面 好像买的系统是Cents的 安装 CentOS 的安装 Docker：Cannot connect to the Docker daemon. Is the docker daemon running on this host? 1Docker：Cannot connect to the Docker daemon. Is the docker daemon running on this host? docker -d -p 8888：8080 先分配角色。在启动Docker 如果端口播被占用了 先关闭Docker sudo service docker stop 1sudo service docker stop 在启动Doccur service docker start 1service docker start 大佬指教。不是locaohostg 192.168.2.123 是公网ip腾讯公网的ip–118.89.28.213 加镜像名啊 兄die]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot尚硅谷 雷丰阳]]></title>
    <url>%2F2018%2F11%2F11%2FSpring%20Boot%2FSpring%20Boot%E5%B0%9A%E7%A1%85%E8%B0%B7%2F</url>
    <content type="text"><![CDATA[一、**Spring Boot 入门 1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； ccc 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.atguigu.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; ##4、配置文件占位符 1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ​ ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings("rawtypes")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico ​ 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== ​ Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path="/hello" view-name="success"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = "spring.messages")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="asserts/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="asserts/css/signin.css" th:href="@&#123;/asserts/css/signin.css&#125;" rel="stylesheet"&gt; &lt;/head&gt; &lt;body class="text-center"&gt; &lt;form class="form-signin" action="dashboard.html"&gt; &lt;img class="mb-4" th:src="@&#123;/asserts/img/bootstrap-solid.svg&#125;" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72"&gt; &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#&#123;login.tip&#125;"&gt;Please sign in&lt;/h1&gt; &lt;label class="sr-only" th:text="#&#123;login.username&#125;"&gt;Username&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="Username" th:placeholder="#&#123;login.username&#125;" required="" autofocus=""&gt; &lt;label class="sr-only" th:text="#&#123;login.password&#125;"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#&#123;login.password&#125;" required=""&gt; &lt;div class="checkbox mb-3"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#&#123;login.btn&#125;"&gt;Sign in&lt;/button&gt; &lt;p class="mt-5 mb-3 text-muted"&gt;© 2017-2018&lt;/p&gt; &lt;a class="btn btn-sm"&gt;中文&lt;/a&gt; &lt;a class="btn btn-sm"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = "spring.mvc", name = "locale") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter("l"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split("_"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style="color: red" th:text="$&#123;msg&#125;" th:if="$&#123;not #strings.isEmpty(msg)&#125;"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute("msg","没有权限请先登陆"); request.getRequestDispatcher("/index.html").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); registry.addViewController("/main.html").setViewName("dashboard"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**") .excludePathPatterns("/index.html","/","/user/login"); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"&gt; &lt;div class="sidebar-sticky"&gt; &lt;ul class="nav flex-column"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" th:class="$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;" href="#" th:href="@&#123;/main.html&#125;"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"&gt; &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"&gt;&lt;/path&gt; &lt;polyline points="9 22 9 12 15 12 15 22"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class="sr-only"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace="commons/bar::#sidebar(activeUri='emps')"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type="email" class="form-control" placeholder="zhangsan@atguigu.com"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action="@&#123;/emp&#125;" method="post"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name="_method";值就是我们指定的请求方式--&gt; &lt;input type="hidden" name="_method" value="put" th:if="$&#123;emp!=null&#125;"/&gt; &lt;input type="hidden" name="id" th:if="$&#123;emp!=null&#125;" th:value="$&#123;emp.id&#125;"&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="$&#123;emp!=null&#125;?$&#123;emp.email&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class="form-control" name="department.id"&gt; &lt;option th:selected="$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;" th:value="$&#123;dept.id&#125;" th:each="dept:$&#123;depts&#125;" th:text="$&#123;dept.departmentName&#125;"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" th:text="$&#123;emp!=null&#125;?'修改':'添加'"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each="emp:$&#123;emps&#125;"&gt; &lt;td th:text="$&#123;emp.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text="$&#123;emp.email&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.gender&#125;==0?'女':'男'"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.departmentName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-sm btn-primary" th:href="@&#123;/emp/&#125;+$&#123;emp.id&#125;"&gt;编辑&lt;/a&gt; &lt;button th:attr="del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;" class="btn btn-sm btn-danger deleteBtn"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(".deleteBtn").click(function()&#123; //删除当前员工的 $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put("timestamp", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value("$&#123;error.path:/error&#125;")private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = "error/" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code","user.notexist"); map.put("message",e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute("javax.servlet.error.status_code"); */ request.setAttribute("javax.servlet.error.status_code",500); map.put("code","user.notexist"); map.put("message",e.getMessage()); //转发到/error return "forward:/error"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put("company","atguigu"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir("tomcat")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the " + "configure method or add an @Configuration annotation"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql "docker-entrypoint.sh" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql "docker-entrypoint.sh" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql "docker-entrypoint.sh" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = "spring.datasource.type")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125; 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select("select * from department where id=#&#123;id&#125;") public Department getDeptById(Integer id); @Delete("delete from department where id=#&#123;id&#125;") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = "id") @Insert("insert into department(departmentName) values(#&#123;departmentName&#125;)") public int insertDept(Department department); @Update("update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;") public int updateDept(Department department);&#125; 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = "com.atguigu.springboot.mapper")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = "last_name",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println("ApplicationContextInitializer...initialize..."+applicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println("SpringApplicationRunListener...starting..."); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get("os.name"); System.out.println("SpringApplicationRunListener...environmentPrepared.."+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextPrepared..."); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextLoaded..."); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println("SpringApplicationRunListener...finished..."); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println("ApplicationRunner...run...."); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println("CommandLineRunner...run..."+ Arrays.asList(args)); &#125;&#125; 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = "atguigu.hello")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 123456789101112131415161718package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+"-" +name + helloProperties.getSuffix(); &#125;&#125; 12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并发编程]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1 并发编程的基础]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot Docker 小D课堂]]></title>
    <url>%2F2018%2F11%2F11%2FSpring%20Boot%2FSpringBoot-Docker-%E5%B0%8FD%E8%AF%BE%E5%A0%82%2F</url>
    <content type="text"><![CDATA[构建SpringBoot 应用docker镜像1.第1课 高级篇幅之构建SpringBoot应用docker镜像上集 官方文档：https://spring.io/guides/gs/spring-boot-docker/ 1、步骤：maven里面添加配置pom.xml 简介:使用Docker的maven插件，构建springboot应用 &lt;!--在maven最上面的申明的地方--properties--&gt; &lt;properties&gt; &lt;docker.image.prefix&gt;xdclass&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;!--项目打包的名称--&gt; &lt;finalName&gt;docker-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 配置讲解 Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。 ${project.build.finalName} 产出物名称，缺省为${project.artifactId}-${project.version} ⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ https://blog.csdn.net/TMaskBoy/article/details/82562413 高能预警 No plugin found for prefix ‘docker’ in the current project and in the plugin groups在Maven的配置文件 conf/settings.xml中添加com.spotify 12345&lt;pluginGroups&gt; &lt;pluginGroup&gt;com.spotify&lt;/pluginGroup&gt; &lt;/pluginGroups&gt;注意setting配置文件在maven的仓库里面找不到 重新更新idea中maven的插件 然后 更换.m2中conf中setting.xml的内容 #详细错误如下：om.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value (‘swarm’) 起初pom.xml中docker-maven-plugin的版本是1.0.0，使用mvn package docker:build -e构建Image出现如上异常。百般搜索无果，后来看其他的Spring Boot构建Docker镜像有用的是0.4.3，遂修改之。 解决办法 将小D课堂里面的插件 &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; 改为⭐️⭐️ 123&lt;groupId&gt;com.spotify&lt;/groupId&gt;&lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; ⭐️ //这边不是dockerfile-maven-plugin了而是docker-maven-plugin&lt;version&gt;0.4.13&lt;/version&gt; ⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ 第2课 高级篇幅之构建SpringBoot应用docker镜像下集 步骤1创建Dockerfile,默认是根目录，（可以修改为src/main/docker/Dockerfile,如果修则需要制定路径） 简介:打包SpringCloud镜像并上传私有仓库并部署 1、 什么是Dockerfile : 由一系列命令和参数构成的脚本，这些命令应用于基础镜像, 最终创建一个新的镜 像 实战 FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 参数讲解： FROM &lt;image&gt;:&lt;tag&gt; 需要一个基础镜像，可以是公共的或者是私有的， 后续构建会基于此镜像，如果同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令 VOLUME 配置一个具有持久化功能的目录，主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容 器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据 文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录 ARG 设置编译镜像时加入的参数， ENV 是设置容器的环境变量 COPY : 只支持将本地文件复制到容器 ,还有个ADD更强大但复杂点 ENTRYPOINT 容器启动时执行的命令 EXPOSE 8080 暴露镜像端口 第3课构建镜像2、构建镜像 mvn install dockerfile:build 打标签 docker tag a1b9fc71720d registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 推送到镜像仓库 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 应用服务器拉取镜像 docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 docker run -d --name xdclass_docker_demo1 -p 8099:8080 a1b9fc71720d 3、查看启动日志 docker logs -f containerid 实战1.mvn install dockerfile:build。不知道为什么终端没有用idea中终端却有用 😄哈哈 2.docker images 没有名字镜像？？注意在idea中测试的话就要用idea 不要随变改成终端 3.docker run -d –name demo -p 8080:8080 8ef42611e3b0 备注：运行镜像 –name 指定名字 -d 后台运行 8ef42611e3b0：刚刚构建的image的ID name 不会用就别用 4.docker ps 查看一下镜像的进程 ？？？没有程序。测试一下]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 雷丰阳整合篇]]></title>
    <url>%2F2018%2F11%2F11%2FSpring%20Boot%2FSpringBoot%E9%AB%98%E7%BA%A7%E9%9B%B7%E4%B8%B0%E9%98%B3%2F</url>
    <content type="text"><![CDATA[#1 SpringBoot-cache SpringbootCacheApplication1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cache.annotation.EnableCaching;/** * 一、搭建基本环境 * 1、导入数据库文件 创建出department和employee表 * 2、创建javaBean封装数据 * 3、整合MyBatis操作数据库 * 1.配置数据源信息 * 2.使用注解版的MyBatis； * 1）、@MapperScan指定需要扫描的mapper接口所在的包 * 二、快速体验缓存 * 步骤： * 1、开启基于注解的缓存 @EnableCaching * 2、标注缓存注解即可 * @Cacheable * @CacheEvict * @CachePut * 默认使用的是ConcurrentMapCacheManager==ConcurrentMapCache；将数据保存在 ConcurrentMap&lt;Object, Object&gt;中 * 开发中使用缓存中间件；redis、memcached、ehcache； * 三、整合redis作为缓存 * Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 * 1、安装redis：使用docker； * 2、引入redis的starter * 3、配置redis * 4、测试缓存 * 原理：CacheManager===Cache 缓存组件来实际给缓存中存取数据 * 1）、引入redis的starter，容器中保存的是 RedisCacheManager； * 2）、RedisCacheManager 帮我们创建 RedisCache 来作为缓存组件；RedisCache通过操作redis缓存数据的 * 3）、默认保存数据 k-v 都是Object；利用序列化保存；如何保存为json * 1、引入了redis的starter，cacheManager变为 RedisCacheManager； * 2、默认创建的 RedisCacheManager 操作redis的时候使用的是 RedisTemplate&lt;Object, Object&gt; * 3、RedisTemplate&lt;Object, Object&gt; 是 默认使用jdk的序列化机制 * 4）、自定义CacheManager； * */@MapperScan("com.atguigu.cache.mapper")@SpringBootApplication@EnableCachingpublic class Springboot01CacheApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot01CacheApplication.class, args); &#125;&#125; Bean–Department12345678910111213141516171819202122232425262728293031323334package com.atguigu.cache.bean;public class Department &#123; private Integer id; private String departmentName; public Department() &#123; super(); // TODO Auto-generated constructor stub &#125; public Department(Integer id, String departmentName) &#123; super(); this.id = id; this.departmentName = departmentName; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getDepartmentName() &#123; return departmentName; &#125; public void setDepartmentName(String departmentName) &#123; this.departmentName = departmentName; &#125; @Override public String toString() &#123; return "Department [id=" + id + ", departmentName=" + departmentName + "]"; &#125;&#125; Bean—Employee12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.atguigu.cache.bean;import java.io.Serializable;public class Employee implements Serializable &#123; private Integer id; private String lastName; private String email; private Integer gender; //性别 1男 0女 private Integer dId; public Employee() &#123; super(); &#125; public Employee(Integer id, String lastName, String email, Integer gender, Integer dId) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; this.dId = dId; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getGender() &#123; return gender; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; public Integer getdId() &#123; return dId; &#125; public void setdId(Integer dId) &#123; this.dId = dId; &#125; @Override public String toString() &#123; return "Employee [id=" + id + ", lastName=" + lastName + ", email=" + email + ", gender=" + gender + ", dId=" + dId + "]"; &#125; &#125; config—myRedisConfig12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.atguigu.cache.config;import com.atguigu.cache.bean.Department;import com.atguigu.cache.bean.Employee;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import java.net.UnknownHostException;@Configurationpublic class MyRedisConfig &#123; @Bean public RedisTemplate&lt;Object, Employee&gt; empRedisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; ser = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(ser); return template; &#125; @Bean public RedisTemplate&lt;Object, Department&gt; deptRedisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Department&gt; template = new RedisTemplate&lt;Object, Department&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Department&gt; ser = new Jackson2JsonRedisSerializer&lt;Department&gt;(Department.class); template.setDefaultSerializer(ser); return template; &#125; //CacheManagerCustomizers可以来定制缓存的一些规则 @Primary //将某个缓存管理器作为默认的 @Bean public RedisCacheManager employeeCacheManager(RedisTemplate&lt;Object, Employee&gt; empRedisTemplate)&#123; RedisCacheManager cacheManager = new RedisCacheManager(empRedisTemplate); //key多了一个前缀 //使用前缀，默认会将CacheName作为key的前缀 cacheManager.setUsePrefix(true); return cacheManager; &#125; @Bean public RedisCacheManager deptCacheManager(RedisTemplate&lt;Object, Department&gt; deptRedisTemplate)&#123; RedisCacheManager cacheManager = new RedisCacheManager(deptRedisTemplate); //key多了一个前缀 //使用前缀，默认会将CacheName作为key的前缀 cacheManager.setUsePrefix(true); return cacheManager; &#125;&#125; config—mycacheconfig1234567891011121314151617181920212223package com.atguigu.cache.config;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.lang.reflect.Method;import java.util.Arrays;@Configurationpublic class MyCacheConfig &#123; @Bean(&quot;myKeyGenerator&quot;) public KeyGenerator keyGenerator()&#123; return new KeyGenerator()&#123; @Override public Object generate(Object target, Method method, Object... params) &#123; return method.getName()+&quot;[&quot;+ Arrays.asList(params).toString()+&quot;]&quot;; &#125; &#125;; &#125;&#125; DeptService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.cache.service;import com.atguigu.cache.bean.Department;import com.atguigu.cache.mapper.DepartmentMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.cache.Cache;import org.springframework.cache.annotation.CacheConfig;import org.springframework.cache.annotation.Cacheable;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.stereotype.Service;@Servicepublic class DeptService &#123; @Autowired DepartmentMapper departmentMapper; @Qualifier("deptCacheManager") @Autowired RedisCacheManager deptCacheManager; /** * 缓存的数据能存入redis； * 第二次从缓存中查询就不能反序列化回来； * 存的是dept的json数据;CacheManager默认使用RedisTemplate&lt;Object, Employee&gt;操作Redis * * * @param id * @return */// @Cacheable(cacheNames = "dept",cacheManager = "deptCacheManager")// public Department getDeptById(Integer id)&#123;// System.out.println("查询部门"+id);// Department department = departmentMapper.getDeptById(id);// return department;// &#125; // 使用缓存管理器得到缓存，进行api调用 public Department getDeptById(Integer id)&#123; System.out.println("查询部门"+id); Department department = departmentMapper.getDeptById(id); //获取某个缓存 Cache dept = deptCacheManager.getCache("dept"); dept.put("dept:1",department); return department; &#125;&#125; EmployeeService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package com.atguigu.cache.service;import com.atguigu.cache.bean.Employee;import com.atguigu.cache.mapper.EmployeeMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.*;import org.springframework.stereotype.Service;@CacheConfig(cacheNames="emp"/*,cacheManager = "employeeCacheManager"*/) //抽取缓存的公共配置@Servicepublic class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; /** * 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法； * CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字； * * * 原理： * 1、自动配置类；CacheAutoConfiguration * 2、缓存的配置类 * org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration * org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration * org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration * org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration * org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration * org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration * org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration * org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration * org.springframework.boot.autoconfigure.cache.GuavaCacheConfiguration * org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】 * org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration * 3、哪个配置类默认生效：SimpleCacheConfiguration； * * 4、给容器中注册了一个CacheManager：ConcurrentMapCacheManager * 5、可以获取和创建ConcurrentMapCache类型的缓存组件；他的作用将数据保存在ConcurrentMap中； * * 运行流程： * @Cacheable： * 1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取； * （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。 * 2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数； * key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key； * SimpleKeyGenerator生成key的默认策略； * 如果没有参数；key=new SimpleKey()； * 如果有一个参数：key=参数的值 * 如果有多个参数：key=new SimpleKey(params)； * 3、没有查到缓存就调用目标方法； * 4、将目标方法返回的结果，放进缓存中 * * @Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存， * 如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据； * * 核心： * 1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件 * 2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator * * * 几个属性： * cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存； * * key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值 * 编写SpEL； #i d;参数id的值 #a0 #p0 #root.args[0] * getEmp[2] * * keyGenerator：key的生成器；可以自己指定key的生成器的组件id * key/keyGenerator：二选一使用; * * * cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 * * condition：指定符合条件的情况下才缓存； * ,condition = "#id&gt;0" * condition = "#a0&gt;1"：第一个参数的值》1的时候才进行缓存 * * unless:否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断 * unless = "#result == null" * unless = "#a0==2":如果第一个参数的值是2，结果不缓存； * sync：是否使用异步模式 * @param id * @return * */ @Cacheable(value = &#123;"emp"&#125;/*,keyGenerator = "myKeyGenerator",condition = "#a0&gt;1",unless = "#a0==2"*/) public Employee getEmp(Integer id)&#123; System.out.println("查询"+id+"号员工"); Employee emp = employeeMapper.getEmpById(id); return emp; &#125; /** * @CachePut：既调用方法，又更新缓存数据；同步更新缓存 * 修改了数据库的某个数据，同时更新缓存； * 运行时机： * 1、先调用目标方法 * 2、将目标方法的结果缓存起来 * * 测试步骤： * 1、查询1号员工；查到的结果会放在缓存中； * key：1 value：lastName：张三 * 2、以后查询还是之前的结果 * 3、更新1号员工；【lastName:zhangsan；gender:0】 * 将方法的返回值也放进缓存了； * key：传入的employee对象 值：返回的employee对象； * 4、查询1号员工？ * 应该是更新后的员工； * key = "#employee.id":使用传入的参数的员工id； * key = "#result.id"：使用返回后的id * @Cacheable的key是不能用#result * 为什么是没更新前的？【1号员工没有在缓存中更新】 * */ @CachePut(/*value = "emp",*/key = "#result.id") public Employee updateEmp(Employee employee)&#123; System.out.println("updateEmp:"+employee); employeeMapper.updateEmp(employee); return employee; &#125; /** * @CacheEvict：缓存清除 * key：指定要清除的数据 * allEntries = true：指定清除这个缓存中所有的数据 * beforeInvocation = false：缓存的清除是否在方法之前执行 * 默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除 * * beforeInvocation = true： * 代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除 * * */ @CacheEvict(value="emp",beforeInvocation = true/*key = "#id",*/) public void deleteEmp(Integer id)&#123; System.out.println("deleteEmp:"+id); //employeeMapper.deleteEmpById(id); int i = 10/0; &#125; // @Caching 定义复杂的缓存规则 @Caching( cacheable = &#123; @Cacheable(/*value="emp",*/key = "#lastName") &#125;, put = &#123; @CachePut(/*value="emp",*/key = "#result.id"), @CachePut(/*value="emp",*/key = "#result.email") &#125; ) public Employee getEmpByLastName(String lastName)&#123; return employeeMapper.getEmpByLastName(lastName); &#125;&#125; 2 SpringBoot -amqpSpringBootAmqpApplication1234567891011121314151617181920212223242526package com.atguigu.amqp;import org.springframework.amqp.rabbit.annotation.EnableRabbit;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 自动配置 * 1、RabbitAutoConfiguration * 2、有自动配置了连接工厂ConnectionFactory； * 3、RabbitProperties 封装了 RabbitMQ的配置 * 4、 RabbitTemplate ：给RabbitMQ发送和接受消息； * 5、 AmqpAdmin ： RabbitMQ系统管理功能组件; * AmqpAdmin：创建和删除 Queue，Exchange，Binding * 6、@EnableRabbit + @RabbitListener 监听消息队列的内容 * */@EnableRabbit //开启基于注解的RabbitMQ模式@SpringBootApplicationpublic class Springboot02AmqpApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot02AmqpApplication.class, args); &#125;&#125; BookService123456789101112131415161718192021package com.atguigu.amqp.service;import com.atguigu.amqp.bean.Book;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Service;@Servicepublic class BookService &#123; @RabbitListener(queues = "atguigu.news") public void receive(Book book)&#123; System.out.println("收到消息："+book); &#125; @RabbitListener(queues = "atguigu") public void receive02(Message message)&#123; System.out.println(message.getBody()); System.out.println(message.getMessageProperties()); &#125;&#125; MyAMQPConfig12345678@Configurationpublic class MyAMQPConfig &#123; @Bean public MessageConverter messageConverter()&#123; return new Jackson2JsonMessageConverter(); &#125;&#125; 3 SpringBoot-elastic12345678910111213141516171819202122232425262728package com.atguigu.elastic;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot默认支持两种技术来和ES交互； * 1、Jest（默认不生效） * 需要导入jest的工具包（io.searchbox.client.JestClient） * 2、SpringData ElasticSearch【ES版本有可能不合适】 * 版本适配说明：https://github.com/spring-projects/spring-data-elasticsearch * 如果版本不适配：2.4.6 * 1）、升级SpringBoot版本 * 2）、安装对应版本的ES * * 1）、Client 节点信息clusterNodes；clusterName * 2）、ElasticsearchTemplate 操作es * 3）、编写一个 ElasticsearchRepository 的子接口来操作ES； * 两种用法：https://github.com/spring-projects/spring-data-elasticsearch * 1）、编写一个 ElasticsearchRepository */@SpringBootApplicationpublic class Springboot03ElasticApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot03ElasticApplication.class, args); &#125;&#125; BookRepository123456789101112131415package com.atguigu.elastic.repository;import com.atguigu.elastic.bean.Book;import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;import java.util.List;public interface BookRepository extends ElasticsearchRepository&lt;Book,Integer&gt; &#123; //参照 // https://docs.spring.io/spring-data/elasticsearch/docs/3.0.6.RELEASE/reference/html/ public List&lt;Book&gt; findByBookNameLike(String bookName);&#125; Book123456789@Document(indexName = "atguigu",type = "book")public class Book &#123; private Integer id; private String bookName; private String author; public Integer getId() &#123; return id; &#125; properties1234spring.elasticsearch.jest.uris=http://118.24.44.169:9200spring.data.elasticsearch.cluster-name=elasticsearchspring.data.elasticsearch.cluster-nodes=118.24.44.169:9301 4 SpringBoot -taskSpringBoot-TaskApplication12345678910111213141516package com.atguigu.task;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableAsync;import org.springframework.scheduling.annotation.EnableScheduling;@EnableAsync //开启异步注解功能@EnableScheduling //开启基于注解的定时任务@SpringBootApplicationpublic class Springboot04TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04TaskApplication.class, args); &#125;&#125; AsyncService12345678910111213141516171819package com.atguigu.task.service;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;@Servicepublic class AsyncService &#123; //告诉Spring这是一个异步方法 @Async public void hello()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("处理数据中..."); &#125;&#125; ScheduleService12345678910111213141516171819202122232425package com.atguigu.task.service;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Service;@Servicepublic class ScheduledService &#123; /** * second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）. * 0 * * * * MON-FRI * 【0 0/5 14,18 * * ?】 每天14点整，和18点整，每隔5分钟执行一次 * 【0 15 10 ? * 1-6】 每个月的周一至周六10:15分执行一次 * 【0 0 2 ? * 6L】每个月的最后一个周六凌晨2点执行一次 * 【0 0 2 LW * ?】每个月的最后一个工作日凌晨2点执行一次 * 【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次； */ // @Scheduled(cron = "0 * * * * MON-SAT") //@Scheduled(cron = "0,1,2,3,4 * * * * MON-SAT") // @Scheduled(cron = "0-4 * * * * MON-SAT") @Scheduled(cron = "0/4 * * * * MON-SAT") //每4秒执行一次 public void hello()&#123; System.out.println("hello ... "); &#125; &#125; Asyncontroller12345678910111213141516171819package com.atguigu.task.controller;import com.atguigu.task.service.AsyncService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AsyncController &#123; @Autowired AsyncService asyncService; @GetMapping("/hello") public String hello()&#123; asyncService.hello(); return "success"; &#125;&#125; properties1234spring.mail.username=534096094@qq.comspring.mail.password=gtstkoszjelabijbspring.mail.host=smtp.qq.comspring.mail.properties.mail.smtp.ssl.enable=true 5 Spring-securitySpringBootSecurityApplication123456789101112131415161718192021222324252627282930313233package com.atguigu.security;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 1、引入SpringSecurity； * 2、编写SpringSecurity的配置类； * @EnableWebSecurity extends WebSecurityConfigurerAdapter * 3、控制请求的访问权限： * configure(HttpSecurity http) &#123; * http.authorizeRequests().antMatchers("/").permitAll() * .antMatchers("/level1/**").hasRole("VIP1") * &#125; * 4、定义认证规则： * configure(AuthenticationManagerBuilder auth)&#123; * auth.inMemoryAuthentication() * .withUser("zhangsan").password("123456").roles("VIP1","VIP2") * &#125; * 5、开启自动配置的登陆功能： * configure(HttpSecurity http)&#123; * http.formLogin(); * &#125; * 6、注销：http.logout(); * 7、记住我：Remeberme()； */@SpringBootApplicationpublic class Springboot05SecurityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot05SecurityApplication.class, args); &#125;&#125; MySecurityConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.security.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); //定制请求的授权规则 http.authorizeRequests().antMatchers("/").permitAll() .antMatchers("/level1/**").hasRole("VIP1") .antMatchers("/level2/**").hasRole("VIP2") .antMatchers("/level3/**").hasRole("VIP3"); //开启自动配置的登陆功能，效果，如果没有登陆，没有权限就会来到登陆页面 http.formLogin().usernameParameter("user").passwordParameter("pwd") .loginPage("/userlogin"); //1、/login来到登陆页 //2、重定向到/login?error表示登陆失败 //3、更多详细规定 //4、默认post形式的 /login代表处理登陆 //5、一但定制loginPage；那么 loginPage的post请求就是登陆 //开启自动配置的注销功能。 http.logout().logoutSuccessUrl("/");//注销成功以后来到首页 //1、访问 /logout 表示用户注销，清空session //2、注销成功会返回 /login?logout 页面； //开启记住我功能 http.rememberMe().rememberMeParameter("remeber"); //登陆成功以后，将cookie发给浏览器保存，以后访问页面带上这个cookie，只要通过检查就可以免登录 //点击注销会删除cookie &#125; //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //super.configure(auth); auth.inMemoryAuthentication() .withUser("zhangsan").password("123456").roles("VIP1","VIP2") .and() .withUser("lisi").password("123456").roles("VIP2","VIP3") .and() .withUser("wangwu").password("123456").roles("VIP1","VIP3"); &#125;&#125; Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.atguigu.security.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@Controllerpublic class KungfuController &#123; private final String PREFIX = "pages/"; /** * 欢迎页 * @return */ @GetMapping("/") public String index() &#123; return "welcome"; &#125; /** * 登陆页 * @return */ @GetMapping("/userlogin") public String loginPage() &#123; return PREFIX+"login"; &#125; /** * level1页面映射 * @param path * @return */ @GetMapping("/level1/&#123;path&#125;") public String level1(@PathVariable("path")String path) &#123; return PREFIX+"level1/"+path; &#125; /** * level2页面映射 * @param path * @return */ @GetMapping("/level2/&#123;path&#125;") public String level2(@PathVariable("path")String path) &#123; return PREFIX+"level2/"+path; &#125; /** * level3页面映射 * @param path * @return */ @GetMapping("/level3/&#123;path&#125;") public String level3(@PathVariable("path")String path) &#123; return PREFIX+"level3/"+path; &#125;&#125; welcome123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity4"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align="center"&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt;&lt;div sec:authorize="!isAuthenticated()"&gt; &lt;h2 align="center"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href="@&#123;/userlogin&#125;"&gt;请登录&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt;&lt;div sec:authorize="isAuthenticated()"&gt; &lt;h2&gt;&lt;span sec:authentication="name"&gt;&lt;/span&gt;，您好,您的角色有： &lt;span sec:authentication="principal.authorities"&gt;&lt;/span&gt;&lt;/h2&gt; &lt;form th:action="@&#123;/logout&#125;" method="post"&gt; &lt;input type="submit" value="注销"/&gt; &lt;/form&gt;&lt;/div&gt;&lt;hr&gt;&lt;div sec:authorize="hasRole('VIP1')"&gt; &lt;h3&gt;普通武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/1&#125;"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/2&#125;"&gt;武当长拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/3&#125;"&gt;全真剑法&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP2')"&gt; &lt;h3&gt;高级武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/1&#125;"&gt;太极拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/2&#125;"&gt;七伤拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/3&#125;"&gt;梯云纵&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP3')"&gt; &lt;h3&gt;绝世武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/1&#125;"&gt;葵花宝典&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/2&#125;"&gt;龟派气功&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/3&#125;"&gt;独孤九剑&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; loginhtml12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 align=&quot;center&quot;&gt;欢迎登陆武林秘籍管理系统&lt;/h1&gt; &lt;hr&gt; &lt;div align=&quot;center&quot;&gt; &lt;form th:action=&quot;@&#123;/userlogin&#125;&quot; method=&quot;post&quot;&gt; 用户名:&lt;input name=&quot;user&quot;/&gt;&lt;br&gt; 密码:&lt;input name=&quot;pwd&quot;&gt;&lt;br/&gt; &lt;input type=&quot;checkbox&quot; name=&quot;remeber&quot;&gt; 记住我&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6 springboot-dubboconsumer-user1234567891011121314151617import com.alibaba.dubbo.config.annotation.Reference;import com.atguigu.ticket.service.TicketService;import org.springframework.stereotype.Service;@Servicepublic class UserService&#123; @Reference TicketService ticketService; public void hello()&#123; String ticket = ticketService.getTicket(); System.out.println("买到票了："+ticket); &#125;&#125; application.properties123dubbo.application.name=consumer-userdubbo.registry.address=zookeeper://118.24.44.169:2181 12345678@Component@Service //将服务发布出去public class TicketServiceImpl implements TicketService &#123; @Override public String getTicket() &#123; return "《厉害了，我的国》"; &#125;&#125; 12345dubbo.application.name=provider-ticketdubbo.registry.address=zookeeper://118.24.44.169:2181dubbo.scan.base-packages=com.atguigu.ticket.service SpringCloud12345678910111213/** * 注册中心 * 1、配置Eureka信息 * 2、@EnableEurekaServer */@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 12345678910server: port: 8761eureka: instance: hostname: eureka-server # eureka实例的主机名 client: register-with-eureka: false #不把自己注册到eureka上 fetch-registry: false #不从eureka上来获取服务的注册信息 service-url: defaultZone: http://localhost:8761/eureka/ 12345678910111213server: port: 8002spring: application: name: provider-ticketeureka: instance: prefer-ip-address: true # 注册服务的时候使用服务的ip地址 client: service-url: defaultZone: http://localhost:8761/eureka/ Springboot Actuar1234567891011121314/** * 自定义健康状态指示器 * 1、编写一个指示器 实现 HealthIndicator 接口 * 2、指示器的名字 xxxxHealthIndicator * 3、加入容器中 */@SpringBootApplicationpublic class Springboot08ActuatorApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot08ActuatorApplication.class, args); &#125;&#125; 1234567891011121314151617package com.atguigu.springboot08actuator.health;import org.springframework.boot.actuate.health.Health;import org.springframework.boot.actuate.health.HealthIndicator;import org.springframework.stereotype.Component;@Componentpublic class MyAppHealthIndicator implements HealthIndicator &#123; @Override public Health health() &#123; //自定义的检查方法 //Health.up().build()代表健康 return Health.down().withDetail(&quot;msg&quot;,&quot;服务异常&quot;).build(); &#125;&#125; 123git.branch=mastergit.commit.id=xjkd33sgit.commit.time=2017-12-12 12:12:56 123456789101112131415161718192021222324management.security.enabled=falsespring.redis.host=118.24.44.169info.app.id=helloinfo.app.version=1.0.0#endpoints.metrics.enabled=falseendpoints.shutdown.enabled=true#endpoints.beans.id=mybean#endpoints.beans.path=/bean#endpoints.beans.enabled=false##endpoints.dump.path=/du# \u5173\u95ED\u6240\u6709\u7AEF\u70B9\u8BBF\u95EE#endpoints.enabled=false#endpoints.beans.enabled=truemanagement.context-path=/managemanagement.port=8181 1]]></content>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小D课堂SpringCloud笔记]]></title>
    <url>%2F2018%2F11%2F10%2FSpringCloud%2F%E5%B0%8FD%E8%AF%BE%E5%A0%82springcloud%2F</url>
    <content type="text"><![CDATA[##SpringCloud课程笔记 第一章 课程介绍和学习路线 1、微服务架构SpringCloud课程介绍​ 简介：课程介绍和课程大纲讲解，讲课风格和重点内容理解技 2、技术选型和学后水平​ 简介：课程所需基础和技术选型讲解，学完课程可以到达怎样的程度，​​ 1、IDEA JDK8 Maven SpringBoot基础 Linux​​ 2、理解掌握并开发SpringCloud里面主流架构和组件的基础使用，还有部分源码原理的理解​​ 3、掌握学习的技巧和解决问题的思路 第二章 架构演进和分布式系统基础知识 1、传统架构演进到分布式架构​ 简介：讲解单机应用和分布式应用架构演进基础知识 (画图) 高可用 LVS+keepalive 1、单体应用： 开发速度慢 启动时间长 依赖庞大 等等 2、微服务 易开发、理解和维护 独立的部署和启动 等 不足： 分布式系统-》分布式事务问题 需要管理多个服务-》服务治理 2、微服务核心基础讲解​ 简介：讲解微服务核心知识 ：网关、服务发现注册、配置中心、链路追踪、负载均衡器、熔断​ 1、网关：路由转发 + 过滤器​ /api/v1/pruduct/ 商品服务​ /api/v1/order/ 订单服务​ /api/v1/user/ 用户服务 2、服务注册发现：调用和被调用方的信息维护 3、配置中心：管理配置，动态更新 application.properties 4、链路追踪：分析调用链路耗时 例子：下单-》查询商品服务获取商品价格-》查询用户信息-》保存数据库 5、负载均衡器：分发负载 6、熔断：保护自己和被调用方 3、常见的微服务框架​ 简介:讲解常用的微服务框架 consumer: 调用方 消费者 客户端 client provider: 被调用方 服务者 服务端 service 一个接口一般都会充当两个角色（不是同时充当） 1、dubbo: zookeeper + dubbo + springmvc/springboot 官方地址：http://dubbo.apache.org/#!/?lang=zh-cn 配套 通信方式：rpc 注册中心：zookeper/redis 配置中心：diamond 2、springcloud: 全家桶+轻松嵌入第三方组件(Netflix 奈飞) 官网：http://projects.spring.io/spring-cloud/ 配套 通信方式：http restful 注册中心：eruka/consul 配置中心：config 断路器：hystrix 网关：zuul 分布式追踪系统：sleuth+zipkin 学习资料：https://blog.csdn.net/zhangweiwei2020/article/details/78646252 4、微服务下电商项目基础模块设计​ 简介：微服务下电商项目基础模块设计 分离几个模块，课程围绕这个基础项目进行学习​ 小而精的方式学习微服务 1、用户服务 1）用户信息接口 2）登录接口 2、商品服务 1）商品列表 2）商品详情 3、订单服务 1）我的订单 2）下单接口 第三章 SpringCloud核心组件注册中心1、什么是微服务的注册中心​ 简介：讲解什么是注册中心，常用的注册中心有哪些 (画图)​​ 理解注册中心：服务管理,核心是有个服务注册表，心跳机制动态维护​​ 服务提供者provider: 启动的时候向注册中心上报自己的网络信息​​ 服务消费者consumer: 启动的时候向注册中心上报自己的网络信息，拉取provider的相关网络信息 为什么要用： 微服务应用和机器越来越多，调用方需要知道接口的网络地址，如果靠配置文件的方式去控制网络地址，对于动态新增机器，维护带来很大问题 主流的注册中心： zookeeper、Eureka、consul、etcd 等 ​ 2、分布式应用知识CAP理论知识​ 简介：讲解分布式核心知识CAP理论 CAP定理： 指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得。 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间的数据完全一致，越多节点，数据同步越耗时） 1可用性（A）：负载过大后，集群整体是否还能响应客户端的读写请求。（服务一直可用，而且是正常响应时间） 分区容错性（P）：分区容忍性，就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好） CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡 ​ ###3、分布式系统CAP原理常见面试题和注册中心选择​ 简介:讲解CAP原则在面试中回答和注册中心选择 C A 满足的情况下，P不能满足的原因： 数据同步(C)需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足 CP 满足的情况下，A不能满足的原因： 数据同步(C)需要时间, 机器数量也多(P)，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足 AP 满足的情况下，C不能满足的原因： 机器数量也多(P)，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足 注册中心选择： Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足 Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化 结论：分布式系统中P,肯定要满足，所以只能在CA中二选一 没有最好的选择，最好的选择是根据业务场景来进行架构设计 如果要求一致性，则选择zookeeper，如金融行业 如果要去可用性，则Eureka，如电商系统 4、SpringCloud微服务核心组件Eureka介绍和闭源后影响​ 简介：​ SpringCloud体系介绍​ 官方地址：http://projects.spring.io/spring-cloud/ Eureka的基础知识--&gt;画图讲解交互流程，服务提供者&lt;--&gt;服务消费者 ; Eureka 2.x闭源后选择 参考：https://www.jianshu.com/p/d32ae141f680 https://blog.csdn.net/zjcjava/article/details/78608892 – 5、服务注册和发现Eureka Server搭建实战​ 简介：使用IDEA搭建Eureka服务中心Server端并启动，项目基本骨架介绍​​ 官方文档：http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-eureka-server​​ 第一步：创建项目​ 第二步: 添加注解 @EnableEurekaServer​ 第三步：增加配置application.yml​ server:​ port: 8761​​ eureka:​ instance:​ hostname: localhost​ client: #声明自己是个服务端 ​ registerWithEureka: false​ fetchRegistry: false​ serviceUrl:​ defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/​ 第四步：访问注册中心页面 maven地址: https://www.cnblogs.com/sword-successful/p/6408281.html 6、服务注册和发现之Eureka Client搭建商品服务实战​ 简介：搭建用商品服务，并将服务注册到注册中心 1、创建一个SpirngBoot应用，增加服务注册和发现依赖 2、模拟商品信息，存储在内存中 3、开发商品列表接口，商品详情接口 4、配置文件加入注册中心地址 使用eureka客户端 官方文档：http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#netflix-eureka-client-starter 7、Eureka服务注册中心配置控制台问题处理​ 简介：讲解服务注册中心管理后台，（后续还会细讲） 问题：eureka管理后台出现一串红色字体：是警告，说明有服务上线率低 EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. 关闭检查方法：eureka服务端配置文件加入 server: enable-self-preservation: false 注意：自我保护模式禁止关闭，默认是开启状态true ​​ 问题二：为什么只加一个注册中心地址，就可以注册​ By having spring-cloud-starter-netflix-eureka-client on the classpath, your application automatically registers with the Eureka Server. Configuration is required to locate the Eureka server, as shown in the following example: 第四章 服务消费者ribbon和feign实战和注册中心高可用 1、常用的服务间调用方式讲解​ 简介：讲解常用的服务间的调用方式 RPC: 远程过程调用，像调用本地服务(方法)一样调用服务器的服务 支持同步、异步调用 客户端和服务器之间建立TCP连接，可以一次建立一个，也可以多个调用复用一次链接 PRC数据包小 protobuf thrift rpc：编解码，序列化，链接，丢包，协议 Rest(Http): http请求，支持多种协议和功能 开发方便成本低 http数据包大 java开发：HttpClient，URLConnection 2、微服务调用方式之ribbon实战 订单调用商品服务​ 简介：实战电商项目 订单服务 调用商品服务获取商品信息​ 1、创建order_service项目​ 2、开发伪下单接口​ 3、使用ribbon. (类似httpClient,URLConnection) 启动类增加注解 @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } 4、根据名称进行调用商品，获取商品详情 3、高级篇幅之Ribbon负载均衡源码分析实战​ 简介: 讲解ribbon服务间调用负载均衡源码分析​ 1、完善下单接口​ 2、分析@LoadBalanced​ 1）首先从注册中心获取provider的列表​ 2）通过一定的策略选择其中一个节点 3）再返回给restTemplate调用 =============================================更多干货技术访问小D课堂官网 https://xdclass.net小D老师个人微信：jack794666918 公众号搜索：小D课堂4、高级篇幅之服务间调用之负载均衡策略调整实战​ 简介：实战调整默认负载均衡策略实战 自定义负载均衡策略：http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html#_customizing_the_ribbon_client_by_setting_properties 在配置文件yml里面，自定义负载均衡策略 #自定义负载均衡策略 product-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 策略选择： 1、如果每个机器配置一样，则建议不修改策略 (推荐) 2、如果部分机器配置强，则可以改为 WeightedResponseTimeRule 5、微服务调用方式之feign 实战 订单调用商品服务​ 简介：改造电商项目 订单服务 调用商品服务获取商品信息​ Feign： 伪RPC客户端(本质还是用http)​ 官方文档: https://cloud.spring.io/spring-cloud-openfeign/ 1、使用feign步骤讲解（新旧版本依赖名称不一样） 加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 启动类增加@EnableFeignClients 增加一个接口 并@FeignClient(name=&quot;product-service&quot;) 2、编码实战 3、注意点： 1、路径 2、Http方法必须对应 3、使用requestBody，应该使用@PostMapping 4、多个参数的时候，通过@RequestParam（&quot;id&quot;) int id)方式调用 6、Feign核心源码解读和服务调用方式ribbon和Feign选择​ 简介: 讲解Feign核心源码解读和 服务间的调用方式ribbon、feign选择​​ 1、ribbon和feign两个的区别和选择​ 选择feign​ 默认集成了ribbon​ 写起来更加思路清晰和方便​ 采用注解方式进行配置，配置熔断等方式方便​​ 2、超时配置​ 默认optons readtimeout是60，但是由于hystrix默认是1秒超时​ #修改调用超时时间 feign: client: config: default: connectTimeout: 2000 readTimeout: 2000 模拟接口响应慢，线程睡眠新的方式 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } 第五章 互联网架构服务降级熔断 Hystrix 实战 1、分布式核心知识之熔断、降级讲解​ 简介：系统负载过高，突发流量或者网络等各种异常情况介绍，常用的解决方案 1、熔断： 保险丝，熔断服务，为了防止整个系统故障，包含子和下游服务 下单服务 -》商品服务 -》用户服务 （出现异常-》熔断） 2、降级： 抛弃一些非核心的接口和数据 旅行箱的例子：只带核心的物品，抛弃非核心的，等有条件的时候再去携带这些物品 ​​ 3、熔断和降级互相交集​ 相同点：​ 1）从可用性和可靠性触发，为了防止系统崩溃​ 2）最终让用户体验到的是某些功能暂时不能用​​ 不同点​ 1）服务熔断一般是下游服务故障导致的，而服务降级一般是从整体系统负荷考虑，由调用方控制 2、Netflix开源组件断路器Hystrix介绍​ 简介：介绍Hystrix基础知识和使用场景​​ 文档地址：​ https://github.com/Netflix/Hystrix​ https://github.com/Netflix/Hystrix/wiki​​ 1、什么是Hystrix？​ 1）hystrix对应的中文名字是“豪猪”​ 2）hystrix 英[hɪst’rɪks] 美[hɪst’rɪks] ​​ 2、为什么要用？​ 在一个分布式系统里，一个服务依赖多个服务，可能存在某个服务调用失败，​ 比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败，​ 通过Hystrix就可以解决​​ http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients​​ 3、提供了熔断、隔离、Fallback、cache、监控等功能 4、熔断后怎么处理？ 出现错误之后可以 fallback 错误的处理信息 兜底数据 3、Feign结合Hystrix断路器开发实战《上》​ 简介：讲解SpringCloud整合断路器的使用，用户服务异常情况 1、加入依赖 注意：网上新旧版本问题，所以要以官网为主，不然部分注解会丢失 最新版本 2.0 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; 2、增加注解 启动类里面增加注解 @EnableCircuitBreaker 注解越来越多-》 SpringCloudApplication注解 3、API接口编码实战 熔断-》降级 1）最外层api使用，好比异常处理（网络异常，参数或者内部调用问题） api方法上增加 @HystrixCommand(fallbackMethod = &quot;saveOrderFail&quot;) 编写fallback方法实现，方法签名一定要和api方法签名一致（注意点！！！） ​ 补充： 修改maven仓库地址 pom.xml中修改 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;/repositories&gt; 4、Feign结合Hystrix断路器开发实战《下》​ 简介：讲解SpringCloud整合断路器的使用，用户服务异常情况​ 1、feign结合Hystrix​​ 1）开启feign支持hystrix (注意，一定要开启，旧版本默认支持，新版本默认关闭)​ feign:​ hystrix:​ enabled: true​​ 2）FeignClient(name=”xxx”, fallback=xxx.class ), class需要继承当前FeignClient的类 5、熔断降级服务异常报警通知实战​ 简介：完善服务熔断处理，报警机制完善 1、加入redis依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2、配置redis链接信息 redis: database: 0 host: 127.0.0.1 port: 6379 timeout: 2000 3、使用 //监控报警 String saveOrderKye = &quot;save-order&quot;; String sendValue = redisTemplate.opsForValue().get(saveOrderKye); final String ip = request.getRemoteAddr(); new Thread( ()-&gt;{ if (StringUtils.isBlank(sendValue)) { System.out.println(&quot;紧急短信，用户下单失败，请离开查找原因,ip地址是=&quot;+ip); //发送一个http请求，调用短信服务 TODO redisTemplate.opsForValue().set(saveOrderKye, &quot;save-order-fail&quot;, 20, TimeUnit.SECONDS); }else{ System.out.println(&quot;已经发送过短信，20秒内不重复发送&quot;); } }).start(); 6、高级篇幅之深入源码剖析Hystrix降级策略和调整​ 简介：源码分析Hystrix降级策略和调整 1、查看默认讲解策略 HystrixCommandProperties 1）execution.isolation.strategy 隔离策略 THREAD 线程池隔离 （默认） SEMAPHORE 信号量 信号量适用于接口并发量高的情况，如每秒数千次调用的情况，导致的线程开销过高，通常只适用于非网络调用，执行速度快 2）execution.isolation.thread.timeoutInMilliseconds 超时时间 默认 1000毫秒 3）execution.timeout.enabled 是否开启超时限制 （一定不要禁用） 4）execution.isolation.semaphore.maxConcurrentRequests 隔离策略为 信号量的时候，如果达到最大并发数时，后续请求会被拒绝，默认是10 官方文档: https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.strategy 2、调整策略 超时时间调整 hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 4000 7、断路器Dashboard监控仪表盘实战​ 简介：讲解断路器Dashboard基础使用和查看​ 1、加入依赖​ ​ org.springframework.cloud​ spring-cloud-starter-netflix-hystrix-dashboard​ &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 2、启动类增加注解 @EnableHystrixDashboard ​​ 3、配置文件增加endpointmanagement: endpoints:​ web:​ exposure:​ include: “*” 4、访问入口 http://localhost:8781/hystrix Hystrix Dashboard输入： http://localhost:8781/actuator/hystrix.stream ​​ 参考资料​ 默认开启监控配置​ https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-actuator​​ 配置文件类：​ spring-configuration-metadata.json 8、断路器监控仪表参数讲解和模拟熔断​ 简介：讲解 断路器监控仪表盘参数和模拟熔断 1、sse server-send-event推送到前端 资料：https://github.com/Netflix/Hystrix/wiki/Dashboard 第六章 微服务网关zuul开发实战 1、微服务网关介绍和使用场景​ 简介：讲解网关的作用和使用场景 (画图)​​ 1）什么是网关​ API Gateway，是系统的唯一对外的入口，介于客户端和服务器端之间的中间层，处理非业务功能 提供路由请求、鉴权、监控、缓存、限流等功能​​ 统一接入​ 智能路由​ AB测试、灰度测试​ 负载均衡、容灾处理​ 日志埋点（类似Nignx日志）​ 流量监控 限流处理 服务降级 安全防护 鉴权处理 监控 机器网络隔离 2）主流的网关 zuul：是Netflix开源的微服务网关，和Eureka,Ribbon,Hystrix等组件配合使用，Zuul 2.0比1.0的性能提高很多 kong: 由Mashape公司开源的，基于Nginx的API gateway nginx+lua：是一个高性能的HTTP和反向代理服务器,lua是脚本语言，让Nginx执行Lua脚本，并且高并发、非阻塞的处理各种请求 2、SpringCloud的网关组件zuul基本使用​ 简介：讲解zuul网关基本使用 1、加入依赖 2、启动类加入注解 @EnableZuulProxy 默认集成断路器 @EnableCircuitBreaker 默认访问规则 http://gateway:port/service-id/** 例子：默认 /order-service/api/v1/order/save?user_id=2&amp;product_id=1 自定义 /xdclass_order/api/v1/order/save?user_id=2&amp;product_id=1 自定义路由转发： zuul: routes: order-service: /apigateway/** 环境隔离配置： 需求 ：不想让默认的服务对外暴露接口 /order-service/api/v1/order/save 配置： zuul: ignored-patterns: - /*-service/api/v1/order/save 3、高级篇幅之Zuul常用问题分析和网关过滤器原理分析 简介：讲解Zuul网关原理和过滤器生命周期， 1、路由名称定义问题 路由映射重复覆盖问题 2、Http请求头过滤问题 3、过滤器执行顺序问题 ，过滤器的order值越小，越先执行 4、共享RequestContext，上下文对象 4、自定义Zuul过滤器实现登录鉴权实战​ 简介：自定义Zuul过滤器实现登录鉴权实战 1、新建一个filter包 2、新建一个类，实现ZuulFilter，重写里面的方法 3、在类顶部加注解，@Component,让Spring扫描 5、高级篇幅之高并发情况下接口限流特技​ 简介：谷歌guava框架介绍，网关限流使用 1、nginx层限流 2、网关层限流 6、Zuul微服务网关集群搭建​ 简介：微服务网关Zull集群搭建 1、nginx+lvs+keepalive https://www.cnblogs.com/liuyisai/p/5990645.html 第七章 分布式链路追踪系统Sleuth和ZipKin实战​ 1、微服务下的链路追踪讲解和重要性 简介：讲解什么是分布式链路追踪系统，及使用好处 2、SpringCloud的链路追踪组件Sleuth实战 简介：讲解分布式链路追踪组件Sleuth实战 1、官方文档 http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#sleuth-adding-project 2、什么是Sleuth 一个组件，专门用于记录链路数据的开源组件 [order-service,96f95a0dd81fe3ab,852ef4cfcdecabf3,false] 1、第一个值，spring.application.name的值 2、第二个值，96f95a0dd81fe3ab ，sleuth生成的一个ID，叫Trace ID，用来标识一条请求链路，一条请求链路中包含一个Trace ID，多个Span ID 3、第三个值，852ef4cfcdecabf3、spanid 基本的工作单元，获取元数据，如发送一个http 4、第四个值：false，是否要将该信息输出到zipkin服务中来收集和展示。 3、添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt; &lt;/dependency&gt; 3、SpringCloud的链路追踪组件Sleuth常见问题说明 简介：讲解分布式链路追踪组件Sleuth常见问题说明 ​ 4、可视化链路追踪系统Zipkin部署 简介：讲解Zipkin的介绍和部署 1、什么是zipkin 官网：https://zipkin.io/ 大规模分布式系统的APM工具（Application Performance Management）,基于Google Dapper的基础实现，和sleuth结合可以提供可视化web界面分析调用链路耗时情况 2、同类产品 鹰眼（EagleEye） CAT twitter开源zipkin，结合sleuth Pinpoint，运用JavaAgent字节码增强技术 StackDriver Trace (Google) 3、开始使用 https://github.com/openzipkin/zipkin https://zipkin.io/pages/quickstart.html zipkin组成：Collector、Storage、Restful API、Web UI组成 4、知识拓展：OpenTracing OpenTracing 已进入 CNCF，正在为全球的分布式追踪，提供统一的概念和数据标准。 通过提供平台无关、厂商无关的 API，使得开发人员能够方便的添加（或更换）追踪系统的实现。 推荐阅读： http://blog.daocloud.io/cncf-3/ https://www.zhihu.com/question/27994350 https://yq.aliyun.com/articles/514488?utm_content=m_43347 5、高级篇幅之链路追踪组件Zipkin+Sleuth实战 简介：使用Zipkin+Sleuth业务分析调用链路分析实战 1、文档 http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_sleuth_with_zipkin_via_http sleuth收集跟踪信息通过http请求发送给zipkin server，zipkinserver进行跟踪信息的存储以及提供Rest API即可，Zipkin UI调用其API接口进行数据展示 默认存储是内存，可也用mysql、或者elasticsearch等存储 2、加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; 里面包含 spring-cloud-starter-sleuth、spring-cloud-sleuth-zipkin 3、文档说明：http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_features_2 4、配置zipkin.base-url 5、配置采样百分闭spring.sleuth.sampler 推荐资料： https://blog.csdn.net/jrn1012/article/details/77837710 =============================================更多干货技术访问小D课堂官网 https://xdclass.net小D老师个人微信：jack794666918 公众号搜索：小D课堂​第八章 微服务核心知识分布式配置中心Config实战​​ 1、微服务下的分布式配置中心​ 简介：讲解什么是配置中心及使用前后的好处 (画图)​ 什么是配置中心：​ 一句话：统一管理配置, 快速切换各个环境的配置​​ 相关产品：​ 百度的disconf​ 地址:https://github.com/knightliao/disconf​​ 阿里的diamand​ 地址：https://github.com/takeseem/diamond​​ springcloud的configs-server:​ 地址：http://cloud.spring.io/spring-cloud-config/ 推荐干货文章：http://jm.taobao.org/2016/09/28/an-article-about-config-center/ 2、SpringCloud的配置中心组件config-server实战 简介：讲解SpringCloud配置中心config-server实战 1、新建项目，创建config-server 2、启动类增加注解 @EnableConfigServer 3、使用git服务器结合Config搭建分布式配置中心 简介：讲解使用git服务器结合Config搭建分布式配置中心 1、默认使用git存储配置中心 使用git服务器，可以自己搭建gitlab服务器 或者使用github、开源中国git、阿里云git 794666918@qq.com xdclass.net123 https://gitee.com/waitforxy/config_cloud.git 2、配置文件添加配置 spring: application: name: config-server #git配置 cloud: config: server: git: uri: https://gitee.com/waitforxy/config_cloud username: 794666918@qq.com password: xdclass.net123 #超时时间 timeout: 5 #分支 default-label: master 3、访问方式（一定要注意语法，如果有问题，会出错） 多种访问路径，可以通过启动日志去查看 例子 http://localhost:9100/product-service.yml /{name}-{profiles}.properties /{name}-{profiles}.yml /{name}-{profiles}.json /{label}/{name}-{profiles}.yml name 服务器名称 profile 环境名称，开发、测试、生产 lable 仓库分支、默认master分支 4、分布式配置中心客户端使用实战​ 简介：微服务里面客户端接入配置中心实战​ 官方文档：http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html#_spring_cloud_config_client​​ 1、加入依赖​ ​ org.springframework.cloud​ spring-cloud-config-client​ ​​ 2、修改对应服务的配置文件,把application.yml 改为 bootstrap.yml​ #指定注册中心地址​ eureka:​ client:​ serviceUrl:​ defaultZone: http://localhost:8761/eureka/​ #服务的名称 spring: application: name: product-service #指定从哪个配置中心读取 cloud: config: discovery: service-id: CONFIG-SERVER enabled: true profile: test #建议用lable去区分环境，默认是lable是master分支 #label: test 注意点： 1.配置文件要用bootstrap.yml 2.默认读取文件名是 服务名称 第九章 微服务消息总线Bus结合消息队列RabbitMQ实战 1、消息总线Bus介绍和使用场景 简介：讲解消息总线Bus介绍和使用场景 1、什么是消息 一个事件，需要广播或者单独传递给某个接口 2、为什么使用这个 配置更新了，但是其他系统不知道是否更新 2、消息队列和RabbitMQ基础介绍 简介：消息队列和RabbitMQ基础介绍 1、消息队列介绍 参考：https://www.cnblogs.com/linjiqin/p/5720865.html 2、同类产品 ActiveMQ RocketMQ Kafka 等 3、SpringCloud默认推荐使用RabbitMQ 4、RabbitMQ介绍 官方文档：http://www.rabbitmq.com/getstarted.html 中文文档：http://rabbitmq.mr-ping.com/ 3、实战系列使用Docker搭建RabbitMQ3.7 简介：使用Docker安装RabbitMQ 1、如果对Docker没基础，课程后续有讲解Docker，可以先跳转过去学习Docker 2、安装步骤 1)拉取镜像：docker pull rabbitmq:management 2)查看当前镜像列表：docker images 3)删除指定镜像：docker rmi IMAGE_ID (如果需要强制删除加 -f) 4)创建容器 docker run -d --name=&quot;myrabbitmq&quot; -p 5671:5671 -p 15672:15672 rabbitmq:management 参数讲解: run: 创建一个新的容器并运行一个命令 -d: 后台运行容器，并返回容器ID -p: 端口映射，格式为：主机(宿主)端口:容器端口 --name=&quot;rabbitmq&quot;: 为容器指定一个名称 3、RabbitMQ默认创建了一个 guest 用户，密码也是 guest, 如果访问不了记得查看防火墙，端口或者云服务器的安全组 管理后台：http://127.0.0.1:15672 其他安装方式： Linux安装：https://blog.csdn.net/qq_34021712/article/details/72567786 windows安装：http://www.rabbitmq.com/install-windows.html https://blog.csdn.net/liyuejin/article/details/78410586 4、高级篇幅消息总线整合配置中心架构流程图 简介：讲解消息总线Bus结合config组件搭建配置中心项目架构图和操作流程 启动 rabbitmq： docker run -d -p 5672:5672 -p 15672:15672 rabbitmq:management rabbitmq默认是5672,所以改为5672端口 1、config-client加入依赖 &lt;!--配置中心结合消息队列--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; ​​ 官方文档：http://cloud.spring.io/spring-cloud-bus/single/spring-cloud-bus.html#_bus_refresh_endpoint​ 文档里面 暴露端点 management.endpoints.web.exposure.include=bus-refresh​​ 2、在配置文件中增加关于RabbitMQ的连接(如果是本机，则可以直接启动，采用默认连接配置)​ spring:​ rabbitmq:​ host: localhost​ port: 5672​ username: guest​ password: guest​​ #暴露全部的监控信息​ management:​ endpoints:​ web:​ exposure:​ include: “*”​​ 3、需要刷新配置的地方，增加注解​ @RefreshScope​ 4、访问验证 post方式： http://localhost:8773/actuator/bus-refresh 5、动态刷新配置: 在开发和测试环境使用，尽量少在生产环境使用 5、微服务相关项目改造配置中心 简介：把课程项目改造成配置中心讲解 1、git里面新增对应项目的配置文件，都要添加下面的配置 #服务的名称 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest #暴露全部的监控信息 management: endpoints: web: exposure: include: &quot;*&quot; ​​ 2、项目里面添加maven依赖​​ ​ ​ org.springframework.cloud​ spring-cloud-config-client​ ​​ ​​ ​ org.springframework.boot​ spring-boot-starter-actuator​ ​ org.springframework.cloud spring-cloud-starter-bus-amqp 3、修改application.properties为bootstrap.yml 并拷贝配置文件 #指定注册中心地址 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ #服务的名称 spring: application: name: order-service #指定从哪个配置中心读取 cloud: config: discovery: service-id: CONFIG-SERVER enabled: true profile: test 4、各个项目启动顺序 1）注册中心 2）配置中心 3）对应的服务：商品服务、订单服务。。。 4）启动网关 第十章、SpringCloud课程内容上半部分总结​ 1、微服务核心知识内容回顾 简介：回顾SpringCloud前面10章的基础内容 1)介绍微服务的基础知识，核心组件，CAP原理 2）SpringCloud注册中心 Eureka 3）product-service / order-service 4) 伪RPC Ribbon / feign 5) hystrix熔断 6) 服务网关介绍，zuul 7）配置中心config-server ​ 2、微服务下半部分知识 云服务器和Docker容器 简介：讲解云服务器和容器知识 ​ 第十一章 阿里云ECS服务器介绍和网络知识讲解 1、云服务器介绍和阿里云服务器ECS服务器选购 简介：什么是云服务器及目前主要的几个厂商介绍 1、阿里云、腾讯云、亚马逊云 阿里云：https://www.aliyun.com/ 腾讯云：https://cloud.tencent.com/ 亚马逊云：https://aws.amazon.com/ ​​ 2、阿里云服务器远程登录和常用工具​ 简介：讲解阿里云服务器登录使用和常见终端工具​ 1、windows工具 putty，xshell, security​ 参考资料：​ https://jingyan.baidu.com/article/e75057f210c6dcebc91a89dd.html​ https://www.jb51.net/softjc/88235.html​​ 2、苹果系统MAC： 通过终端登录​ ssh root@ip 回车后输入密码​ ssh root@120.25.1.38​​ 3、可以尝试自己通过百度进行找文档， 安装mysql jdk nginx maven git redis elk 3、互联网架构知识之网站部署上线基础准备​ 简介：讲解应用部署到可以公网访问需要步骤 1、一个http请求的故事 2、什么是cname和a记录 A记录和CNAME只可以同时生效一个，A记录优先 3、域名和ip的关系，DNS作用 参考资料： https://blog.csdn.net/benbenzhuhwp/article/details/44704319 https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;ch=1&amp;tn=98050039_dg&amp;wd=%E4%B8%80%E4%B8%AAhttp%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B&amp;rsv_pq=80a65c5f00005961&amp;rsv_t=a5fcWreuJzILdSwr4gI8pFqlO7HSu5BlhjwalyVzPiV9w2L%2BKEj78pPi1Qn6Vx4wXxI&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=8&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;sug=%25E4%25B8%2580%25E4%25B8%25AAhttp%25E8%25AF%25B7%25E6%25B1%2582%25E7%259A%2584%25E8%25AF%25A6%25E7%25BB%2586%25E8%25BF%2587%25E7%25A8%258B&amp;rsv_n=1 4、域名购买和配置解析实战​ 简介：域名购买和配置解析实战 1、购买域名，备案 阿里云 备案地址：https://beian.aliyun.com/ 2、购买服务器，阿里云，腾讯云，亚马逊云aws 3、配置域名解析到服务器 ​ ​第十二章 微服务必备技能Docker容器基础篇幅​​ 1、微服务下的Docker介绍和使用场景​ 简介：Docker介绍和使用场景​​ 1、什么是Dokcer​ 百科:一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口；​​ 使用go语言编写，在LCX（linux容器）基础上进行的封装​​ 简单来说：​ 1）就是可以快速部署启动应用​ 2）实现虚拟化，完整资源隔离​ 3）一次编写，四处运行（有一定的限制，比如Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用）​ 2、为什么要用 1、提供一次性的环境，假如需要安装Mysql，则需要安装很多依赖库、版本等，如果使用Docker则通过镜像就可以直接启动运行 2、快速动态扩容，使用docker部署了一个应用，可以制作成镜像，然后通过Dokcer快速启动 3、组建微服务架构，可以在一个机器上模拟出多个微服务，启动多个应用 4、更好的资源隔离和共享 一句话：开箱即用，快速部署，可移植性强，环境隔离 2、Linux云服务器Centos7安装Docker实战 简介：讲解阿里云ECS服务安装Docker实战 Linux Standard Base的缩写，lsb_release命令用来显示LSB和特定版本的相关信息 命令： lsb_release -a 阿里云安装手册： https://help.aliyun.com/document_detail/51853.html?spm=a2c4g.11186623.6.820.RaToNY 常见问题： https://blog.csdn.net/daluguishou/article/details/52080250 3、Docker仓库、镜像、容器核心知识讲解 简介：快速掌握Dokcer基础知识， 1、概念： Docker 镜像 - Docker images： 容器运行时的只读模板，操作系统+软件运行环境+用户程序 class User{ private String userName; private int age; } Docker 容器 - Docker containers： 容器包含了某个应用运行所需要的全部环境 User user = new User() Docker 仓库 - Docker registeries： 用来保存镜像，有公有和私有仓库，好比Maven的中央仓库和本地私服 镜像仓库： （参考）配置国内镜像仓库：https://blog.csdn.net/zzy1078689276/article/details/77371782 对比面向对象的方式 Dokcer 里面的镜像 : Java里面的类 Class Docker 里面的容器 : Java里面的对象 Object 通过类创建对象，通过镜像创建容器 4、Docker容器常见命令实战 简介：讲解Docker在云服务上的实际应用 1、 常用命令（安装部署好Dokcer后，执行的命令是docker开头）,xxx是镜像名称 搜索镜像：docker search xxx 列出当前系统存在的镜像：docker images 拉取镜像：docker pull xxx xxx是具体某个镜像名称(格式 REPOSITORY:TAG) REPOSITORY：表示镜像的仓库源,TAG：镜像的标签 运行一个容器：docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 rabbitmq:management docker run - 运行一个容器 -d 后台运行 -p 端口映射 rabbitmq:management (格式 REPOSITORY:TAG)，如果不指定tag，默认使用最新的 --name &quot;xxx&quot; 列举当前运行的容器：docker ps 检查容器内部信息：docker inspect 容器名称 删除镜像：docker rmi IMAGE_NAME 强制移除镜像不管是否有容器使用该镜像 增加 -f 参数， 停止某个容器：docker stop 容器名称 启动某个容器：docker start 容器名称 移除某个容器： docker rm 容器名称 （容器必须是停止状态） 文档： https://blog.csdn.net/permike/article/details/51879578 5、实战应用之使用Docker部署Nginx服务器 简介：讲解使用Docker部署Nginx服务器实战 1、获取镜像 docker run (首先会从本地找镜像，如果有则直接启动，没有的话，从镜像仓库拉起，再启动) docker search nignx 2、列举 docker images 3、拉取 docker pull nignx 3、启动 docker run -d --name &quot;xdclass_nginx&quot; -p 8088:80 nginx docker run -d --name &quot;xdclass_nginx2&quot; -p 8089:80 nginx docker run -d --name &quot;xdclass_nginx3&quot; -p 8090:80 nginx 4、访问 如果是阿里云服务，记得配置安全组，腾讯云也需要配置，这个就是一个防火墙 6、公司中Docker镜像仓库使用讲解 简介：讲解一般公司中镜像仓库在的使用 1、为啥要用镜像仓库 2、官方公共镜像仓库和私有镜像仓库 公共镜像仓库： 官方：https://hub.docker.com/，基于各个软件开发或者有软件提供商开发的 非官方：其他组织或者公司开发的镜像，供大家免费试用 私有镜像仓库： 用于存放公司内部的镜像，不提供给外部试用； SpringCloud 开发了一个支付系统 -》做成一个镜像 （操作系统+软件运行环境+用户程序） 7、高级篇幅之构建自己的镜像仓库 简介：使用阿里云搭建自己的镜像仓库 1、阿里云镜像仓库：https://dev.aliyun.com/search.html 点击管理控制台-》初次使用会提示开通，然后设置密码 xdclass.net123 2、使用阿里云私有镜像仓库 1)登录： docker login --username=794666918@qq.com registry.cn-shenzhen.aliyuncs.com 2) 推送本地镜像： docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:[镜像版本号] 例子： docker tag 2f415b0e9a6e registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:xd_rabbitmq-v1.0.2 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:xd_rabbitmq-v1.0.2 3)拉取镜像 线上服务器拉取镜像： docker login --username=794666918@qq.com registry.cn-shenzhen.aliyuncs.com docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:xd_rabbitmq-v1.0.2 启动容器： docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 2f415b0e9a6e 第十三章 微服务高级篇幅SpringCloud和Docker整合部署​​ 第1课 高级篇幅之构建SpringBoot应用docker镜像上集​​ 简介:使用Docker的maven插件，构建springboot应用​ 官方文档：https://spring.io/guides/gs/spring-boot-docker/ 1、步骤：maven里面添加配置pom.xml &lt;properties&gt; &lt;docker.image.prefix&gt;xdclass&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;finalName&gt;docker-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 配置讲解 Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。 ${project.build.finalName} 产出物名称，缺省为${project.artifactId}-${project.version} =============================================更多干货技术访问小D课堂官网 https://xdclass.net小D老师个人微信：jack794666918 公众号搜索：小D课堂第2课 高级篇幅之构建SpringBoot应用docker镜像下集 简介:打包SpringCloud镜像并上传私有仓库并部署 1、创建Dockerfile,默认是根目录，（可以修改为src/main/docker/Dockerfile,如果修则需要制定路径） 什么是Dockerfile : 由一系列命令和参数构成的脚本，这些命令应用于基础镜像, 最终创建一个新的镜像 FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 参数讲解： FROM &lt;image&gt;:&lt;tag&gt; 需要一个基础镜像，可以是公共的或者是私有的， 后续构建会基于此镜像，如果同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令 VOLUME 配置一个具有持久化功能的目录，主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录 ARG 设置编译镜像时加入的参数， ENV 是设置容器的环境变量 COPY : 只支持将本地文件复制到容器 ,还有个ADD更强大但复杂点 ENTRYPOINT 容器启动时执行的命令 EXPOSE 8080 暴露镜像端口 2、构建镜像 mvn install dockerfile:build 打标签 docker tag a1b9fc71720d registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 推送到镜像仓库 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 应用服务器拉取镜像 docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 docker run -d --name xdclass_docker_demo1 -p 8099:8080 a1b9fc71720d 3、查看启动日志 docker logs -f containerid 文档：https://yeasy.gitbooks.io/docker_practice/image/dockerfile/ 第3课 实战系列之注册中心打包Docker镜像 简介：讲解使用Docker打包注册中心，上传私有镜像仓库并部署 1、新增maven插件 &lt;properties&gt; &lt;docker.image.prefix&gt;xdclass&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;finalName&gt;docker-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2、新建Dockerfile FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 3、打包： mvn install dockerfile:build 4、推送阿里云镜像仓库 阿里云镜像仓库：https://dev.aliyun.com/search.html docker tag 062d2ddf272a registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:eureka-v20180825docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:eureka-v20180825docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:eureka-v20180825 5、查看日志 docker logs -f containerid 第4课 实战系列之部署RabbitMQ和配置中心打包Docker镜像 简介：讲解使用Docker打包配置中心，和部署RabbitMQ 1、服务地址 ssh root@47.106.120.173 部署 rabbitmq： docker run -d -p 5672:5672 -p 15672:15672 rabbitmq:management 2、推送镜像 docker tag 0f636543904e registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180825 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180825 docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180825 5、常见问题处理之升级云服务器 简介：处理上节课出现的问题，升级服务器注意事项 1、升级云服务器配置（购买配置后需要重启机器才生效） 2、启动完成后，需要开启docker 指令： systemctl start docker 3、所有对外的都要经过网关才可以对外，应用间通信(除非跨机房)都用内网通信 6、实战系列之Docker部署Redis 简介：使用Docker安装redis 1、搜索镜像 docker search redis 2、拉取 docker pull docker.io/redis 3、启动 docker run --name &quot;xd_redis&quot; -p 6379:6379 -d 4e8db158f18d 参考： docker run --name &quot;xd_redis&quot; -p 6379:6379 -d 4e8db158f18d --requirepass &quot;123456&quot; -v $PWD/data:/data 4、访问redis容器里面，进行操作 docker exec -it 295058d2b92e redis-cli 7、生产环境常见问题之配置中心访问 简介：讲解生产环境部署常见问题，配置中心访问路径变化 1、配置中心访问出错，路径不对 解决：修改所有的注册中心，增加下面配置 instance: instance-id: ${spring.cloud.client.ip-address}:${server.port} prefer-ip-address: true docker tag 50a12cd66210 registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180826 8、实战系列之打包Docker镜像打包商品服务和订单服务、网关 简介:打包Docker镜像部署商品服务和订单服务、网关 注意： 1、maven打包构建，会触发单元测试，部分情况可以跳过， mvn install -Dmaven.test.skip=true dockerfile:build 2、生产环境不能用localhost 或者 127.0.0.1, 一定要用内网通信ip (虚拟主机映射 hosts) 9、实战系列云服务器部署网关、订单、商品服务 简介：云服务部署商品服务、订单服务、网关服务 1、拉取镜像、启动 访问路径 http://47.106.120.173:8781/api/v1/order/save?product_id=5&amp;user_id=5 http://47.106.120.173:9000/apigateway/order/api/v1/order/save?user_id=5&amp;product_id=3&amp;token=232serer 第十四章 课程总结和常见问题处理 1、SpringCloud微服务常见问题和解决思路 简介：讲解SpringCloud开发实战常见问题，及解决思路 1、技术选择：SpringCloud全家桶，每个组件又有多个替代，改怎么选择 1）选择的时候根据公司里面团队人员熟悉程度，降低学习成本 2）选择社区活跃的并且文档相对较多的，怎么判断活跃，可以看github上代码提交和start数 2、云服务选择： 腾讯云，阿里云 ，遇到问题可以提交工单，有专人跟进 ​​ 3、部署了应用，但是访问不了​ 解决思路：​ 1)查看应用启动是否正常，如果有错误日志，复制错误日志去百度搜索！！！！！！！特别重要​​ 2）启动正常，则先在本机使用 CURL “http://lcoalhost:8080/api/v1/user/find&quot; 访问对应的接口，看是否有响应​​ 3）启动正常，且curl有响应，则检查是否有关闭防火墙，或者开放对应的访问端口，开放端口才可以访问​​ 4）腾讯云和阿里云都是有安全组，类似外层防火墙，一定要去web控制台检查是否有开启端口 4、内网和外网访问，鉴权问题安全问题 1）所有应用只能通过网关提供对外访问的入口 2）应用程序之间通讯，采用内网 5、程序出错或者异常: 复制错误日志去百度搜索，网上有很多人会遇到类似的错误，多积累，特别强调 2、课程总结和后续技术规划 简介：总结SpringCloud课程和微服务后续课程规划 1、springCloud全家桶，技术选择和知识点特别多，一定要学会记笔记，微服务更多关注的是里面架构和数据流转，而不是具体的业务。 2、SpringCloud架构这些配置，一般使用一次后就不会多次修改了，进入公司主要还是开发业务，业务开发一般都用springboot，比较少让新人搭建SpringCloud的架构 3、开发业务，无非就是CRUD，增删改查，只不过是初级和高级的区别，封装成通用和不通用的区别 ​​ 4、微服务和容器盛行的情况下，容器编排和自动缩扩容越来越重要​​ 可以关注：k8s / service mesh /server less 等技术 ​​ 总结：​ 1）后续会推出对应的课程，还有项目实战系列，大家记得关注 小D课堂，官网 ：https://xdclass.net,​​ 2）也可以加我微信交流： jack794666918​​ 3）购买对应的课程后，记得进我们小D课堂官方的交流群，我会在里面分享主流技术和答疑，面试经验等等，还会同步更新资料和还超级干货分享 =============================================]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见问题总结]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前端向后端传值： Button 和form 1234567function goUpdatePage(id) &#123; window.location.href = "$&#123;pageContext.request.contextPath&#125;/user/editcontroller?id=" + id;&#125; &lt;button type="button" onclick="goUpdatePage($&#123;user.id&#125;)" class="btn btn-primary btn-xs"&gt; &lt;i class=" glyphicon glyphicon-pencil"&gt;&lt;/i&gt;&lt;/button&gt; 开发中service层 必须要写 @service注解 ⚠️service中不要加@service。在service的实现serviceiml中加@service注解 开发的顺序 从前端传值到Controller 再到 service 再到serviceimpl 再到userdao 再到mybatis.xml再到数据库 数据库返回前端页面 引入mybatis 的多个mapper的配置文件 mapper.xml Spring Boot 的方式 12mybatis.mapper-locations=classpath:mybatis/mapper/*.xml ###idea警告：Field injection is not recommended ####Springboot开发 Dao中UserDao RoleDao中要加 @Mapper注解 # import和open项目是不一样的 出现上面的情况要import一下啊 兄ide Caused by: org.apache.ibatis.type.TypeException: Could not resolve type alias ‘BaseResultMap’ Cause: org.apache.ibatis.builder.BuilderException: Error resolving class. Ca 看到那个resultType了么，就是它惹的祸，这里把resultType改为resultMap就OK啦，重启tomcat，木有异常啦 跳转视图 用字符串哈 开发中前端的img要放到和框架的同一目录及下面哈。兄die 1Connection connection = ConnectionUtils.getConnection(); 用类.方法（）.var 可以直接返回该对象的返回对象 Sting s=”test” 1System.out.println(s);===s.sout 时间问题 https://blog.csdn.net/qq_34160679/article/details/80651027 1jdbc.url = jdbc:mysql:/xxx:3306/zhongfubang?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai Linux 无法使用命令export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin修改/etc/profile文件，配置maven环境变量时候出问题了，忘记加了 $PATH: 然后source /etc/profile 接下来就是 ll,ls,vim命令都用不了。。。害的我以为xshell我更新了呢，卸载重装了还是没用。 解决办法如下图，执行这两条命令： 123export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin vim /etc/profile SpringBoot 主类报错 1在idea中使用终端 然后使用mvn install命令。删掉有问题的jar包重新下载。 解决问题 Idea相关1装一个lombok插件才会有get set方法 1234MybatisPluginCodes插件 findBy... 看文档 卸载其他相关插件 commond+1 创建SQl语句 self4j log4j的问题1ggerFactory is not a Logback LoggerContext but Logback is on the classpath. Either remove Logback or the competing implementation 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;--------------------- Springboot 依赖冲突 Maven logs遇到错误 重启Idea 或者关机重启电脑 SpringBoot +Mybatis 整合问题： 使用Yml 添加mapperxml 12345@RequestMapping(&quot;/&#123;id&#125;&quot;) @ResponseBody public Mydb01 list(@PathVariable(&quot;id&quot;) Integer id) &#123;//@PathVariable(&quot;id&quot;) id是不是一定要写 return userService.selectByPrimaryKey(id); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ITerm2的配置]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2FIterm2%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ITerm2的配置问题每次vim的时候一定要source一下 啊 xiong die 学习资源 https://www.jianshu.com/p/9c3439cc3bdb 简书 https://github.com/sirius1024/iterm2-with-oh-my-zsh Github https://www.cnblogs.com/xishuai/p/mac-iterm2.html 博客园 https://blog.csdn.net/z3512498/article/details/51245853 CSDN 改变用户名 必须要使用vim的命令修改配置 常见的命令1234vi ~/.zshrcsource ~/.zshrc （soucre配置文件 让配置文件生效）文件放在itermgit下面 必须要在主题可以使用的情况下 进行以上的配置快捷键冲突 取词 copy失效 常见问题 安装完成后，在/bin目录下会多出一个zsh的文件。 Mac系统默认使用dash作为终端，可以使用命令修改默认使用zsh： 1chsh -s /bin/zsh 如果想修改回默认dash，同样使用chsh命令即可： 1chsh -s /bin/bash export MAVEN_HOME=/Java/apache-maven-3.5.4 export PATH=${PATH}:${MAVEN_HOME}/bin]]></content>
      <tags>
        <tag>Iterm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-web]]></title>
    <url>%2F2018%2F11%2F08%2FDocker%2FDocker-web%2F</url>
    <content type="text"><![CDATA[学习地址* https://www.imooc.com/video/14624（慕课网）-6⃣刘果国 #第一个 java web项目 （SpringBoot 项目打包成一个war包的方式） 一制作自己的景象 Dockerfile docker build 首先需要一个war文件 拷贝在桌面上 Docker images 1.建立一个Dockerfile vim Dockerfile 2. 下载Tomcat镜像 网易镜像中心 找Tomcat的镜像 https://c.163yun.com/hub#/m/home/ （包括JDK Tomcat） 1docker pull hub.c.163.com/library/tomcat:latest 站在巨人的肩上 3.编辑Dockerfile1234567在Mac终端中使用vim编辑文件步骤1. cd 文件所在的文件夹路径 &lt;回車&gt;2. 輸入 vim 文件名 &lt;回車&gt;3. 按下 i 鍵來编辑文本文字4. 退出vim編輯器： 不保存并退出 &lt;ESC&gt; :q! &lt;回車&gt; 保存并退出 &lt;ESC&gt; :wq &lt;回車&gt; from hub.c.163.com/library/tomcat MAINTAINER Freemana2017 1047629166@qq.com 1234cd /Users/apple/Desktop/Dockerwebls&gt; mv atcrodfunding3_ssm-0.0.1-SNAPSHOT.war atcrod.warmv atcrodfunding3_ssm-0.0.1-SNAPSHOT.war atcrod.war (用MV 重新命名一下) 进入文件夹里面 编写Dockerfile 学会看镜像的说明 1234567891011121314151617How to use this image.Run the default Tomcat server (CMD [\&quot;catalina.sh\&quot;, \&quot;run\&quot;]):$ docker run -it --rm tomcat:8.0You can test it by visiting http://container-ip:8080 in a browser or, if you need access outside the host, on port 8888:$ docker run -it --rm -p 8888:8080 tomcat:8.0You can then go to http://localhost:8888 or http://host-ip:8888 in a browser.The default Tomcat environment in the image for versions 7 and 8 is:⭐️CATALINA_BASE: /usr/local/tomcat⭐️CATALINA_HOME: /usr/local/tomcatCATALINA_TMPDIR: /usr/local/tomcat/tempJRE_HOME: /usrCLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar 1。编写Dockerfile 文件–Dockerfile12345from hub.c.163.com/library/tomcatMAINTAINER Freemana2017 1047629166@qq.comCOPY atcrod.war /usr/local/tomcat/webapps 2.创建镜像 –docker build 3.查看镜像–docker images 4.给镜像写名字 docker build -t atcrod:latest . 5.再次查看镜像 docker images ###二运行自己的容器1.docker run -d -p 8888:8080 atcrod 8888本机的端口号。8080Tomcat的端口号 去163.com查询 atcrod镜像的名字 2.docker ps 查看Tomcat的进程 检查容器是不是启动啦 3.netstat -na|grep 8888 检查端口是不是存在了 输入localhost:8888测试Tomcat是否启动啦 ⚠️ 以上只是web项目在Docker中的部署项目3.Docker 部署SpringBoot web项目 学习资源汇总 http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html https://blog.csdn.net/weixin_39800144/article/details/79214978 https://blog.csdn.net/weixin_39800144/article/details/79213276 https://bingohuang.com/spring-boot-docker/ FROM java:8 VOLUME /tmp COPY target/tran4spd-1.0-SNAPSHOT.jar resource.jar. #这边放的是Docker部署的jar包的位置 绝对路径 RUN bash -c “touch /resource.jar” EXPOSE 8080 ENTRYPOINT [“java”,”-jar”,”resource.jar”] # docker run -d -p 18080:8099 –name docker-resource leesia/resource:1.0 注意java-jar无法运行Tomcat要外置 1234567&lt;!-- https://mvnrepository.com/artifact/javax.servlet/servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; ##文件路径不要用中文！！！]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker SpringBoot]]></title>
    <url>%2F2018%2F11%2F07%2FDocker%2FDocker-SpringBoot%2F</url>
    <content type="text"><![CDATA[DockerMachine应用注意整个过程要等待一下 参考https://study.163.com/course/courseLearn.htm?courseId=1002892012#/learn/video?lessonId=1003309140&amp;courseId=1002892012 网易云课堂 动手玩Docker 安装DockerMachine docker-machine ls tcp://192.168.99.100:2376 name：cloudcomb docker-machine create –driver virtualbox cloudcomb Docker-machine env cloudcomb ⚠️第四个变量eval说的是当前Dockermachine的名字是—cloudcomb eval $(docker-machine env cloudcomb) 拷贝放到底下 使用网易蜂巢 Docker run hub.c163.com/library/busybox:latest echon hello world （unable。。这个过程要等待啊）⭐️ docker-machine rm cloudcomb 删除docker-machine SpringBoot整合Docker Emmmm.等我有钱了 把Xnip去掉哈哈 下载源码https://github.com/bingohuang/spring-boot-docker Git 通过命令行下载文件 先cd一下指定一下下载的路径 导入项目到Idea 然后查看一下源码 运行一下项目（访问一下 测试一下） Docker SpringBoot部署项目 ⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ 1.install项目 找到这两个文件 放到桌面上 2.将这两个项目放到一个文件下，不知道为什么好像要把jar改名成gs-spring-boot-docker-0.0.1.jar 3.cd到文件下 ls一下4.执行 ˛docker version 5.执行 docker-machine env 6.执行eval $(docker-machine env)（复制后面的第四条） tcp://192.168.99.100:2376192.168.99.100 tcp://127.0.0.1:2376 tcp://127.0.0.1:2376 ###7.docker version（没有-） 8.ls一下目录 9.docker build -t cloudcomb/sun:1.0 . （桌面上要有jar包和dockerfilede 文件） 此时报错 没有gs-spring-boot-docker.jar文件 其实ls的时候就应该是gs-spring-boot-docker.jar 这儿是个bug。 解决办法 改jar包名 添加gs前缀 1https://docker.mirrors.ustc.edu.cn 10。docker build -t cloudcomb/sun:1.0 .（大佬说这一步是拉取镜像。用加速器 改名后重新执行命令）我们可以用大佬网易云的Dokcer镜像 11. docker images -a 12.docker run -p 1024:8080 -t cloudcomb/sun:1.0 . 注意 cloudcomb和前面的cloudcomb要一一对应 1024 与8080是一一对应的关系 Error: Unable to access jarfile /app.jar ⭐️ ADD user-server-0.0.1-SNAPSHOT.jar app.jar 要和pom的user-server 保持名字一样，不然maven打出来的包，docker找不到。 最终的结局办法 好像是将copy去掉了 注意看控制台打印的信息 兄dei DockerFile： Docker就是给一名字 gs-spring-bbot 贴一个Dockerfilr。 1234567891011121314151617181920212223242526272829303132333435FROM hub.c.163.com/xbingo/jdk8:latestfrom hub.c.163.com/library/tomcatMAINTAINER Freemana2017 1047629166@qq.comADD atcrodfunding3_ssm-0.0.1-SNAPSHOT.jar app.jarENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]COPY atcrod.war /usr/local/tomcat/webapps #FROM openjdk:8-jdk-alpine#VOLUME /tmp#ADD atcrodfunding3_ssm-0.0.1-SNAPSHOT.jar app.jar#ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]# #FROM hub.c.163.com/xbingo/jdk8:latest##ADD gs-spring-boot-docker-0.1.0.jar app.jar##ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] #这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:##FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载#VOLUME ，VOLUME 指向了一个/tmp的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/tmp作为工作目录。这个命令的效果是：#在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/tmp目录#ADD ，拷贝文件并且重命名#ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT#这样 Spring Boot 项目添加 Docker 依赖就完成了。 Dockerfile 用的war要有Tomcat 自己理解吧 多看一些视频笔记什么的 反正很难,,, 以上的文件是从github上拉的 现在自己构建SpringBoot -jar的应用 通过群里的指导 估计jar打包和war打包区别不大吧 下面通过SpringBoot构建Docker部署一下试试 https://waylau.com/docker-spring-boot/ http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html https://lw900925.github.io/docker/docker-springboot.html https://www.tianmaying.com/tutorial/spring-boot-docker https://bingohuang.com/spring-boot-docker/ https://www.imooc.com/search/?words=docker http://www.ityouknow.com/docker/2018/03/30/docker-machine.html https://spring.io/guides/gs/spring-boot-docker/ SpringBoot Docker https://lw900925.github.io/docker/docker-springboot.html http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html 主要环节 $ sudo docker tag [ImageId] ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号]$ sudo docker push ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号] ⭐️ sudo docker tag 5fc4ede68fcd ccr.ccs.tencentyun.com/atcrod/latest sudo docker push ccr.ccs.tencentyun.com/atcrod/latest]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-Idea]]></title>
    <url>%2F2018%2F11%2F07%2FDocker%2FDocker-Idea%2F</url>
    <content type="text"><![CDATA[###1.Docker 在Intellij中的使用 Machine的安装 compose的安装 Docker的配置 首先学习什么东西都要用官网的东西 安装Docker的插件-看网上教程 看Docker插件的官网 hrer 学习英文。任何东西官网都用详细说明的 学习Docker 学习SpringBoot整合Docker 学习运维 下面开始Docker的学习 1.现在插件 2.看网址的教程 3.安装machin和compose machine和compose的安装参考 1.Gitbook书 https://yeasy.gitbooks.io/docker_practice/content/compose/install.html 2。官方文档（为主） https://docs.docker.com/machine/install-machine/ ⭐️ （为什么每次都要重新下载dockermachine） Docker-machine env 不能执行二进制文件 首先要 重新下载Dockermachihe 123base=https://github.com/docker/machine/releases/download/v0.14.0 &amp;&amp; curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/usr/local/bin/docker-machine &amp;&amp; chmod +x /usr/local/bin/docker-machine 3.Github https://github.com/docker/machine/releases https://github.com/docker/machine 2.有些东西放在了云收藏里面Docker的用户名是2018112#####安装Docker插件要开VPN 还有访问Gitbub也要开VPN wiredes的 安装Docker要安装DookerToolBox 3.Docker ！！Docker真是一个恐怖的东西 ######Docker的学习资源GitBook里面的Docker的附录部分 https://blog.lab99.org/post/docker-2016-07-14-faq.html 1.无独有偶通过Docker-SpirngBoot的学习了解了TCP socker Engine API URL的填写 Docker开启远程访问这是过程中产生的问题 安装了socket 以后想办法删除 PS：Docker服务中进程间通信通过/var/run/docker.sock实现，默认服务不提供监听端口，因此使用docker remote api 需要手动绑定端口。方法： 12&gt; `# service docker stop``# docker -d -H unix:``///var/run/docker.sock -H tcp://0.0.0.0:2375`&gt; ###2.点击+号添加一个docker配置，输入Name和Engine API URL，URL是docker服务地址，需要docker开启远程连接功能。CentOS中在docker启动参数里添加如下配置即可开启远程连接。 -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 下面是docker在idea中的安装 clouds里面没有Docker。在Docker中配置 TCP：tcp：//127.0.0.1:2376 注意这个是通过终端命令得到的 1234567docker-machine env cloudcombexport DOCKER_TLS_VERIFY=&quot;1&quot;export DOCKER_HOST=&quot;tcp://192.168.99.101:2376&quot;export DOCKER_CERT_PATH=&quot;/Users/apple/.docker/machine/machines/cloudcomb&quot;export DOCKER_MACHINE_NAME=&quot;cloudcomb&quot;# Run this command to configure your shell:# eval $(docker-machine env cloudcomb) 将前面的端口换成本地的 tcp:127.0.0.1:2376 emm睡一觉起来VPN打开要等一会 在终端输入dockerversion docker-machine env—Host is not running #学习资源：通过Github的搜索功能🔍 发现一些学习资料https://www.jetbrains.com/help/idea/docker.html alip1sudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latest 1234567891011FROM java:8VOLUME /tmpsudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latestCOPY target/tran4spd-1.0-SNAPSHOT.jar resource.jarRUN bash -c &quot;touch /resource.jar&quot;EXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;resource.jar&quot;]# docker run -d -p 18080:8099 --name docker-resource leesia/resource:1.0]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的使用教程]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2FHexo%2F</url>
    <content type="text"><![CDATA[主题copy一份在apple中不需要终端new 或者 标题title直接复制也是可以的有时候有延迟下面就是图片的问题啦 用图床ipic解决问题 https://www.jianshu.com/p/dbc945b05d55 PIC https://sspai.com/post/39965 少数派 ### https://hexo.io/zh-cn/docs/front-matter 学习Hexo按照这个网站里面有教程 学习任何东西都要使用官方文档 其余学习的东西在safair收藏➕随笔 hexo里面 真的好累 搭建这个环境 总之就是照着官网的例子 然后使用这个模版 然后yml文件要写全 坑太多了 能出一本书 先这样]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 雷丰阳]]></title>
    <url>%2F2018%2F03%2F06%2FSpring%20Boot%2FSpring%20Boot%2F</url>
    <content type="text"><![CDATA[一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.atguigu.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; ##4、配置文件占位符 1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings("rawtypes")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path="/hello" view-name="success"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = "spring.messages")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="asserts/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="asserts/css/signin.css" th:href="@&#123;/asserts/css/signin.css&#125;" rel="stylesheet"&gt; &lt;/head&gt; &lt;body class="text-center"&gt; &lt;form class="form-signin" action="dashboard.html"&gt; &lt;img class="mb-4" th:src="@&#123;/asserts/img/bootstrap-solid.svg&#125;" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72"&gt; &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#&#123;login.tip&#125;"&gt;Please sign in&lt;/h1&gt; &lt;label class="sr-only" th:text="#&#123;login.username&#125;"&gt;Username&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="Username" th:placeholder="#&#123;login.username&#125;" required="" autofocus=""&gt; &lt;label class="sr-only" th:text="#&#123;login.password&#125;"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#&#123;login.password&#125;" required=""&gt; &lt;div class="checkbox mb-3"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#&#123;login.btn&#125;"&gt;Sign in&lt;/button&gt; &lt;p class="mt-5 mb-3 text-muted"&gt;© 2017-2018&lt;/p&gt; &lt;a class="btn btn-sm"&gt;中文&lt;/a&gt; &lt;a class="btn btn-sm"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = "spring.mvc", name = "locale") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter("l"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split("_"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style="color: red" th:text="$&#123;msg&#125;" th:if="$&#123;not #strings.isEmpty(msg)&#125;"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute("msg","没有权限请先登陆"); request.getRequestDispatcher("/index.html").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); registry.addViewController("/main.html").setViewName("dashboard"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**") .excludePathPatterns("/index.html","/","/user/login"); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"&gt; &lt;div class="sidebar-sticky"&gt; &lt;ul class="nav flex-column"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" th:class="$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;" href="#" th:href="@&#123;/main.html&#125;"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"&gt; &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"&gt;&lt;/path&gt; &lt;polyline points="9 22 9 12 15 12 15 22"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class="sr-only"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace="commons/bar::#sidebar(activeUri='emps')"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type="email" class="form-control" placeholder="zhangsan@atguigu.com"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action="@&#123;/emp&#125;" method="post"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name="_method";值就是我们指定的请求方式--&gt; &lt;input type="hidden" name="_method" value="put" th:if="$&#123;emp!=null&#125;"/&gt; &lt;input type="hidden" name="id" th:if="$&#123;emp!=null&#125;" th:value="$&#123;emp.id&#125;"&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="$&#123;emp!=null&#125;?$&#123;emp.email&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class="form-control" name="department.id"&gt; &lt;option th:selected="$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;" th:value="$&#123;dept.id&#125;" th:each="dept:$&#123;depts&#125;" th:text="$&#123;dept.departmentName&#125;"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" th:text="$&#123;emp!=null&#125;?'修改':'添加'"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each="emp:$&#123;emps&#125;"&gt; &lt;td th:text="$&#123;emp.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text="$&#123;emp.email&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.gender&#125;==0?'女':'男'"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.departmentName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-sm btn-primary" th:href="@&#123;/emp/&#125;+$&#123;emp.id&#125;"&gt;编辑&lt;/a&gt; &lt;button th:attr="del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;" class="btn btn-sm btn-danger deleteBtn"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(".deleteBtn").click(function()&#123; //删除当前员工的 $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put("timestamp", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value("$&#123;error.path:/error&#125;")private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = "error/" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code","user.notexist"); map.put("message",e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute("javax.servlet.error.status_code"); */ request.setAttribute("javax.servlet.error.status_code",500); map.put("code","user.notexist"); map.put("message",e.getMessage()); //转发到/error return "forward:/error"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put("company","atguigu"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir("tomcat")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the " + "configure method or add an @Configuration annotation"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql "docker-entrypoint.sh" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql "docker-entrypoint.sh" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql "docker-entrypoint.sh" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = "spring.datasource.type")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125; 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select("select * from department where id=#&#123;id&#125;") public Department getDeptById(Integer id); @Delete("delete from department where id=#&#123;id&#125;") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = "id") @Insert("insert into department(departmentName) values(#&#123;departmentName&#125;)") public int insertDept(Department department); @Update("update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;") public int updateDept(Department department);&#125; 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = "com.atguigu.springboot.mapper")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = "last_name",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println("ApplicationContextInitializer...initialize..."+applicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println("SpringApplicationRunListener...starting..."); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get("os.name"); System.out.println("SpringApplicationRunListener...environmentPrepared.."+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextPrepared..."); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextLoaded..."); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println("SpringApplicationRunListener...finished..."); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println("ApplicationRunner...run...."); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println("CommandLineRunner...run..."+ Arrays.asList(args)); &#125;&#125; 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = "atguigu.hello")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 123456789101112131415161718package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+"-" +name + helloProperties.getSuffix(); &#125;&#125; 12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
