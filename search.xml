<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F12%2F10%2Fjava%E5%9F%BA%E7%A1%80%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031public class ClassDemo1 &#123; public static void main(String[] args) &#123; // Foo的实例对象如何表示 Foo foo1 = new Foo();// foo1就表示出来了 // Foo 这个类 也是个实例对象 ，Class类的实列对象 如何表示呢 // 任何一个类都是Class的实列对象 这个实列对象有三种表示方式 /** * c1 c2表示了Foo类的类类型（class type） * 万事万物皆对象 * 类也是对象 是Class类的实列对象 * 这个对象我们称为该类的lei lei */ // 第一种表示方式---&gt;实际在告诉我们任何一个类都以一个隐含的静态成员 Class c1=Foo.class; // 第二种表示方式--&gt;已经知道该类的对象通过getClass方法 Class c2 = foo1.getClass(); //第三种方式 Class c3=Class.forName("com.package.Foo") &#125; // 我们完全可以通过类类型创建该类的对象实列 // --&gt;通过c1 or c2 创建Foo的实例 Foo foo = (Foo) c1.newInstance();foo.print(); class Foo &#123; void print() &#123; &#125; &#125;&#125; 123456789101112131415161718package com.imooc.reflect;public class ClassDemo2 &#123; public static void main(String[] args) &#123; Class c1 = int.class;//int 的类类型 Class c2 = String.class;//String类的类类型 String类字节码（自己发明的) Class c3 = double.class; Class c4 = Double.class; Class c5 = void.class; System.out.println(c1.getName()); System.out.println(c2.getName()); System.out.println(c2.getSimpleName());//不包含包名的类的名称 System.out.println(c5.getName()); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.imooc.reflect;public class ClassDemo1 &#123; public static void main(String[] args) &#123; //Foo的实例对象如何表示 Foo foo1 = new Foo();//foo1就表示出来了. //Foo这个类 也是一个实例对象，Class类的实例对象,如何表示呢 //任何一个类都是Class的实例对象，这个实例对象有三种表示方式 //第一种表示方式---&gt;实际在告诉我们任何一个类都有一个隐含的静态成员变量class Class c1 = Foo.class; //第二中表达方式 已经知道该类的对象通过getClass方法 Class c2 = foo1.getClass(); /*官网 c1 ,c2 表示了Foo类的类类型(class type) * 万事万物皆对象， * 类也是对象，是Class类的实例对象 * 这个对象我们称为该类的类类型 * */ //不管c1 or c2都代表了Foo类的类类型，一个类只可能是Class类的一个实例对象 System.out.println(c1 == c2); //第三种表达方式 Class c3 = null; try &#123; c3 = Class.forName("com.imooc.reflect.Foo"); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(c2==c3); //我们完全可以通过类的类类型创建该类的对象实例----&gt;通过c1 or c2 or c3创建Foo的实例对象 try &#123; Foo foo = (Foo)c1.newInstance();//需要有无参数的构造方法 foo.print(); &#125; catch (InstantiationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;class Foo&#123; void print()&#123; System.out.println("foo"); &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.imooc.reflect;import java.lang.reflect.Method;public class BeanUtil &#123; /** * 根据标准javaBean对象的属性名获取其属性值 * * @param obj * @param propertyName * @return */ public static Object getValueByPropertyName(Object obj, String propertyName) &#123; // 1.根据属性名称就可以获取其get方法 String getMethodName = "get" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1); //2.获取方法对象 Class c = obj.getClass(); try &#123; //get方法都是public的且无参数 Method m= c.getMethod(getMethodName); //3 通过方法的反射操作方法 Object value = m.invoke(obj); return value; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.imooc.reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ClassUtil &#123; /** * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数) * @param obj 该对象所属类的信息 */ public static void printClassMethodMessage(Object obj)&#123; //要获取类的信息 首先要获取类的类类型 Class c = obj.getClass();//传递的是哪个子类的对象 c就是该子类的类类型 //获取类的名称 System.out.println("类的名称是:"+c.getName()); /* * Method类，方法对象 * 一个成员方法就是一个Method对象 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限 */ Method[] ms = c.getMethods();//c.getDeclaredMethods() for(int i = 0; i &lt; ms.length;i++)&#123; //得到方法的返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName()+" "); //得到方法的名称 System.out.print(ms[i].getName()+"("); //获取参数类型---&gt;得到的是参数列表的类型的类类型 Class[] paramTypes = ms[i].getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125; /** * 获取成员变量的信息 * @param obj */ public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); /* * 成员变量也是对象 * java.lang.reflect.Field * Field类封装了关于成员变量的操作 * getFields()方法获取的是所有的public的成员变量的信息 * getDeclaredFields获取的是该类自己声明的成员变量的信息 */ //Field[] fs = c.getFields(); Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; //得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName+" "+fieldName); &#125; &#125; /** * 打印对象的构造函数的信息 * @param obj */ public static void printConMessage(Object obj)&#123; Class c = obj.getClass(); /* * 构造函数也是对象 * java.lang. Constructor中封装了构造函数的信息 * getConstructors获取所有的public的构造函数 * getDeclaredConstructors得到所有的构造函数 */ //Constructor[] cs = c.getConstructors(); Constructor[] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName()+"("); //获取构造函数的参数列表---&gt;得到的是参数列表的类类型 Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker war]]></title>
    <url>%2F2018%2F12%2F09%2FDocker%20war%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Docker 打包 War镜像]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F09%2F%E4%B8%87%E5%92%8C%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/int93/article/details/78811801/ python 参考网址 讲文件放到IDE 里面 看视频 tesseract]]></content>
  </entry>
  <entry>
    <title><![CDATA[macwindows文件传输]]></title>
    <url>%2F2018%2F12%2F08%2Fmacwindows%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[文件传输12345678910111213141516171819202122232425262728import cv2 as cvimport pytesseract as tessfrom PIL import Imagedef recognize_text(): gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY) ret, binary = cv.threshold(gray, 0, 255, cv.THRESH_BINARY_INV | cv.THRESH_OTSU) kernel = cv.getStructuringElement(cv.MORPH_RECT, (1, 2)) bin1 = cv.morphologyEx(binary, cv.MORPH_OPEN, kernel) kernel = cv.getStructuringElement(cv.MORPH_RECT, (2, 1)) open_out = cv.morphologyEx(bin1, cv.MORPH_OPEN, kernel) cv.imshow("binary-image", open_out) cv.bitwise_not(open_out, open_out) textImage = Image.fromarray(open_out) text = tess.image_to_string(textImage) print("识别结果: %s"%text)print("--------- Python OpenCV Tutorial ---------")src = cv.imread("/Users/apple/Desktop/1.png")cv.namedWindow("input image", cv.WINDOW_AUTOSIZE)cv.imshow("input image", src)recognize_text()cv.waitKey(0)cv.destroyAllWindows() http://pythonware.com/products/pil/ https://pypi.python.org/pypi/pytesseract]]></content>
      <tags>
        <tag>文件传输</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 Rabbit MQ 老师源代码]]></title>
    <url>%2F2018%2F12%2F05%2FRabbitMQ%2Fquickstart%2F</url>
    <content type="text"><![CDATA[慕课网 Rabbit MQ 老师源代码12345678910111213141516171819202122232425262728public class Procuder &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 通过Channel发送数据 for(int i=0; i &lt; 5; i++)&#123; String msg = &quot;Hello RabbitMQ!&quot;; //1 exchange 2 routingKey channel.basicPublish(&quot;&quot;, &quot;test001&quot;, null, msg.getBytes()); &#125; //5 记得要关闭相关的连接 channel.close(); connection.close(); &#125;&#125; quickstart12345678910111213141516171819202122232425262728293031package com.example.rabbitmq.start;import org.springframework.boot.SpringApplication;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class Procuder &#123; // 生产端Procuder http://94.191.24.33:15672/#/ public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;94.191.24.33&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); // 2.通过连接工厂创建连接connectionFactory.newConnection(); Connection connection = connectionFactory.newConnection(); // 3.通过connection创建一个Channel Channel channel = connection.createChannel(); // 4.通过Channel发送数据 String msg = &quot;Hello RabbitMQ&quot;; // channel.basicPublish(exchange, routingKey, props, body); channel.basicPublish(&quot;&quot;, &quot;test001&quot;, null, msg.getBytes()); channel.close(); connection.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.rabbitmq.start;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import com.rabbitmq.client.QueueingConsumer;import com.rabbitmq.client.QueueingConsumer.Delivery;public class Consumer &#123; @SuppressWarnings(&quot;deprecation&quot;) public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory，并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;94.191.24.33&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); // 2.通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); // 3 通过连接工厂创建连接 Channel channel = connection.createChannel(); // 4.申明（创建）一个队列 String queueName = &quot;test001&quot;; // channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments) channel.queueDeclare(&quot;test001&quot;, true, false, false, null); // 5.创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); /** * 6.设置channel # channel.basicConsume(queue,autoAck, autoAck) # 1：queue：队列的名字 * 2.autoAck：是否自动签收 3:autoAck：具体的消费者对象 */ channel.basicConsume(queueName, true, queueingConsumer); // 7.获取消息 while (true) &#123; Delivery delivery = queueingConsumer.nextDelivery(); byte[] body = delivery.getBody(); String msg = new String(delivery.getBody());// 获取消息 System.out.println(&quot;消费端&quot; + msg); &#125; &#125;&#125;//String string =new String(delivery.getBody()); 12345678910111213141516171819202122232425262728293031323334353637public class Consumer &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 声明（创建）一个队列 String queueName = &quot;test001&quot;; channel.queueDeclare(queueName, true, false, false, null); //5 创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); //6 设置Channel channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; //7 获取消息 Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费端: &quot; + msg); //Envelope envelope = delivery.getEnvelope(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829public class Procuder &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 通过Channel发送数据 for(int i=0; i &lt; 5; i++)&#123; String msg = &quot;Hello RabbitMQ!&quot;; //1 exchange 2 routingKey channel.basicPublish(&quot;&quot;, &quot;test001&quot;, null, msg.getBytes()); &#125; //5 记得要关闭相关的连接 channel.close(); connection.close(); &#125;&#125; apiack1234567891011121314151617181920212223242526272829public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_ack_exchange&quot;; String queueName = &quot;test_ack_queue&quot;; String routingKey = &quot;ack.#&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); // 手工签收 必须要关闭 autoAck = false channel.basicConsume(queueName, false, new MyConsumer(channel)); &#125;&#125; 1234567891011121314151617181920212223242526272829public class MyConsumer extends DefaultConsumer &#123; private Channel channel ; public MyConsumer(Channel channel) &#123; super(channel); this.channel = channel; &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;body: &quot; + new String(body)); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if((Integer)properties.getHeaders().get(&quot;num&quot;) == 0) &#123; channel.basicNack(envelope.getDeliveryTag(), false, true); &#125; else &#123; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_ack_exchange&quot;; String routingKey = &quot;ack.save&quot;; for(int i =0; i&lt;5; i ++)&#123; Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;(); headers.put(&quot;num&quot;, i); AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .deliveryMode(2) .contentEncoding(&quot;UTF-8&quot;) .headers(headers) .build(); String msg = &quot;Hello RabbitMQ ACK Message &quot; + i; channel.basicPublish(exchange, routingKey, true, properties, msg.getBytes()); &#125; &#125;&#125; confirm1234567891011121314151617181920212223242526272829303132333435363738public class Consumer &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 获取C onnection Connection connection = connectionFactory.newConnection(); //3 通过Connection创建一个新的Channel Channel channel = connection.createChannel(); String exchangeName = &quot;test_confirm_exchange&quot;; String routingKey = &quot;confirm.#&quot;; String queueName = &quot;test_confirm_queue&quot;; //4 声明交换机和队列 然后进行绑定设置, 最后制定路由Key channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); //5 创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费端: &quot; + msg); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Producer &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 获取C onnection Connection connection = connectionFactory.newConnection(); //3 通过Connection创建一个新的Channel Channel channel = connection.createChannel(); //4 指定我们的消息投递模式: 消息的确认模式 channel.confirmSelect(); String exchangeName = &quot;test_confirm_exchange&quot;; String routingKey = &quot;confirm.save&quot;; //5 发送一条消息 String msg = &quot;Hello RabbitMQ Send confirm message!&quot;; channel.basicPublish(exchangeName, routingKey, null, msg.getBytes()); //6 添加一个确认监听 channel.addConfirmListener(new ConfirmListener() &#123; @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException &#123; System.err.println(&quot;-------no ack!-----------&quot;); &#125; @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException &#123; System.err.println(&quot;-------ack!-----------&quot;); &#125; &#125;); &#125;&#125; Consumer123456789101112131415161718192021222324252627public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_consumer_exchange&quot;; String routingKey = &quot;consumer.#&quot;; String queueName = &quot;test_consumer_queue&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); channel.basicConsume(queueName, true, new MyConsumer(channel)); &#125;&#125; 123456789101112131415161718public class MyConsumer extends DefaultConsumer &#123; public MyConsumer(Channel channel) &#123; super(channel); &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;consumerTag: &quot; + consumerTag); System.err.println(&quot;envelope: &quot; + envelope); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); &#125;&#125; 12345678910111213141516171819202122232425public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_consumer_exchange&quot;; String routingKey = &quot;consumer.save&quot;; String msg = &quot;Hello RabbitMQ Consumer Message&quot;; for(int i =0; i&lt;5; i ++)&#123; channel.basicPublish(exchange, routingKey, true, null, msg.getBytes()); &#125; &#125;&#125; dlx12345678910111213141516171819202122232425262728293031323334353637public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); // 这就是一个普通的交换机 和 队列 以及路由 String exchangeName = &quot;test_dlx_exchange&quot;; String routingKey = &quot;dlx.#&quot;; String queueName = &quot;test_dlx_queue&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); Map&lt;String, Object&gt; agruments = new HashMap&lt;String, Object&gt;(); agruments.put(&quot;x-dead-letter-exchange&quot;, &quot;dlx.exchange&quot;); //这个agruments属性，要设置到声明队列上 channel.queueDeclare(queueName, true, false, false, agruments); channel.queueBind(queueName, exchangeName, routingKey); //要进行死信队列的声明: channel.exchangeDeclare(&quot;dlx.exchange&quot;, &quot;topic&quot;, true, false, null); channel.queueDeclare(&quot;dlx.queue&quot;, true, false, false, null); channel.queueBind(&quot;dlx.queue&quot;, &quot;dlx.exchange&quot;, &quot;#&quot;); channel.basicConsume(queueName, true, new MyConsumer(channel)); &#125;&#125; 123456789101112131415public class MyConsumer extends DefaultConsumer &#123; public MyConsumer(Channel channel) &#123; super(channel); &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;consumerTag: &quot; + consumerTag); System.err.println(&quot;envelope: &quot; + envelope); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); &#125; 123456789101112131415161718192021222324252627282930public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_dlx_exchange&quot;; String routingKey = &quot;dlx.save&quot;; String msg = &quot;Hello RabbitMQ DLX Message&quot;; for(int i =0; i&lt;1; i ++)&#123; AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .deliveryMode(2) .contentEncoding(&quot;UTF-8&quot;) .expiration(&quot;10000&quot;) .build(); channel.basicPublish(exchange, routingKey, true, properties, msg.getBytes()); &#125; &#125;&#125; exchange–direct123456789101112131415161718192021222324252627282930313233343536373839404142public class Consumer4DirectExchange &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory() ; connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); connectionFactory.setAutomaticRecoveryEnabled(true); connectionFactory.setNetworkRecoveryInterval(3000); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_direct_exchange&quot;; String exchangeType = &quot;direct&quot;; String queueName = &quot;test_direct_queue&quot;; String routingKey = &quot;test.direct&quot;; //表示声明了一个交换机 channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null); //表示声明了一个队列 channel.queueDeclare(queueName, false, false, false, null); //建立一个绑定关系: channel.queueBind(queueName, exchangeName, routingKey); //durable 是否持久化消息 QueueingConsumer consumer = new QueueingConsumer(channel); //参数：队列名称、是否自动ACK、Consumer channel.basicConsume(queueName, true, consumer); //循环获取消息 while(true)&#123; //获取消息，如果没有消息，这一步将会一直阻塞 Delivery delivery = consumer.nextDelivery(); String msg = new String(delivery.getBody()); System.out.println(&quot;收到消息：&quot; + msg); &#125; &#125;&#125; 1234567891011121314151617181920212223242526public class Producer4DirectExchange &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 创建Connection Connection connection = connectionFactory.newConnection(); //3 创建Channel Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_direct_exchange&quot;; String routingKey = &quot;test.direct111&quot;; //5 发送 String msg = &quot;Hello World RabbitMQ 4 Direct Exchange Message 111 ... &quot;; channel.basicPublish(exchangeName, routingKey , null , msg.getBytes()); &#125; &#125; Exchange-fanout12345678910111213141516171819202122232425262728293031323334353637public class Consumer4FanoutExchange &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory() ; connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); connectionFactory.setAutomaticRecoveryEnabled(true); connectionFactory.setNetworkRecoveryInterval(3000); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_fanout_exchange&quot;; String exchangeType = &quot;fanout&quot;; String queueName = &quot;test_fanout_queue&quot;; String routingKey = &quot;&quot;; //不设置路由键 channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null); channel.queueDeclare(queueName, false, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); //durable 是否持久化消息 QueueingConsumer consumer = new QueueingConsumer(channel); //参数：队列名称、是否自动ACK、Consumer channel.basicConsume(queueName, true, consumer); //循环获取消息 while(true)&#123; //获取消息，如果没有消息，这一步将会一直阻塞 Delivery delivery = consumer.nextDelivery(); String msg = new String(delivery.getBody()); System.out.println(&quot;收到消息：&quot; + msg); &#125; &#125;&#125; 123456789101112131415161718192021222324252627public class Producer4FanoutExchange &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 创建Connection Connection connection = connectionFactory.newConnection(); //3 创建Channel Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_fanout_exchange&quot;; //5 发送 for(int i = 0; i &lt; 10; i ++) &#123; String msg = &quot;Hello World RabbitMQ 4 FANOUT Exchange Message ...&quot;; channel.basicPublish(exchangeName, &quot;&quot;, null , msg.getBytes()); &#125; channel.close(); connection.close(); &#125; &#125; Exchange -topic123456789101112131415161718192021222324252627282930313233343536373839404142public class Consumer4TopicExchange &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory() ; connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); connectionFactory.setAutomaticRecoveryEnabled(true); connectionFactory.setNetworkRecoveryInterval(3000); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_topic_exchange&quot;; String exchangeType = &quot;topic&quot;; String queueName = &quot;test_topic_queue&quot;; //String routingKey = &quot;user.*&quot;; String routingKey = &quot;user.*&quot;; // 1 声明交换机 channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null); // 2 声明队列 channel.queueDeclare(queueName, false, false, false, null); // 3 建立交换机和队列的绑定关系: channel.queueBind(queueName, exchangeName, routingKey); //durable 是否持久化消息 QueueingConsumer consumer = new QueueingConsumer(channel); //参数：队列名称、是否自动ACK、Consumer channel.basicConsume(queueName, true, consumer); //循环获取消息 while(true)&#123; //获取消息，如果没有消息，这一步将会一直阻塞 Delivery delivery = consumer.nextDelivery(); String msg = new String(delivery.getBody()); System.out.println(&quot;收到消息：&quot; + msg); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031public class Producer4TopicExchange &#123; public static void main(String[] args) throws Exception &#123; //1 创建ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 创建Connection Connection connection = connectionFactory.newConnection(); //3 创建Channel Channel channel = connection.createChannel(); //4 声明 String exchangeName = &quot;test_topic_exchange&quot;; String routingKey1 = &quot;user.save&quot;; String routingKey2 = &quot;user.update&quot;; String routingKey3 = &quot;user.delete.abc&quot;; //5 发送 String msg = &quot;Hello World RabbitMQ 4 Topic Exchange Message ...&quot;; channel.basicPublish(exchangeName, routingKey1 , null , msg.getBytes()); channel.basicPublish(exchangeName, routingKey2 , null , msg.getBytes()); channel.basicPublish(exchangeName, routingKey3 , null , msg.getBytes()); channel.close(); connection.close(); &#125; &#125; limit1234567891011121314151617181920212223242526272829303132public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_qos_exchange&quot;; String queueName = &quot;test_qos_queue&quot;; String routingKey = &quot;qos.#&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); //1 限流方式 第一件事就是 autoAck设置为 false channel.basicQos(0, 1, false); channel.basicConsume(queueName, false, new MyConsumer(channel)); &#125;&#125; 123456789101112131415161718192021222324public class MyConsumer extends DefaultConsumer &#123; private Channel channel ; public MyConsumer(Channel channel) &#123; super(channel); this.channel = channel; &#125; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;-----------consume message----------&quot;); System.err.println(&quot;consumerTag: &quot; + consumerTag); System.err.println(&quot;envelope: &quot; + envelope); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125;&#125; 123456789101112131415161718192021222324public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_qos_exchange&quot;; String routingKey = &quot;qos.save&quot;; String msg = &quot;Hello RabbitMQ QOS Message&quot;; for(int i =0; i&lt;5; i ++)&#123; channel.basicPublish(exchange, routingKey, true, null, msg.getBytes()); &#125; &#125;&#125; message123456789101112131415161718192021222324252627282930313233343536373839public class Consumer &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); //4 声明（创建）一个队列 String queueName = &quot;test001&quot;; channel.queueDeclare(queueName, true, false, false, null); //5 创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); //6 设置Channel channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; //7 获取消息 Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费端: &quot; + msg); Map&lt;String, Object&gt; headers = delivery.getProperties().getHeaders(); System.err.println(&quot;headers get my1 value: &quot; + headers.get(&quot;my1&quot;)); //Envelope envelope = delivery.getEnvelope(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940public class Procuder &#123; public static void main(String[] args) throws Exception &#123; //1 创建一个ConnectionFactory, 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); //2 通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3 通过connection创建一个Channel Channel channel = connection.createChannel(); Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;(); headers.put(&quot;my1&quot;, &quot;111&quot;); headers.put(&quot;my2&quot;, &quot;222&quot;); AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() .deliveryMode(2) .contentEncoding(&quot;UTF-8&quot;) .expiration(&quot;10000&quot;) .headers(headers) .build(); //4 通过Channel发送数据 for(int i=0; i &lt; 5; i++)&#123; String msg = &quot;Hello RabbitMQ!&quot;; //1 exchange 2 routingKey channel.basicPublish(&quot;&quot;, &quot;test001&quot;, properties, msg.getBytes()); &#125; //5 记得要关闭相关的连接 channel.close(); connection.close(); &#125;&#125; returnlistener12345678910111213141516171819202122232425262728293031323334public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchangeName = &quot;test_return_exchange&quot;; String routingKey = &quot;return.#&quot;; String queueName = &quot;test_return_queue&quot;; channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null); channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, exchangeName, routingKey); QueueingConsumer queueingConsumer = new QueueingConsumer(channel); channel.basicConsume(queueName, true, queueingConsumer); while(true)&#123; Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.err.println(&quot;消费者: &quot; + msg); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public class Producer &#123; public static void main(String[] args) throws Exception &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.11.76&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;/&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); String exchange = &quot;test_return_exchange&quot;; String routingKey = &quot;return.save&quot;; String routingKeyError = &quot;abc.save&quot;; String msg = &quot;Hello RabbitMQ Return Message&quot;; channel.addReturnListener(new ReturnListener() &#123; @Override public void handleReturn(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;---------handle return----------&quot;); System.err.println(&quot;replyCode: &quot; + replyCode); System.err.println(&quot;replyText: &quot; + replyText); System.err.println(&quot;exchange: &quot; + exchange); System.err.println(&quot;routingKey: &quot; + routingKey); System.err.println(&quot;properties: &quot; + properties); System.err.println(&quot;body: &quot; + new String(body)); &#125; &#125;); channel.basicPublish(exchange, routingKeyError, true, null, msg.getBytes()); //channel.basicPublish(exchange, routingKeyError, true, null, msg.getBytes());&#125;&#125;]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[千峰RabbitMQ 老师源代码]]></title>
    <url>%2F2018%2F12%2F05%2FRabbitMQ%2F%E5%8D%83%E5%B3%B0%20Rabbit%20MQ%20%E8%80%81%E5%B8%88%E6%BA%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[千峰 Rabbit MQ 老师源代码hello123456789101112131415161718192021public class Recver &#123; private final static String QUEUE = &quot;testhello&quot;;//队列的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE,false,false,false,null); QueueingConsumer consumer =new QueueingConsumer(channel);//定义一个消费者,QueueingConsumer已经过时,建议使用DefaultConsumer子类 //接收消息 ,参数2 是自动确认 channel.basicConsume(QUEUE, true, consumer); while (true) &#123; //获取消息 QueueingConsumer.Delivery delivery = consumer.nextDelivery();//如果没有消息会等待,有的话就获取执行然后销毁,是一次性的 String message = new String(delivery.getBody()); System.out.println(message); &#125; &#125;&#125; 123456789101112131415161718192021222324public class Sender &#123; private final static String QUEUE = &quot;testhello&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; //获取连接 Connection connection = ConnextionUtil.getConnection(); //创建通道 Channel channel = connection.createChannel(); //声明队列,如果队列存在则什么都不做,如果不存在才创建 // 参数1 队列的名字 //参数2 是否持久化队列,我们的队列模式是在内存中的,如果 rabbitmq 重启会丢失,如果我们设置为 true, 则会保存到 erlang 自带的数据库中,重启后会重新读取 //参数3 是否排外,有两个作用,第一个当我们的连接关闭后是否会自动删除队列,作用二 是否私有当天前队列,如果私有了,其他通道不可以访问当前队列,如果为 true, 一般是一个队列只适用于一个消费者的时候 //参数4 是够自动删除 //参数5 我们的一些其他参数 channel.queueDeclare(QUEUE, false, false, false, null); //发送内容 channel.basicPublish(&quot;&quot;,QUEUE,null,&quot;发送的消息&quot;.getBytes()); //关闭连接 channel.close(); connection.close(); &#125;&#125; persist1234567891011121314151617181920public class Recver &#123; private static String EXCHANGE_NAME = &quot;testpersist&quot;; private static String QUEUE_NAME = &quot;testpersistqueue&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;, true, false, null); //声明持久化的队列 channel.queueDeclare(QUEUE_NAME, true, false, false, null); channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,&quot;abc&quot;); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.err.println(&quot;收到消息:&quot;+new String(body)); &#125; &#125;; channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 12345678910111213141516public class Sender &#123; private static String EXCHANGE_NAME = &quot;testpersist&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); //声明持久化的交换机 channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;, true, false, null); //声明持久化消息 channel.basicPublish(EXCHANGE_NAME, &quot;abc&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, &quot;持久化的消息&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; publish123456789101112131415161718192021222324public class Recver1 &#123; private final static String EXCHANGE_NAME = &quot;testexchange&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testpubqueue1&quot;, false, false, false,null); //绑定队列到交换机 channel.queueBind(&quot;testpubqueue1&quot;, EXCHANGE_NAME, &quot;&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者11111111:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testpubqueue1&quot;, false, consumer); &#125;&#125; 1234567891011121314151617181920public class Recver2 &#123; private final static String EXCHANGE_NAME = &quot;testexchange&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testpubqueue2&quot;, false, false, false,null); //绑定队列到交换机 channel.queueBind(&quot;testpubqueue2&quot;, EXCHANGE_NAME, &quot;&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者2222222:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testpubqueue2&quot;, false, consumer); &#125;&#125; 1234567891011121314public class Sender &#123; private final static String EXCHANGE_NAME = &quot;testexchange&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);//定义一个交换机,类型是fanout,也就是发布订阅模式 //发布订阅模式的,因为消息是先发到交换机中,而交换机是没有保存功能的,所以如果没有消费者,消息会丢失 channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, &quot;发布订阅模式的消息&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; ##route 12345678910111213141516171819202122232425public class Recver1 &#123; private final static String EXCHANGE_NAME = &quot;testeoute&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testroutequeue1&quot;, false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 // 绑定队列到交换机,绑定自己的关键字 key 为key,注意在绑定到指定路由(交换机)的时候,该路由必须存在,也就是我们必须先由发送者创建一个路由才可以 channel.queueBind(&quot;testroutequeue1&quot;, EXCHANGE_NAME, &quot;key1&quot;); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind(&quot;testroutequeue1&quot;, EXCHANGE_NAME, &quot;key2&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者11111111:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testroutequeue1&quot;, false, consumer); &#125;&#125; 1234567891011121314151617181920212223public class Recver2 &#123; private final static String EXCHANGE_NAME = "testeoute";//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare("testroutequeue2", false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 channel.queueBind("testroutequeue2", EXCHANGE_NAME, "key1"); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind("testroutequeue2", EXCHANGE_NAME, "key3"); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println("消费者22222:"+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume("testroutequeue2", false, consumer); &#125;&#125; 123456789101112public class Sender &#123; private final static String EXCHANGE_NAME = &quot;testeoute&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);//定义路由格式的交换机 channel.basicPublish(EXCHANGE_NAME, &quot;key3&quot;, null, &quot;路由消息&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; ##spring 12345678910 */public class MyConsumer &#123; /** * 用于接收消息 * @param message */ public void test(String message) &#123; System.err.println(message); &#125;&#125; 12345678public class SpringTest &#123; public static void main(String[] args) throws Exception&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); RabbitTemplate template = context.getBean(RabbitTemplate.class); template.convertAndSend(&quot;spring 的消息&quot;); ((ClassPathXmlApplicationContext) context).destroy(); &#125;&#125; spring212345678@Component(&quot;confirmCallBackListener&quot;)public class ConfirmCallBackListener implements RabbitTemplate.ConfirmCallback &#123; @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; System.err.println(&quot;确认回调 ack==&quot;+ack+&quot; cause==&quot;+cause); &#125;&#125; 12345678910 @Component(&quot;publishUtil&quot;)public class PublishUtil &#123; @Autowired private AmqpTemplate amqpTemplate; public void send(String exchange, String routingkey, Object message) &#123; amqpTemplate.convertAndSend(exchange,routingkey,message ); &#125;&#125; 1234567891011121314151617181920@Component(&quot;receiveConfirmTestListener&quot;)public class ReceiveConfirmTestListener implements ChannelAwareMessageListener &#123; /** * 收到消息的时候执行的监听 * @param message * @param channel * @throws Exception */ @Override public void onMessage(Message message, Channel channel) throws Exception &#123; try &#123; System.err.println(&quot;消费者收到了消息&quot; + message); channel.basicAck(message.getMessageProperties().getDeliveryTag(),false); &#125;catch (Exception e)&#123; e.printStackTrace(); channel.basicAck(message.getMessageProperties().getDeliveryTag(),false); &#125; &#125;&#125; 12345678 @Component(&quot;returnCallBackListener&quot;)public class ReturnCallBackListener implements RabbitTemplate.ReturnCallback &#123; @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) &#123; System.err.println(&quot;失败 message==&quot;+new String(message.getBody())+&quot; replyCode==&quot;+replyCode+&quot; replyText&quot;+replyText+&quot; exchange&quot;+exchange+&quot; routingKey&quot;+routingKey); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext2.xml&quot;&#125;)public class TestMain &#123; @Autowired private PublishUtil publishUtil; private static String exChange = &quot;DIRECT_EX&quot;;//交换机 private static String queue = &quot;CONFIRM_TEST&quot;; /** * EXCHANGE QUEUE都对, confirm 会执行, ack=true * @throws Exception */ @Test public void test1() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange, queue, message); Thread.sleep(2000); &#125; /** * EXCHANGE错误 QUEUE对, confirm 会执行, ack=false * @throws Exception */ @Test public void test2() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange+&quot;!&quot;, queue, message); Thread.sleep(2000); &#125; /** * EXCHANGE对的 QUEUE错的,confirm 会执行 act=true, 失败会执行 * @throws Exception */ @Test public void test3() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange, queue+&quot;1&quot;, message); Thread.sleep(2000); &#125; /** * EXCHANGE QUEUE都是错的 confirm 会执行,但是ack=false * @throws Exception */ @Test public void test4() throws Exception&#123; String message = &quot;当前时间是:&quot; + System.currentTimeMillis(); publishUtil.send(exChange+&quot;`&quot;, queue+&quot;1&quot;, message); Thread.sleep(2000); &#125; topic123456789101112131415161718192021222324 public class Recver1 &#123; private final static String EXCHANGE_NAME = &quot;testtopic&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testtopicqueue1&quot;, false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 channel.queueBind(&quot;testtopicqueue1&quot;, EXCHANGE_NAME, &quot;key.*&quot;); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind(&quot;testtopicqueue1&quot;, EXCHANGE_NAME, &quot;abc.#&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者11111111:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testtopicqueue1&quot;, false, consumer); &#125;&#125; 1234567891011121314151617181920212223public class Recver2 &#123; private final static String EXCHANGE_NAME = &quot;testtopic&quot;;//定义交换机的名字 public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(&quot;testtopicqueue2&quot;, false, false, false,null); //绑定队列到交换机 //参数3 标记,绑定到交换机的时候会指定一个标记,只有和它一样的标记的消息才会被当前消费者收到 channel.queueBind(&quot;testtopicqueue2&quot;, EXCHANGE_NAME, &quot;key.#&quot;); //如果要接收多个标记,只需要再执行一次即可 channel.queueBind(&quot;testtopicqueue2&quot;, EXCHANGE_NAME, &quot;abc.#&quot;); channel.basicQos(1); DefaultConsumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;消费者22222:&quot;+new String(body)); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(&quot;testtopicqueue2&quot;, false, consumer); &#125;&#125; 1234567891011121314public class Sender &#123; private final static String EXCHANGE_NAME = &quot;testtopic&quot;; public static void main(String[] args) throws Exception&#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange,声明为 topic 也就是通配符类型 channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;); //发送 abc.1.2数据,凡是能匹配到这个关键词的都会收到 channel.basicPublish(EXCHANGE_NAME, &quot;abc.1.2&quot;, null, &quot;topic 模式消息111&quot;.getBytes()); channel.close(); connection.close(); &#125;&#125; util123456789101112 public class ConnextionUtil &#123; public static Connection getConnection () throws Exception&#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;192.168.3.233&quot;);//设置 server 的地址 connectionFactory.setPort(5672); connectionFactory.setUsername(&quot;test&quot;); connectionFactory.setPassword(&quot;test&quot;); connectionFactory.setVirtualHost(&quot;/test&quot;); return connectionFactory.newConnection();//创建一个新的连接 &#125;&#125; work12345678910111213141516171819202122232425262728293031public class Recver1 &#123; private final static String QUEUE = &quot;testwork&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE,false,false,false,null); // 同一时刻服务器只会发一条消息给消费者,只有当前消费者将消息处理完成后才会获取到下一条消息 //注释掉后可以获取多条消息,但是会一条一条处理 channel.basicQos(1);//告诉服务器,在我们没有确认当前消息完成之前,不要给我发新的消息 DefaultConsumer consumer =new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //当我们收到消息的时候调用 System.out.println(&quot;消费者1 收到的内容是:&quot;+new String(body)); //确认 try &#123; Thread.sleep(10);//模拟耗时 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false);//参数2,false 为确认收到消息, true 为拒接收到消息 &#125; &#125;; //注册消费者, 参数2 手动确认,代表我们收到消息后需要手动告诉服务器,我收到消息了 channel.basicConsume(QUEUE,false,consumer); &#125;&#125; 1234567891011121314151617181920212223242526272829public class Recver2 &#123; private final static String QUEUE = &quot;testwork&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; Connection connection = ConnextionUtil.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE,false,false,false,null); channel.basicQos(1);//告诉服务器,在我们没有确认当前消息完成之前,不要给我发新的消息 DefaultConsumer consumer =new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //当我们收到消息的时候调用 System.out.println(&quot;消费者2 收到的内容是:&quot;+new String(body)); try &#123; Thread.sleep(300);//模拟耗时 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //确认 channel.basicAck(envelope.getDeliveryTag(), false);//参数2,false 为确认收到消息, true 为拒接收到消息 &#125; &#125;; //注册消费者, 参数2 手动确认,代表我们收到消息后需要手动告诉服务器,我收到消息了 channel.basicConsume(QUEUE,false,consumer); &#125;&#125; 123456789101112131415161718192021222324252627 public class Sender &#123; private final static String QUEUE = &quot;testwork&quot;;//队列的名字 public static void main(String[] args) throws Exception &#123; //获取连接 Connection connection = ConnextionUtil.getConnection(); //创建通道 Channel channel = connection.createChannel(); //声明队列,如果队列存在则什么都不做,如果不存在才创建 // 参数1 队列的名字 //参数2 是否持久化队列,我们的队列模式是在内存中的,如果 rabbitmq 重启会丢失,如果我们设置为 true, 则会保存到 erlang 自带的数据库中,重启后会重新读取 //参数3 是否排外,有两个作用,第一个当我们的连接关闭后是否会自动删除队列,作用二 是否私有当天前队列,如果私有了,其他通道不可以访问当前队列,如果为 true, 一般是一个队列只适用于一个消费者的时候 //参数4 是够自动删除 //参数5 我们的一些其他参数 channel.queueDeclare(QUEUE, false, false, false, null); for (int i = 0; i &lt; 100; i++) &#123; //发送内容 channel.basicPublish(&quot;&quot;,QUEUE,null,(&quot;发送的消息&quot;+i).getBytes()); &#125; //关闭连接 channel.close(); connection.close(); &#125;&#125; resourceapplication.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xsi:schemaLocation="http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.7.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"&gt; &lt;!--1 定义连接工厂--&gt; &lt;rabbit:connection-factory id="connectionFactory" host="192.168.3.233" port="5672" username="test" password="test" virtual-host="/test"/&gt; &lt;!--消息是发送到交换机还是队列--&gt; &lt;!--定义 rabbitmq 的模板 queue="" 如果发送到队列则写队列 exchange="" 如果发送到交换机则写交换机 routing-key="" 定义路由的关键字 --&gt; &lt;rabbit:template id="template" connection-factory="connectionFactory" exchange="fanoutExchange" /&gt; &lt;rabbit:admin connection-factory="connectionFactory"/&gt; &lt;!--定义队列--&gt; &lt;rabbit:queue name="myQueue" auto-declare="true"/&gt; &lt;!--定义交换机--&gt; &lt;rabbit:fanout-exchange name="fanoutExchange" auto-declare="true"&gt; &lt;!--将队列绑定到交换机--&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="myQueue"&gt; &lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:fanout-exchange&gt;&lt;!--定义监听容易,当收到消息的时候会执行内部的配置--&gt; &lt;rabbit:listener-container connection-factory="connectionFactory"&gt;&lt;!--定义到底哪个类里面的什么方法用于处理收到的消息--&gt; &lt;rabbit:listener ref="consumer" method="test" queue-names="myQueue"/&gt; &lt;/rabbit:listener-container&gt; &lt;!--定义消费者--&gt; &lt;bean id="consumer" class="com.qianfeng.spring.MyConsumer"/&gt;&lt;!-- &lt;rabbit:direct-exchange name="directExchange" durable="true" auto-delete="false"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="myQueue" key="key1"&gt; &lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:direct-exchange&gt;--&gt; &lt;!-- &lt;rabbit:topic-exchange name="topicExchange" durable="true" auto-delete="false"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding pattern="dfasfsd.*" queue="myQueue"/&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:topic-exchange&gt;--&gt;&lt;/beans&gt; application2.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.7.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;context:component-scan base-package="com.qianfeng"/&gt; &lt;bean id="jsonMessageConverter" class="org.springframework.amqp.support.converter.Jackson2JsonMessageConverter" /&gt; &lt;!-- 􏰽􏰾RabbitMQ􏰙􏰆􏰇􏴜􏴡 publisher-confirms 􏰒􏵠􏱈􏱉, publisher-confirms 为 true的情况下 确认失败等回调才会执行 􏵡􏳚􏰀􏰔􏵈􏵉--&gt; &lt;rabbit:connection-factory id="connectionFactory" host="192.168.3.233" port="5672" username="test" password="test" virtual-host="/test" publisher-confirms="true" /&gt; &lt;rabbit:admin connection-factory="connectionFactory" /&gt; &lt;!-- 􏰬􏱊􏵞􏱯􏰽􏵢􏴿􏰩 --&gt;&lt;!-- mandatory􏳅􏳆􏲬􏳿true,return callback􏰶􏴟􏵣 --&gt; &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" confirm-callback="confirmCallBackListener" return-callback="returnCallBackListener" mandatory="true"/&gt; &lt;rabbit:queue name="CONFIRM_TEST" /&gt; &lt;rabbit:direct-exchange name="DIRECT_EX" id="DIRECT_EX" &gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="CONFIRM_TEST" /&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:direct-exchange&gt; &lt;!-- 􏴁􏳿consumer, 􏰿􏱀􏰙􏴛􏲇queue􏰙􏱚􏱖􏳲􏲘 --&gt; &lt;rabbit:listener-container connection-factory="connectionFactory" acknowledge="manual" &gt; &lt;rabbit:listener queues="CONFIRM_TEST" ref="receiveConfirmTestListener" /&gt;&lt;/rabbit:listener-container&gt;&lt;/beans&gt; 1234567log4j.rootLogger=DEBUG,A1log4j.logger.com.taotao = DEBUGlog4j.logger.org.mybatis = DEBUGlog4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c]-[%p] %m%n]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消费生产与消费]]></title>
    <url>%2F2018%2F12%2F05%2FRabbitMQ%2F4%E6%B6%88%E8%B4%B9%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9%2F</url>
    <content type="text"><![CDATA[1.加入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;scope&gt;3.6.5&lt;/scope&gt; &lt;/dependency&gt; 2.编码实战2.1Productor12345678910111213141516171819202122public class Procuder &#123; // 生产端Procuder http://94.191.24.33:15672/#/ public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory 并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost("94.191.24.33"); connectionFactory.setPort(15672); connectionFactory.setVirtualHost("/"); // 2.通过连接工厂创建连接connectionFactory.newConnection(); Connection connection = connectionFactory.newConnection(); // 3.通过connection创建一个Channel Channel channel = connection.createChannel(); // 4.通过Channel发送数据 String msg = "Hello RabbitMQ"; //channel.basicPublish(exchange, routingKey, props, body); channel.basicPublish("", "test001", null, msg.getBytes()); channel.close(); connection.close(); &#125; 2.2.Consumer12345678910111213141516171819202122232425262728293031323334353637public class Consumer &#123; public static void main(String[] args) throws Exception &#123; // 1.创建一个ConnectionFactory，并进行配置 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost("94.191.24.33"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost("/"); // 2.通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); // 3 通过连接工厂创建连接 Channel channel = connection.createChannel(); // 4.申明（创建）一个队列 String queueName = "test001"; // channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments) channel.queueDeclare("test001", true, false, false, null); // 5.创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); /** * 6.设置channel # channel.basicConsume(queue,autoAck, autoAck) # 1：queue：队列的名字 * 2.autoAck：是否自动签收 3:autoAck：具体的消费者对象 */ channel.basicConsume(queueName, true, queueingConsumer); //7.获取消息 while (true) &#123; Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody());// 获取消息 System.out.println("消费端" + msg); &#125; &#125;&#125; 2.3 启动程序看管控台 2.4 方法的API3.一些基础]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8实战]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2Fjava8%E5%AE%9E%E6%88%98%20%E6%B1%AA%E6%96%87%E5%90%9B%2F</url>
    <content type="text"></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2Fjava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%B1%AA%E6%96%87%E5%90%9Bbibil%2F</url>
    <content type="text"></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java引用传递]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[基本数据类型（show（）方法出栈 栈里面只有成员变量）123456789101112package 引用传递;//基本数据类型参数传递public class Demo &#123; public static void main(String[] args) &#123; int x = 3; show(x);//⭐️x=3 show（）方法出栈 栈里面只有3 System.out.println("x=" + x); &#125; public static void show(int x) &#123; x = 4; &#125;&#125; 123456789101112package 引用传递;//基本数据类型参数传递public class Demo &#123; public static void main(String[] args) &#123; int x = 3; show(x);// 答案x=4 执行的是show 里面的方法 &#125; public static void show(int x) &#123; x = 4; System.out.println("x=" + x); &#125;&#125; 引用数据类型参数传递 1234567891011121314package 引用传递;//引用数据类型public class Demo2 &#123; int x = 3; public static void main(String[] args) &#123; Demo2 demo2 = new Demo2(); demo2.x=9; show(demo2);// ⭐️ x=4 System.out.println(demo2.x); &#125; public static void show(Demo2 d) &#123; d.x = 4; &#125;&#125; 总结 引用数据类型传递详解 栈内存：保存所有的对象名称 d(保存了引用堆内存空间的地址） 堆内存空间。保存具体对象的具体属性 全局数据区：保存static类型的属性 全局代码区：保存所有的方法定义 java的引用传递 同一块堆内存空间，同时被多个栈内存指向，不同的栈可以修改同一块堆内存空间的地址 123456789101112131415161718192021222324252627282930313233package 引用传递;class Demo1 &#123; private int data = 10; public Demo1() &#123; &#125; public Demo1(int data) &#123; this.data = data; &#125; public int getData() &#123; return this.data; &#125; public void setData(int data) &#123; this.data = data; &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; Demo1 demo1 = new Demo1(); fun(demo1);// System.out.println(demo1.getData());//30 &#125; public static void fun(Demo1 temp) &#123; // 接受引用 temp.setData(30);// 修改属性内容 &#125;&#125; https://blog.csdn.net/lym152898/article/details/54411956]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ管控台]]></title>
    <url>%2F2018%2F12%2F04%2FRabbitMQ%2F3.%E7%AE%A1%E6%8E%A7%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[不积跬步 无以至千里 养成写博客理解的习惯#博客在学习的时候写 看最好的视频 写做好的博客 cheerUP]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbit MQ命令总结]]></title>
    <url>%2F2018%2F12%2F04%2FRabbit%20MQ%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[命令总结 RabbitMQ不积跬步无以至千里1.lsof -i :5672 查看有没有启动成功 2.rabbitmq 3.rabbitmqctl list_queues 查看所有队列的名称 4.rabbitmqctl list_vhosts 5.rabbitmqctl status 查看当前节点的状态]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaSE 总结 IO 集合 线程]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1.集合]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java动态代理]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F12%2F04%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[java反射机制完全详解#1.反射源头 —Class类 1.1 取得Class类对象 ⭐️1234567public class Demo &#123; public static void main(String[] args) &#123; Date date = new Date(); Class&lt;? extends Date&gt; class1 = date.getClass();//取得class类对象 System.out.println(class1);//class java.util.Date &#125;&#125; 12345678//利用类.class获得反射的是实例划对象public class Demo1 &#123; public static void main(String[] args) &#123; Date date = new Date(); Class&lt;? extends Date&gt; class1 = java.util.Date.class ;//取得class类对象 System.out.println(class1);//class java.util.Date &#125;&#125; 12345678//利用Class类提供的方法实例化对向public class Demo2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class&lt;?&gt; forName = Class.forName("java.util.Date"); System.out.println(forName);//class java.util.Date &#125;&#125; #2.利用反射实例化对象 2.1public T newInstacne ⭐️⭐️123456789101112131415161718public class Demo3 &#123; public Demo3() &#123; System.out.println("^^^^"); &#125; public String toString() &#123; return "######"; &#125;&#125;-------------------------------------------------------------------------------- public class Demo4 &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; class1 = Class.forName("反射.Demo3"); Object object = class1.newInstance();// 实例化对象 // Demo3 demo3=new Demo3();//调用无参构造 System.out.println(class1); System.out.println(object); &#125;&#125; 2.2。工厂设计模式 3.取得类继承结构 123456789101112131415161718192021222324252627public class Demo3 extends Object implements Serializable &#123; public Demo3() &#123; System.out.println("^^^^"); &#125; public String toString() &#123; return "######"; &#125;&#125;-------------------------------------------------------------------------------- public class Demo4 &#123; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; class1 = Class.forName("反射.Demo3"); class1.getName();// 包名.类名 class1.getPackage();// package 包名 class1.getPackage().getName();// 包名 class1.getSimpleName();// 类名 class1.getSuperclass().getName();// 父类的包名 Class&lt;?&gt;[] icls = class1.getInterfaces();// [Ljava.lang.Class;@6bf256fa for (int i = 0; i &lt; icls.length; i++) &#123; System.out.println(icls[i].getSimpleName());//Serializable &#125; 4.反射取得构造方法（invoke） 5.反射取得方法 ⭐️⭐️⭐️ 1234567891011121314public class Demo5 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; getMethodDemo(); &#125; // 获取指定Class中的公共函数 public static void getMethodDemo() throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = Class.forName(&quot;反射.Persion&quot;); Method[] methods = clazz.getMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; System.out.println(methods[i]); &#125; &#125; 6.Invoke –]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于java的容器注解]]></title>
    <url>%2F2018%2F12%2F04%2FSpring%2Fjava%E5%AE%B9%E5%99%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/196 后续更新 1.实战 总结]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bean的配置项作用域生命周期]]></title>
    <url>%2F2018%2F12%2F04%2FSpring%2Fbean%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F04%2FSpring%2FSpringAOP%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC 及bean容器 注入]]></title>
    <url>%2F2018%2F12%2F04%2FSpring%2FSpringIOC%2F</url>
    <content type="text"><![CDATA[1.IOC及Bean容器 ​ 2.Spring 注入 &lt;必须要有get/set方法&gt; &lt; property name=”” ref=””&gt;⭐️ * name= 当前Bean中class所在的类的注入的属性的 成员变量名 * ref=表示引用 下一个的ID值 ** &lt;必须要有构造器方法&gt; 3.实战–IOC3.1传统的new 方式实现接口编程​ 3.2使用Bean开发 3.2 set注入1.Dao层 2.service层 3.3 构造方法注入]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbit MQ 命令行与管控台]]></title>
    <url>%2F2018%2F12%2F03%2FRabbitMQ%2F2.%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8E%E7%AE%A1%E6%8E%A7%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435rabbitmqctl stop_app：关闭应用rabbitmqctl stop_app：启动应用rabbitmqctlstatus：节点状态rabbitmqctladd_user username password：添加用户rabbitmqctllist_users：列出所有用户rabbitmqctldelete_user username：删除用户rabbitmqctl clear_permissions -p vhostpath username ：清楚用户权限rabbitmqctladd_vhost vhostpath：创建虚拟主机rabbitmqctllist_vhost：列出所有虚拟主机rabbitmqctllist_permissions -p vhostpath：列出虚拟主机所有权限rabbitmqctldelete_vhost vhostpath：删除虚拟主机rabbitmqctllist_queues：查看所有队列信息rabbitmqctl -p vhostpath purge_queue blue：清除队列里的消息rabbitmqctlreset：移除所有数据，要在rabbitmqctlstop_app之后使用rabbitmqctl join_cluster [--ram]：组成集群命令rabbitmqctlcluster_status：查看集群状态rabbitmqctlchange_cluster_node_type disc |ram：修改集群节点的存储模式rabbitmqctlforget_cluster_node_ [--offline] ：忘记节点（摘除节点）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux安装RabbitMQ]]></title>
    <url>%2F2018%2F12%2F03%2FRabbitMQ%2F1.RabbitMQ%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在基于RPM的Linux上安装（RHEL，CentOS，Fedora，openSUSE） 1.下载Erlang https://www.erlang-solutions.com/resources/download.html ❌❌❌ http://www.rabbitmq.com/releases/erlang/ ☑️☑️☑️ 2 下载RabbitMQ服务器、 # #方法一：Wget +地址方法二：在终端中输入命令: scp 待上传文件名 linux用户名@服务器IP:存放到服务器的哪个位置 :~ fa 3.安装scoket 123456789101112131415161718192021222324## RabbitMQ 参考资料慕课网老师讲义 准备：yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz下载：wget www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpmwget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpmwget www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm配置文件：vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;&quot;guest&quot;&gt;&gt;,只保留guest服务启动和停止：启动 rabbitmq-server start &amp;停止 rabbitmqctl app_stop管理插件：rabbitmq-plugins enable rabbitmq_management访问地址：http://192.168.11.76:15672/]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识RabbitMQ]]></title>
    <url>%2F2018%2F12%2F03%2FRabbitMQ%2F0.RabbitMQ%2F</url>
    <content type="text"><![CDATA[http://www.rabbitmq.com/#features 安装顺序 ：先是erlang 然后是 socat 然后是rabbitmq Linux安装：]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis]]></title>
    <url>%2F2018%2F12%2F02%2Fgererational%2F</url>
    <content type="text"><![CDATA[如何找到上图的地址：方式1: 方式2:]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2F2018%2F12%2F02%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F%E5%B8%B8%E7%94%A8maven%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;7.0.64&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mybatis.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mybatis.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt;&lt;/dependency&gt;&lt;-- JSON 序列化工具--&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;!--&lt;scope&gt;runtime&lt;/scope&gt;--&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;20.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- id加密解密 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hashids&lt;/groupId&gt; &lt;artifactId&gt;hashids&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- ftpclient --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- file upload --&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis pager --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- alipay 阿里支付--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-configuration&lt;/groupId&gt; &lt;artifactId&gt;commons-configuration&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt;&lt;/dependency&gt;&lt;redis 客户端 jedis&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器linux awd云]]></title>
    <url>%2F2018%2F12%2F02%2FLinux%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[登录Linux云服务器浏览器 WebShell 方式登录 支持复制粘贴、中文输入法，需要开启 SSH 端口（TCP:22） 立即登录 标准登录方式 使用 Windows 系统的电脑 1、下载安装 Windows SSH 和 Telnet 客户端工具 Putty。 下载Putty 2、用户名： root，Host： 94.191.24.33 3、按照 Putty 使用帮助进行登录。 Putty 密码方式使用帮助 使用 Linux/Mac OS X 系统的电脑（使用密码登录） 1、打开 SSH 客户端（Mac可使用系统自带的终端） 2、输入 ssh -q -l root -p 22 94.191.24.33 3、输入 CVM 实例密码进行登录。 使用 Linux/Mac OS X 系统的电脑（使用密钥登录） 1、打开 SSH 客户端（Mac可使用系统自带的终端）。 2、查找您云服务器关联的 SSH 密钥文件本地存放地址。 3、您的密钥必须不公开可见，SSH 才能工作。请使用此命令： chmod 400 [密钥文件路径]。 4、输入命令： ssh [-i 密钥文件路径] root@94.191.24.33。 浏览器 VNC 方式登录 不推荐 暂不支持复制粘贴、中文输入法。 立即登录 提示：采用VNC方式登录，请务必开启 MFA 二次验证提高安全保障级别 git@gitee.com:GoodMrY/mmall_learning.git git@gitee.com:GoodMrY/mmall_learning.gitgit@gitee.com:GoodMrY/mmall_learning.gitgit@gitee.com:GoodMrY/mmall_learning.gitgit@gitee.com:GoodMrY/mmall_learning.git]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java企业级项目]]></title>
    <url>%2F2018%2F12%2F01%2Fjava%E7%94%B5%E5%95%86%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[123456789-A INPUT -p TCP --dport 61001:62000 -j ACCEPT-A OUTPUT -p TCP --sport 61001:62000 -j ACCEPT-A INPUT -p TCP --dport 20 -j ACCEPT-A OUTPUT -P TCP --sport 20 -j ACCEPT-A INPUT -p TCP --dprot 21 -j ACCEPT-A OUTPUT -p TCP --sport 21 -j ACCEPT]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F01%2FLinux%2FLinux%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F30%2FLinux%2FLinux%E5%AE%89%E8%A3%85Tomcat%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[linux安装JDK1.7 cento7]]></title>
    <url>%2F2018%2F11%2F30%2FLinux%2FLinux%E5%AE%89%E8%A3%85JDK%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2018%2F11%2F30%2FLinux%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux SSH Mac1.下载 淘宝 用户名dongguakeji 密码dongguakeji2.mac远程访问SSH 不再sudoers文件中此事将被报告 （dongguakeji密码不能使用）–解决 使用root登陆分配权限 3.使用root登陆 远程SSH连接Linux centos7 使用root访问 关闭防火墙 11.你要改用iptables的话，需要安装iptables服务 sudo yum install iptables-services CentOS 7.0默认使用的是firewall作为防火墙，这里改为 iptables防火墙步骤。 firewall-cmd –state. #查看默认防火墙状态 （关闭后显示notrunning，开启后显示running） [root@localhost ~]#firewall-cmd –state not running 关闭防火墙： systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 4.Linux下ip设置 https://blog.csdn.net/qq_34924407/article/details/79967650. Centos7中查看IP命令：IP add https://blog.csdn.net/tuntun1120/article/details/65443757 虚拟机下CentOS7开启SSH连接 4.切换网络模式选择 然后重新编辑⭐️ 虚拟主机–&gt;网络适配器——&gt;侨界模式—&gt;复制物理网络连接转台然后重新编辑IP 变成下面这样 总结：1.先检查SSH 服务开没开 2.检查22 端口的状态 3.看网络互相通过ping看看是不是有64type的回应 4。资料在收藏夹里面 还有慕课的视频Linux]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F11%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[public class Test { ​ public static void main(String[] args) { ​ LinkedList linkedlist = new LinkedList(); ​ Node e = new Node(“e”); ​ Node e2 = new Node(“e22”); ​ Node e3 = new Node(“e33”); ​ Node e4 = new Node(“e44”); ​ Node e5 = new Node(“e55”); ​ Node e6 = new Node(“e66”); ​ }} 1234567891011121314151617181920public class Test &#123; public static &lt;E&gt; void main(String[] args) &#123; LinkedList&lt;E&gt; linkedlist = new LinkedList&lt;E&gt;(); Node e = new Node("e"); Node e2 = new Node("e22"); Node e3 = new Node("e33"); Node e4 = new Node("e44"); Node e5 = new Node("e55"); Node e6 = new Node("e66"); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot尚硅谷]]></title>
    <url>%2F2018%2F11%2F11%2FSpringBoot%2FSpring%20Boot%2F</url>
    <content type="text"><![CDATA[一、**Spring Boot 入门 1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； ccc 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.atguigu.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; ##4、配置文件占位符 1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ​ ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings("rawtypes")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico ​ 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== ​ Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path="/hello" view-name="success"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = "spring.messages")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="asserts/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="asserts/css/signin.css" th:href="@&#123;/asserts/css/signin.css&#125;" rel="stylesheet"&gt; &lt;/head&gt; &lt;body class="text-center"&gt; &lt;form class="form-signin" action="dashboard.html"&gt; &lt;img class="mb-4" th:src="@&#123;/asserts/img/bootstrap-solid.svg&#125;" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72"&gt; &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#&#123;login.tip&#125;"&gt;Please sign in&lt;/h1&gt; &lt;label class="sr-only" th:text="#&#123;login.username&#125;"&gt;Username&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="Username" th:placeholder="#&#123;login.username&#125;" required="" autofocus=""&gt; &lt;label class="sr-only" th:text="#&#123;login.password&#125;"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#&#123;login.password&#125;" required=""&gt; &lt;div class="checkbox mb-3"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#&#123;login.btn&#125;"&gt;Sign in&lt;/button&gt; &lt;p class="mt-5 mb-3 text-muted"&gt;© 2017-2018&lt;/p&gt; &lt;a class="btn btn-sm"&gt;中文&lt;/a&gt; &lt;a class="btn btn-sm"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = "spring.mvc", name = "locale") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter("l"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split("_"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style="color: red" th:text="$&#123;msg&#125;" th:if="$&#123;not #strings.isEmpty(msg)&#125;"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute("msg","没有权限请先登陆"); request.getRequestDispatcher("/index.html").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); registry.addViewController("/main.html").setViewName("dashboard"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**") .excludePathPatterns("/index.html","/","/user/login"); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"&gt; &lt;div class="sidebar-sticky"&gt; &lt;ul class="nav flex-column"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" th:class="$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;" href="#" th:href="@&#123;/main.html&#125;"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"&gt; &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"&gt;&lt;/path&gt; &lt;polyline points="9 22 9 12 15 12 15 22"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class="sr-only"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace="commons/bar::#sidebar(activeUri='emps')"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type="email" class="form-control" placeholder="zhangsan@atguigu.com"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action="@&#123;/emp&#125;" method="post"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name="_method";值就是我们指定的请求方式--&gt; &lt;input type="hidden" name="_method" value="put" th:if="$&#123;emp!=null&#125;"/&gt; &lt;input type="hidden" name="id" th:if="$&#123;emp!=null&#125;" th:value="$&#123;emp.id&#125;"&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="$&#123;emp!=null&#125;?$&#123;emp.email&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class="form-control" name="department.id"&gt; &lt;option th:selected="$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;" th:value="$&#123;dept.id&#125;" th:each="dept:$&#123;depts&#125;" th:text="$&#123;dept.departmentName&#125;"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" th:text="$&#123;emp!=null&#125;?'修改':'添加'"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each="emp:$&#123;emps&#125;"&gt; &lt;td th:text="$&#123;emp.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text="$&#123;emp.email&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.gender&#125;==0?'女':'男'"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.departmentName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-sm btn-primary" th:href="@&#123;/emp/&#125;+$&#123;emp.id&#125;"&gt;编辑&lt;/a&gt; &lt;button th:attr="del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;" class="btn btn-sm btn-danger deleteBtn"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(".deleteBtn").click(function()&#123; //删除当前员工的 $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put("timestamp", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value("$&#123;error.path:/error&#125;")private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = "error/" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code","user.notexist"); map.put("message",e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute("javax.servlet.error.status_code"); */ request.setAttribute("javax.servlet.error.status_code",500); map.put("code","user.notexist"); map.put("message",e.getMessage()); //转发到/error return "forward:/error"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put("company","atguigu"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir("tomcat")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the " + "configure method or add an @Configuration annotation"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql "docker-entrypoint.sh" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql "docker-entrypoint.sh" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql "docker-entrypoint.sh" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = "spring.datasource.type")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125; 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select("select * from department where id=#&#123;id&#125;") public Department getDeptById(Integer id); @Delete("delete from department where id=#&#123;id&#125;") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = "id") @Insert("insert into department(departmentName) values(#&#123;departmentName&#125;)") public int insertDept(Department department); @Update("update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;") public int updateDept(Department department);&#125; 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = "com.atguigu.springboot.mapper")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = "last_name",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println("ApplicationContextInitializer...initialize..."+applicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println("SpringApplicationRunListener...starting..."); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get("os.name"); System.out.println("SpringApplicationRunListener...environmentPrepared.."+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextPrepared..."); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextLoaded..."); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println("SpringApplicationRunListener...finished..."); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println("ApplicationRunner...run...."); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println("CommandLineRunner...run..."+ Arrays.asList(args)); &#125;&#125; 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = "atguigu.hello")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 123456789101112131415161718package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+"-" +name + helloProperties.getSuffix(); &#125;&#125; 12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker镜像加速]]></title>
    <url>%2F2018%2F11%2F11%2FDocker%2FDocker%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[emmm。。。为什么图片可以使用 网上的地址？ https://www.jianshu.com/p/94c6e44ebd3c 不要使用https前缀， 负责会提示证书错误， Version requires:- Docker for MAC version: docker version STEPS:- Open docker -&gt;preference -&gt;Daemon-&gt;basic-&gt;Registry mirrors 添加： http://registry.docker-cn.com Note：不要使用https前缀， 负责会提示证书错误， “registry-mirrors” : No certs for egitstry.docker.com 导致dockerrestart failed。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker上传到腾讯云服务器上]]></title>
    <url>%2F2018%2F11%2F11%2FDocker%2FDocker%E4%B8%8A%E4%BC%A0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[https://cloud.tencent.com/document/product/457/9117 腾讯云 https://study.163.com/course/courseLearn.htm?courseId=1006018194#/learn/video?lessonId=1053398787&amp;courseId=1006018194 小D课堂 先选择容器服务 123sudo docker login --username=[username] ccr.ccs.tencentyun.com sudo docker login --username=100007660104 ccr.ccs.tencentyun.com 100007660104 username:腾讯云账号，开通时已注册。输入密码后即登录完成。 ##注意 用户名 不是QQ号登陆的密码而是仓库的用户名 第一次自动生成 ####密码输入的时候先输入电脑root密码 z ###再输入密码yhp836143 12$ sudo docker tag [ImageId] ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号]$ sudo docker push ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号] 12$ sudo docker tag 5fc4ede68fcd ccr.ccs.tencentyun.com/freemana2017/atcrod:latest$ sudo docker push ccr.ccs.tencentyun.com/freemana2017/atcrod:latest 密码输入 z 因为是sudo 使用镜像—-下载镜像 小D课堂 第62讲 mac远程登陆腾讯云服务器 然后在腾讯云服务器上使用push命令拉去镜像 然后使用run命令运行镜像 最后改成公网访问镜像 登陆到腾讯云的实验室 安装Docker环境 在本机上登陆SSH 然后搭建Docker环境 ### https://cloud.tencent.com/developer/labs/lab/10054/console 在本机上远程腾讯云 搭建Docker环境 登录到镜像仓库，需输入密码。 1$ sudo docker login --username=[username] ccr.ccs.tencentyun.com 下载镜像。 sudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latest 1$ sudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latest ⭐️Docker：Cannot connect to the Docker daemon. Is the docker daemon running on this host? https://www.w3cschool.cn/kxqhmy/suzagdn1.html 查看是否存在进程： 1$ ps aux |grep docker1 停止进程 1$sudo service docker stop1 重启docker： 1$dockerd Docker在云服务器上的安装 https://www.jianshu.com/p/ea3078dae4fb 简书 1.登陆到服务器上面 通过终端 或者云主机登陆 2.开始操作 3.https://docs.docker.com/install/linux/docker-ce/centos/#uninstall-old-versions 官网 Docker的安装方式—腾讯云服务器上面 好像买的系统是Cents的 安装 CentOS 的安装 Docker：Cannot connect to the Docker daemon. Is the docker daemon running on this host? 1Docker：Cannot connect to the Docker daemon. Is the docker daemon running on this host? docker -d -p 8888：8080 先分配角色。在启动Docker 如果端口播被占用了 先关闭Docker sudo service docker stop 在启动Doccur service docker start 大佬指教。不是locaohostg 192.168.2.123 是公网ip腾讯公网的ip–118.89.28.213 加镜像名啊 兄die]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot Docker 小D课堂]]></title>
    <url>%2F2018%2F11%2F11%2FSpringBoot%2FSpringBoot-Docker-%E5%B0%8FD%E8%AF%BE%E5%A0%82%2F</url>
    <content type="text"><![CDATA[构建SpringBoot 应用docker镜像1.第1课 高级篇幅之构建SpringBoot应用docker镜像上集 官方文档：https://spring.io/guides/gs/spring-boot-docker/ 1、步骤：maven里面添加配置pom.xml 简介:使用Docker的maven插件，构建springboot应用 &lt;!--在maven最上面的申明的地方--properties--&gt; &lt;properties&gt; &lt;docker.image.prefix&gt;xdclass&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;!--项目打包的名称--&gt; &lt;finalName&gt;docker-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 配置讲解 Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。 ${project.build.finalName} 产出物名称，缺省为${project.artifactId}-${project.version} ⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ https://blog.csdn.net/TMaskBoy/article/details/82562413 高能预警 No plugin found for prefix ‘docker’ in the current project and in the plugin groups在Maven的配置文件 conf/settings.xml中添加com.spotify 12345&lt;pluginGroups&gt; &lt;pluginGroup&gt;com.spotify&lt;/pluginGroup&gt; &lt;/pluginGroups&gt;注意setting配置文件在maven的仓库里面找不到 重新更新idea中maven的插件 然后 更换.m2中conf中setting.xml的内容 #详细错误如下：om.spotify.docker.client.shaded.com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.spotify.docker.client.messages.RegistryAuth: no String-argument constructor/factory method to deserialize from String value (‘swarm’) 起初pom.xml中docker-maven-plugin的版本是1.0.0，使用mvn package docker:build -e构建Image出现如上异常。百般搜索无果，后来看其他的Spring Boot构建Docker镜像有用的是0.4.3，遂修改之。 解决办法 将小D课堂里面的插件 &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; 改为⭐️⭐️ 123&lt;groupId&gt;com.spotify&lt;/groupId&gt;&lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; ⭐️ //这边不是dockerfile-maven-plugin了而是docker-maven-plugin&lt;version&gt;0.4.13&lt;/version&gt; ⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ 第2课 高级篇幅之构建SpringBoot应用docker镜像下集 步骤1创建Dockerfile,默认是根目录，（可以修改为src/main/docker/Dockerfile,如果修则需要制定路径） 简介:打包SpringCloud镜像并上传私有仓库并部署 1、 什么是Dockerfile : 由一系列命令和参数构成的脚本，这些命令应用于基础镜像, 最终创建一个新的镜 像 实战 FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 参数讲解： FROM &lt;image&gt;:&lt;tag&gt; 需要一个基础镜像，可以是公共的或者是私有的， 后续构建会基于此镜像，如果同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令 VOLUME 配置一个具有持久化功能的目录，主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容 器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据 文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录 ARG 设置编译镜像时加入的参数， ENV 是设置容器的环境变量 COPY : 只支持将本地文件复制到容器 ,还有个ADD更强大但复杂点 ENTRYPOINT 容器启动时执行的命令 EXPOSE 8080 暴露镜像端口 第3课构建镜像2、构建镜像 mvn install dockerfile:build 打标签 docker tag a1b9fc71720d registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 推送到镜像仓库 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 应用服务器拉取镜像 docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 docker run -d --name xdclass_docker_demo1 -p 8099:8080 a1b9fc71720d 3、查看启动日志 docker logs -f containerid 实战1.mvn install dockerfile:build。不知道为什么终端没有用idea中终端却有用 😄哈哈 2.docker images 没有名字镜像？？注意在idea中测试的话就要用idea 不要随变改成终端 3.docker run -d –name demo -p 8080:8080 8ef42611e3b0 备注：运行镜像 –name 指定名字 -d 后台运行 8ef42611e3b0：刚刚构建的image的ID name 不会用就别用 4.docker ps 查看一下镜像的进程 ？？？没有程序。测试一下]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小D课堂SpringCloud笔记]]></title>
    <url>%2F2018%2F11%2F10%2FSpringCloud%2Fspringcloud%2F</url>
    <content type="text"><![CDATA[##SpringCloud课程笔记 第一章 课程介绍和学习路线 1、微服务架构SpringCloud课程介绍​ 简介：课程介绍和课程大纲讲解，讲课风格和重点内容理解技巧 2、技术选型和学后水平​ 简介：课程所需基础和技术选型讲解，学完课程可以到达怎样的程度，​​ 1、IDEA JDK8 Maven SpringBoot基础 Linux​​ 2、理解掌握并开发SpringCloud里面主流架构和组件的基础使用，还有部分源码原理的理解​ 3、掌握学习的技巧和解决问题的思路 第二章 架构演进和分布式系统基础知识 1、传统架构演进到分布式架构​ 简介：讲解单机应用和分布式应用架构演进基础知识 (画图) 高可用 LVS+keepalive 1、单体应用： 开发速度慢 启动时间长 依赖庞大 等等 2、微服务 易开发、理解和维护 独立的部署和启动 等 不足： 分布式系统-》分布式事务问题 需要管理多个服务-》服务治理 2、微服务核心基础讲解​ 简介：讲解微服务核心知识 ：网关、服务发现注册、配置中心、链路追踪、负载均衡器、熔断​ 1、网关：路由转发 + 过滤器​ /api/v1/pruduct/ 商品服务​ /api/v1/order/ 订单服务​ /api/v1/user/ 用户服务 2、服务注册发现：调用和被调用方的信息维护 3、配置中心：管理配置，动态更新 application.properties 4、链路追踪：分析调用链路耗时 例子：下单-》查询商品服务获取商品价格-》查询用户信息-》保存数据库 5、负载均衡器：分发负载 6、熔断：保护自己和被调用方 3、常见的微服务框架​ 简介:讲解常用的微服务框架 consumer: 调用方 provider: 被调用方 一个接口一般都会充当两个角色（不是同时充当） 1、dubbo: zookeeper + dubbo + springmvc/springboot 官方地址：http://dubbo.apache.org/#!/?lang=zh-cn 配套 通信方式：rpc 注册中心：zookeper/redis 配置中心：diamond 2、springcloud: 全家桶+轻松嵌入第三方组件(Netflix 奈飞) 官网：http://projects.spring.io/spring-cloud/ 配套 通信方式：http restful 注册中心：eruka/consul 配置中心：config 断路器：hystrix 网关：zuul 分布式追踪系统：sleuth+zipkin 学习资料：https://blog.csdn.net/zhangweiwei2020/article/details/78646252 4、微服务下电商项目基础模块设计​ 简介：微服务下电商项目基础模块设计 分离几个模块，课程围绕这个基础项目进行学习​ 小而精的方式学习微服务 1、用户服务 1）用户信息接口 2）登录接口 2、商品服务 1）商品列表 2）商品详情 3、订单服务 1）我的订单 2）下单接口 =============================================更多干货技术访问小D课堂官网 https://xdclass.net小D老师个人微信：jack794666918 公众号搜索：小D课堂第三章 SpringCloud核心组件注册中心 1、什么是微服务的注册中心​ 简介：讲解什么是注册中心，常用的注册中心有哪些 (画图)​​ 理解注册中心：服务管理,核心是有个服务注册表，心跳机制动态维护​​ 服务提供者provider: 启动的时候向注册中心上报自己的网络信息​ 服务消费者consumer: 启动的时候向注册中心上报自己的网络信息，拉取provider的相关网络信息 为什么要用： 微服务应用和机器越来越多，调用方需要知道接口的网络地址，如果靠配置文件的方式去控制网络地址，对于动态新增机器，维护带来很大问题 主流的注册中心： zookeeper、Eureka、consul、etcd 等 ​ 2、分布式应用知识CAP理论知识​ 简介：讲解分布式核心知识CAP理论 CAP定理： 指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得。 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间的数据完全一致，越多节点，数据同步越耗时） ​​ 可用性（A）：负载过大后，集群整体是否还能响应客户端的读写请求。（服务一直可用，而且是正常响应时间） 分区容错性（P）：分区容忍性，就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好） CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡 ​ 3、分布式系统CAP原理常见面试题和注册中心选择​ 简介:讲解CAP原则在面试中回答和注册中心选择 C A 满足的情况下，P不能满足的原因： 数据同步(C)需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足 CP 满足的情况下，A不能满足的原因： 数据同步(C)需要时间, 机器数量也多(P)，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足 AP 满足的情况下，C不能满足的原因： 机器数量也多(P)，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足 注册中心选择： Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足 Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化 结论：分布式系统中P,肯定要满足，所以只能在CA中二选一 没有最好的选择，最好的选择是根据业务场景来进行架构设计 如果要求一致性，则选择zookeeper，如金融行业 如果要去可用性，则Eureka，如电商系统 4、SpringCloud微服务核心组件Eureka介绍和闭源后影响​ 简介：​ SpringCloud体系介绍​ 官方地址：http://projects.spring.io/spring-cloud/ Eureka的基础知识--&gt;画图讲解交互流程，服务提供者&lt;--&gt;服务消费者 ; Eureka 2.x闭源后选择 参考：https://www.jianshu.com/p/d32ae141f680 https://blog.csdn.net/zjcjava/article/details/78608892 5、服务注册和发现Eureka Server搭建实战​ 简介：使用IDEA搭建Eureka服务中心Server端并启动，项目基本骨架介绍​​ 官方文档：http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-eureka-server​​ 第一步：创建项目​ 第二步: 添加注解 @EnableEurekaServer​ 第三步：增加配置application.yml​ server:​ port: 8761​ eureka: instance: hostname: localhost client: #声明自己是个服务端 registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 第四步：访问注册中心页面 maven地址: https://www.cnblogs.com/sword-successful/p/6408281.html 6、服务注册和发现之Eureka Client搭建商品服务实战​ 简介：搭建用商品服务，并将服务注册到注册中心 1、创建一个SpirngBoot应用，增加服务注册和发现依赖 2、模拟商品信息，存储在内存中 3、开发商品列表接口，商品详情接口 4、配置文件加入注册中心地址 使用eureka客户端 官方文档：http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#netflix-eureka-client-starter 7、Eureka服务注册中心配置控制台问题处理​ 简介：讲解服务注册中心管理后台，（后续还会细讲） 问题：eureka管理后台出现一串红色字体：是警告，说明有服务上线率低 EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. 关闭检查方法：eureka服务端配置文件加入 server: enable-self-preservation: false 注意：自我保护模式禁止关闭，默认是开启状态true ​​ 问题二：为什么只加一个注册中心地址，就可以注册​ By having spring-cloud-starter-netflix-eureka-client on the classpath, your application automatically registers with the Eureka Server. Configuration is required to locate the Eureka server, as shown in the following example: 第四章 服务消费者ribbon和feign实战和注册中心高可用 1、常用的服务间调用方式讲解​ 简介：讲解常用的服务间的调用方式 RPC: 远程过程调用，像调用本地服务(方法)一样调用服务器的服务 支持同步、异步调用 客户端和服务器之间建立TCP连接，可以一次建立一个，也可以多个调用复用一次链接 PRC数据包小 protobuf thrift rpc：编解码，序列化，链接，丢包，协议 Rest(Http): http请求，支持多种协议和功能 开发方便成本低 http数据包大 java开发：HttpClient，URLConnection 2、微服务调用方式之ribbon实战 订单调用商品服务​ 简介：实战电商项目 订单服务 调用商品服务获取商品信息​ 1、创建order_service项目​ 2、开发伪下单接口​ 3、使用ribbon. (类似httpClient,URLConnection) 启动类增加注解 @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } 4、根据名称进行调用商品，获取商品详情 3、高级篇幅之Ribbon负载均衡源码分析实战​ 简介: 讲解ribbon服务间调用负载均衡源码分析​ 1、完善下单接口​ 2、分析@LoadBalanced​ 1）首先从注册中心获取provider的列表​ 2）通过一定的策略选择其中一个节点 3）再返回给restTemplate调用 =============================================更多干货技术访问小D课堂官网 https://xdclass.net小D老师个人微信：jack794666918 公众号搜索：小D课堂4、高级篇幅之服务间调用之负载均衡策略调整实战​ 简介：实战调整默认负载均衡策略实战 自定义负载均衡策略：http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html#_customizing_the_ribbon_client_by_setting_properties 在配置文件yml里面，自定义负载均衡策略 #自定义负载均衡策略 product-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 策略选择： 1、如果每个机器配置一样，则建议不修改策略 (推荐) 2、如果部分机器配置强，则可以改为 WeightedResponseTimeRule 5、微服务调用方式之feign 实战 订单调用商品服务​ 简介：改造电商项目 订单服务 调用商品服务获取商品信息​ Feign： 伪RPC客户端(本质还是用http)​ 官方文档: https://cloud.spring.io/spring-cloud-openfeign/ 1、使用feign步骤讲解（新旧版本依赖名称不一样） 加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 启动类增加@EnableFeignClients 增加一个接口 并@FeignClient(name=&quot;product-service&quot;) 2、编码实战 3、注意点： 1、路径 2、Http方法必须对应 3、使用requestBody，应该使用@PostMapping 4、多个参数的时候，通过@RequestParam（&quot;id&quot;) int id)方式调用 6、Feign核心源码解读和服务调用方式ribbon和Feign选择​ 简介: 讲解Feign核心源码解读和 服务间的调用方式ribbon、feign选择​​ 1、ribbon和feign两个的区别和选择​ 选择feign​ 默认集成了ribbon​ 写起来更加思路清晰和方便​ 采用注解方式进行配置，配置熔断等方式方便​​ 2、超时配置​ 默认optons readtimeout是60，但是由于hystrix默认是1秒超时​ #修改调用超时时间 feign: client: config: default: connectTimeout: 2000 readTimeout: 2000 模拟接口响应慢，线程睡眠新的方式 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } 第五章 互联网架构服务降级熔断 Hystrix 实战 1、分布式核心知识之熔断、降级讲解​ 简介：系统负载过高，突发流量或者网络等各种异常情况介绍，常用的解决方案 1、熔断： 保险丝，熔断服务，为了防止整个系统故障，包含子和下游服务 下单服务 -》商品服务 -》用户服务 （出现异常-》熔断） 2、降级： 抛弃一些非核心的接口和数据 旅行箱的例子：只带核心的物品，抛弃非核心的，等有条件的时候再去携带这些物品 ​​ 3、熔断和降级互相交集​ 相同点：​ 1）从可用性和可靠性触发，为了防止系统崩溃​ 2）最终让用户体验到的是某些功能暂时不能用​​ 不同点​ 1）服务熔断一般是下游服务故障导致的，而服务降级一般是从整体系统负荷考虑，由调用方控制 2、Netflix开源组件断路器Hystrix介绍​ 简介：介绍Hystrix基础知识和使用场景​​ 文档地址：​ https://github.com/Netflix/Hystrix​ https://github.com/Netflix/Hystrix/wiki​​ 1、什么是Hystrix？​ 1）hystrix对应的中文名字是“豪猪”​ 2）hystrix 英[hɪst’rɪks] 美[hɪst’rɪks] ​​ 2、为什么要用？​ 在一个分布式系统里，一个服务依赖多个服务，可能存在某个服务调用失败，​ 比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败，​ 通过Hystrix就可以解决​​ http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients​ 3、提供了熔断、隔离、Fallback、cache、监控等功能 4、熔断后怎么处理？ 出现错误之后可以 fallback 错误的处理信息 兜底数据 3、Feign结合Hystrix断路器开发实战《上》​ 简介：讲解SpringCloud整合断路器的使用，用户服务异常情况 1、加入依赖 注意：网上新旧版本问题，所以要以官网为主，不然部分注解会丢失 最新版本 2.0 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; 2、增加注解 启动类里面增加注解 @EnableCircuitBreaker 注解越来越多-》 SpringCloudApplication注解 3、API接口编码实战 熔断-》降级 1）最外层api使用，好比异常处理（网络异常，参数或者内部调用问题） api方法上增加 @HystrixCommand(fallbackMethod = &quot;saveOrderFail&quot;) 编写fallback方法实现，方法签名一定要和api方法签名一致（注意点！！！） ​ 补充： 修改maven仓库地址 pom.xml中修改 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;/repositories&gt; 4、Feign结合Hystrix断路器开发实战《下》​ 简介：讲解SpringCloud整合断路器的使用，用户服务异常情况​ 1、feign结合Hystrix​​ 1）开启feign支持hystrix (注意，一定要开启，旧版本默认支持，新版本默认关闭)​ feign:​ hystrix:​ enabled: true​​ 2）FeignClient(name=”xxx”, fallback=xxx.class ), class需要继承当前FeignClient的类 5、熔断降级服务异常报警通知实战​ 简介：完善服务熔断处理，报警机制完善 1、加入redis依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2、配置redis链接信息 redis: database: 0 host: 127.0.0.1 port: 6379 timeout: 2000 3、使用 //监控报警 String saveOrderKye = &quot;save-order&quot;; String sendValue = redisTemplate.opsForValue().get(saveOrderKye); final String ip = request.getRemoteAddr(); new Thread( ()-&gt;{ if (StringUtils.isBlank(sendValue)) { System.out.println(&quot;紧急短信，用户下单失败，请离开查找原因,ip地址是=&quot;+ip); //发送一个http请求，调用短信服务 TODO redisTemplate.opsForValue().set(saveOrderKye, &quot;save-order-fail&quot;, 20, TimeUnit.SECONDS); }else{ System.out.println(&quot;已经发送过短信，20秒内不重复发送&quot;); } }).start(); 6、高级篇幅之深入源码剖析Hystrix降级策略和调整​ 简介：源码分析Hystrix降级策略和调整 1、查看默认讲解策略 HystrixCommandProperties 1）execution.isolation.strategy 隔离策略 THREAD 线程池隔离 （默认） SEMAPHORE 信号量 信号量适用于接口并发量高的情况，如每秒数千次调用的情况，导致的线程开销过高，通常只适用于非网络调用，执行速度快 2）execution.isolation.thread.timeoutInMilliseconds 超时时间 默认 1000毫秒 3）execution.timeout.enabled 是否开启超时限制 （一定不要禁用） 4）execution.isolation.semaphore.maxConcurrentRequests 隔离策略为 信号量的时候，如果达到最大并发数时，后续请求会被拒绝，默认是10 官方文档: https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.strategy 2、调整策略 超时时间调整 hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 4000 7、断路器Dashboard监控仪表盘实战​ 简介：讲解断路器Dashboard基础使用和查看​ 1、加入依赖​ ​ org.springframework.cloud​ spring-cloud-starter-netflix-hystrix-dashboard​ &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 2、启动类增加注解 @EnableHystrixDashboard ​​ 3、配置文件增加endpointmanagement: endpoints:​ web:​ exposure:​ include: “*” 4、访问入口 http://localhost:8781/hystrix Hystrix Dashboard输入： http://localhost:8781/actuator/hystrix.stream ​​ 参考资料​ 默认开启监控配置​ https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-actuator​​ 配置文件类：​ spring-configuration-metadata.json 8、断路器监控仪表参数讲解和模拟熔断​ 简介：讲解 断路器监控仪表盘参数和模拟熔断 1、sse server-send-event推送到前端 资料：https://github.com/Netflix/Hystrix/wiki/Dashboard 第六章 微服务网关zuul开发实战 1、微服务网关介绍和使用场景​ 简介：讲解网关的作用和使用场景 (画图)​​ 1）什么是网关​ API Gateway，是系统的唯一对外的入口，介于客户端和服务器端之间的中间层，处理非业务功能 提供路由请求、鉴权、监控、缓存、限流等功能​​ 统一接入​ 智能路由​ AB测试、灰度测试​ 负载均衡、容灾处理​ 日志埋点（类似Nignx日志）​ 流量监控 限流处理 服务降级 安全防护 鉴权处理 监控 机器网络隔离 2）主流的网关 zuul：是Netflix开源的微服务网关，和Eureka,Ribbon,Hystrix等组件配合使用，Zuul 2.0比1.0的性能提高很多 kong: 由Mashape公司开源的，基于Nginx的API gateway nginx+lua：是一个高性能的HTTP和反向代理服务器,lua是脚本语言，让Nginx执行Lua脚本，并且高并发、非阻塞的处理各种请求 2、SpringCloud的网关组件zuul基本使用​ 简介：讲解zuul网关基本使用 1、加入依赖 2、启动类加入注解 @EnableZuulProxy 默认集成断路器 @EnableCircuitBreaker 默认访问规则 http://gateway:port/service-id/** 例子：默认 /order-service/api/v1/order/save?user_id=2&amp;product_id=1 自定义 /xdclass_order/api/v1/order/save?user_id=2&amp;product_id=1 自定义路由转发： zuul: routes: order-service: /apigateway/** 环境隔离配置： 需求 ：不想让默认的服务对外暴露接口 /order-service/api/v1/order/save 配置： zuul: ignored-patterns: - /*-service/api/v1/order/save 3、高级篇幅之Zuul常用问题分析和网关过滤器原理分析 简介：讲解Zuul网关原理和过滤器生命周期， 1、路由名称定义问题 路由映射重复覆盖问题 2、Http请求头过滤问题 3、过滤器执行顺序问题 ，过滤器的order值越小，越先执行 4、共享RequestContext，上下文对象 4、自定义Zuul过滤器实现登录鉴权实战​ 简介：自定义Zuul过滤器实现登录鉴权实战 1、新建一个filter包 2、新建一个类，实现ZuulFilter，重写里面的方法 3、在类顶部加注解，@Component,让Spring扫描 5、高级篇幅之高并发情况下接口限流特技​ 简介：谷歌guava框架介绍，网关限流使用 1、nginx层限流 2、网关层限流 6、Zuul微服务网关集群搭建​ 简介：微服务网关Zull集群搭建 1、nginx+lvs+keepalive https://www.cnblogs.com/liuyisai/p/5990645.html 第七章 分布式链路追踪系统Sleuth和ZipKin实战​ 1、微服务下的链路追踪讲解和重要性 简介：讲解什么是分布式链路追踪系统，及使用好处 2、SpringCloud的链路追踪组件Sleuth实战 简介：讲解分布式链路追踪组件Sleuth实战 1、官方文档 http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#sleuth-adding-project 2、什么是Sleuth 一个组件，专门用于记录链路数据的开源组件 [order-service,96f95a0dd81fe3ab,852ef4cfcdecabf3,false] 1、第一个值，spring.application.name的值 2、第二个值，96f95a0dd81fe3ab ，sleuth生成的一个ID，叫Trace ID，用来标识一条请求链路，一条请求链路中包含一个Trace ID，多个Span ID 3、第三个值，852ef4cfcdecabf3、spanid 基本的工作单元，获取元数据，如发送一个http 4、第四个值：false，是否要将该信息输出到zipkin服务中来收集和展示。 3、添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt; &lt;/dependency&gt; 3、SpringCloud的链路追踪组件Sleuth常见问题说明 简介：讲解分布式链路追踪组件Sleuth常见问题说明 ​ 4、可视化链路追踪系统Zipkin部署 简介：讲解Zipkin的介绍和部署 1、什么是zipkin 官网：https://zipkin.io/ 大规模分布式系统的APM工具（Application Performance Management）,基于Google Dapper的基础实现，和sleuth结合可以提供可视化web界面分析调用链路耗时情况 2、同类产品 鹰眼（EagleEye） CAT twitter开源zipkin，结合sleuth Pinpoint，运用JavaAgent字节码增强技术 StackDriver Trace (Google) 3、开始使用 https://github.com/openzipkin/zipkin https://zipkin.io/pages/quickstart.html zipkin组成：Collector、Storage、Restful API、Web UI组成 4、知识拓展：OpenTracing OpenTracing 已进入 CNCF，正在为全球的分布式追踪，提供统一的概念和数据标准。 通过提供平台无关、厂商无关的 API，使得开发人员能够方便的添加（或更换）追踪系统的实现。 推荐阅读： http://blog.daocloud.io/cncf-3/ https://www.zhihu.com/question/27994350 https://yq.aliyun.com/articles/514488?utm_content=m_43347 5、高级篇幅之链路追踪组件Zipkin+Sleuth实战 简介：使用Zipkin+Sleuth业务分析调用链路分析实战 1、文档 http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_sleuth_with_zipkin_via_http sleuth收集跟踪信息通过http请求发送给zipkin server，zipkinserver进行跟踪信息的存储以及提供Rest API即可，Zipkin UI调用其API接口进行数据展示 默认存储是内存，可也用mysql、或者elasticsearch等存储 2、加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; 里面包含 spring-cloud-starter-sleuth、spring-cloud-sleuth-zipkin 3、文档说明：http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_features_2 4、配置zipkin.base-url 5、配置采样百分闭spring.sleuth.sampler 推荐资料： https://blog.csdn.net/jrn1012/article/details/77837710 =============================================更多干货技术访问小D课堂官网 https://xdclass.net小D老师个人微信：jack794666918 公众号搜索：小D课堂​第八章 微服务核心知识分布式配置中心Config实战​​ 1、微服务下的分布式配置中心​ 简介：讲解什么是配置中心及使用前后的好处 (画图)​ 什么是配置中心：​ 一句话：统一管理配置, 快速切换各个环境的配置​​ 相关产品：​ 百度的disconf​ 地址:https://github.com/knightliao/disconf​ 阿里的diamand 地址：https://github.com/takeseem/diamond springcloud的configs-server: 地址：http://cloud.spring.io/spring-cloud-config/ 推荐干货文章：http://jm.taobao.org/2016/09/28/an-article-about-config-center/ 2、SpringCloud的配置中心组件config-server实战 简介：讲解SpringCloud配置中心config-server实战 1、新建项目，创建config-server 2、启动类增加注解 @EnableConfigServer 3、使用git服务器结合Config搭建分布式配置中心 简介：讲解使用git服务器结合Config搭建分布式配置中心 1、默认使用git存储配置中心 使用git服务器，可以自己搭建gitlab服务器 或者使用github、开源中国git、阿里云git 794666918@qq.com xdclass.net123 https://gitee.com/waitforxy/config_cloud.git 2、配置文件添加配置 spring: application: name: config-server #git配置 cloud: config: server: git: uri: https://gitee.com/waitforxy/config_cloud username: 794666918@qq.com password: xdclass.net123 #超时时间 timeout: 5 #分支 default-label: master 3、访问方式（一定要注意语法，如果有问题，会出错） 多种访问路径，可以通过启动日志去查看 例子 http://localhost:9100/product-service.yml /{name}-{profiles}.properties /{name}-{profiles}.yml /{name}-{profiles}.json /{label}/{name}-{profiles}.yml name 服务器名称 profile 环境名称，开发、测试、生产 lable 仓库分支、默认master分支 4、分布式配置中心客户端使用实战​ 简介：微服务里面客户端接入配置中心实战​ 官方文档：http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html#_spring_cloud_config_client​​ 1、加入依赖​ ​ org.springframework.cloud​ spring-cloud-config-client​ ​​ 2、修改对应服务的配置文件,把application.yml 改为 bootstrap.yml​ #指定注册中心地址​ eureka:​ client:​ serviceUrl:​ defaultZone: http://localhost:8761/eureka/​ #服务的名称 spring: application: name: product-service #指定从哪个配置中心读取 cloud: config: discovery: service-id: CONFIG-SERVER enabled: true profile: test #建议用lable去区分环境，默认是lable是master分支 #label: test 注意点： 1.配置文件要用bootstrap.yml 2.默认读取文件名是 服务名称 第九章 微服务消息总线Bus结合消息队列RabbitMQ实战 1、消息总线Bus介绍和使用场景 简介：讲解消息总线Bus介绍和使用场景 1、什么是消息 一个事件，需要广播或者单独传递给某个接口 2、为什么使用这个 配置更新了，但是其他系统不知道是否更新 2、消息队列和RabbitMQ基础介绍 简介：消息队列和RabbitMQ基础介绍 1、消息队列介绍 参考：https://www.cnblogs.com/linjiqin/p/5720865.html 2、同类产品 ActiveMQ RocketMQ Kafka 等 3、SpringCloud默认推荐使用RabbitMQ 4、RabbitMQ介绍 官方文档：http://www.rabbitmq.com/getstarted.html 中文文档：http://rabbitmq.mr-ping.com/ 3、实战系列使用Docker搭建RabbitMQ3.7 简介：使用Docker安装RabbitMQ 1、如果对Docker没基础，课程后续有讲解Docker，可以先跳转过去学习Docker 2、安装步骤 1)拉取镜像：docker pull rabbitmq:management 2)查看当前镜像列表：docker images 3)删除指定镜像：docker rmi IMAGE_ID (如果需要强制删除加 -f) 4)创建容器 docker run -d --name=&quot;myrabbitmq&quot; -p 5671:5671 -p 15672:15672 rabbitmq:management 参数讲解: run: 创建一个新的容器并运行一个命令 -d: 后台运行容器，并返回容器ID -p: 端口映射，格式为：主机(宿主)端口:容器端口 --name=&quot;rabbitmq&quot;: 为容器指定一个名称 3、RabbitMQ默认创建了一个 guest 用户，密码也是 guest, 如果访问不了记得查看防火墙，端口或者云服务器的安全组 管理后台：http://127.0.0.1:15672 其他安装方式： Linux安装：https://blog.csdn.net/qq_34021712/article/details/72567786 windows安装：http://www.rabbitmq.com/install-windows.html https://blog.csdn.net/liyuejin/article/details/78410586 4、高级篇幅消息总线整合配置中心架构流程图 简介：讲解消息总线Bus结合config组件搭建配置中心项目架构图和操作流程 启动 rabbitmq： docker run -d -p 5672:5672 -p 15672:15672 rabbitmq:management rabbitmq默认是5672,所以改为5672端口 1、config-client加入依赖 &lt;!--配置中心结合消息队列--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; ​​ 官方文档：http://cloud.spring.io/spring-cloud-bus/single/spring-cloud-bus.html#_bus_refresh_endpoint​ 文档里面 暴露端点 management.endpoints.web.exposure.include=bus-refresh​​ 2、在配置文件中增加关于RabbitMQ的连接(如果是本机，则可以直接启动，采用默认连接配置)​ spring:​ rabbitmq:​ host: localhost​ port: 5672​ username: guest​ password: guest​ #暴露全部的监控信息 management: endpoints: web: exposure: include: &quot;*&quot; 3、需要刷新配置的地方，增加注解 @RefreshScope 4、访问验证 post方式： http://localhost:8773/actuator/bus-refresh 5、动态刷新配置: 在开发和测试环境使用，尽量少在生产环境使用 5、微服务相关项目改造配置中心 简介：把课程项目改造成配置中心讲解 1、git里面新增对应项目的配置文件，都要添加下面的配置 #服务的名称 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest #暴露全部的监控信息 management: endpoints: web: exposure: include: &quot;*&quot; ​​ 2、项目里面添加maven依赖​​ ​ ​ org.springframework.cloud​ spring-cloud-config-client​ ​ &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 3、修改application.properties为bootstrap.yml 并拷贝配置文件 #指定注册中心地址 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ #服务的名称 spring: application: name: order-service #指定从哪个配置中心读取 cloud: config: discovery: service-id: CONFIG-SERVER enabled: true profile: test 4、各个项目启动顺序 1）注册中心 2）配置中心 3）对应的服务：商品服务、订单服务。。。 4）启动网关 第十章、SpringCloud课程内容上半部分总结​ 1、微服务核心知识内容回顾 简介：回顾SpringCloud前面10章的基础内容 1)介绍微服务的基础知识，核心组件，CAP原理 2）SpringCloud注册中心 Eureka 3）product-service / order-service 4) 伪RPC Ribbon / feign 5) hystrix熔断 6) 服务网关介绍，zuul 7）配置中心config-server ​ 2、微服务下半部分知识 云服务器和Docker容器 简介：讲解云服务器和容器知识 ​ 第十一章 阿里云ECS服务器介绍和网络知识讲解 1、云服务器介绍和阿里云服务器ECS服务器选购 简介：什么是云服务器及目前主要的几个厂商介绍 1、阿里云、腾讯云、亚马逊云 阿里云：https://www.aliyun.com/ 腾讯云：https://cloud.tencent.com/ 亚马逊云：https://aws.amazon.com/ ​​ 2、阿里云服务器远程登录和常用工具​ 简介：讲解阿里云服务器登录使用和常见终端工具​ 1、windows工具 putty，xshell, security​ 参考资料：​ https://jingyan.baidu.com/article/e75057f210c6dcebc91a89dd.html​ https://www.jb51.net/softjc/88235.html​​ 2、苹果系统MAC： 通过终端登录​ ssh root@ip 回车后输入密码​ ssh root@120.25.1.38​ 3、可以尝试自己通过百度进行找文档， 安装mysql jdk nginx maven git redis elk 3、互联网架构知识之网站部署上线基础准备​ 简介：讲解应用部署到可以公网访问需要步骤 1、一个http请求的故事 2、什么是cname和a记录 A记录和CNAME只可以同时生效一个，A记录优先 3、域名和ip的关系，DNS作用 参考资料： https://blog.csdn.net/benbenzhuhwp/article/details/44704319 https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;ch=1&amp;tn=98050039_dg&amp;wd=%E4%B8%80%E4%B8%AAhttp%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B&amp;rsv_pq=80a65c5f00005961&amp;rsv_t=a5fcWreuJzILdSwr4gI8pFqlO7HSu5BlhjwalyVzPiV9w2L%2BKEj78pPi1Qn6Vx4wXxI&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=8&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;sug=%25E4%25B8%2580%25E4%25B8%25AAhttp%25E8%25AF%25B7%25E6%25B1%2582%25E7%259A%2584%25E8%25AF%25A6%25E7%25BB%2586%25E8%25BF%2587%25E7%25A8%258B&amp;rsv_n=1 4、域名购买和配置解析实战​ 简介：域名购买和配置解析实战 1、购买域名，备案 阿里云 备案地址：https://beian.aliyun.com/ 2、购买服务器，阿里云，腾讯云，亚马逊云aws 3、配置域名解析到服务器 ​ ​第十二章 微服务必备技能Docker容器基础篇幅​​ 1、微服务下的Docker介绍和使用场景​ 简介：Docker介绍和使用场景​​ 1、什么是Dokcer​ 百科:一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口；​ 使用go语言编写，在LCX（linux容器）基础上进行的封装 简单来说： 1）就是可以快速部署启动应用 2）实现虚拟化，完整资源隔离 3）一次编写，四处运行（有一定的限制，比如Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用） 2、为什么要用 1、提供一次性的环境，假如需要安装Mysql，则需要安装很多依赖库、版本等，如果使用Docker则通过镜像就可以直接启动运行 2、快速动态扩容，使用docker部署了一个应用，可以制作成镜像，然后通过Dokcer快速启动 3、组建微服务架构，可以在一个机器上模拟出多个微服务，启动多个应用 4、更好的资源隔离和共享 一句话：开箱即用，快速部署，可移植性强，环境隔离 2、Linux云服务器Centos7安装Docker实战 简介：讲解阿里云ECS服务安装Docker实战 Linux Standard Base的缩写，lsb_release命令用来显示LSB和特定版本的相关信息 命令： lsb_release -a 阿里云安装手册： https://help.aliyun.com/document_detail/51853.html?spm=a2c4g.11186623.6.820.RaToNY 常见问题： https://blog.csdn.net/daluguishou/article/details/52080250 3、Docker仓库、镜像、容器核心知识讲解 简介：快速掌握Dokcer基础知识， 1、概念： Docker 镜像 - Docker images： 容器运行时的只读模板，操作系统+软件运行环境+用户程序 class User{ private String userName; private int age; } Docker 容器 - Docker containers： 容器包含了某个应用运行所需要的全部环境 User user = new User() Docker 仓库 - Docker registeries： 用来保存镜像，有公有和私有仓库，好比Maven的中央仓库和本地私服 镜像仓库： （参考）配置国内镜像仓库：https://blog.csdn.net/zzy1078689276/article/details/77371782 对比面向对象的方式 Dokcer 里面的镜像 : Java里面的类 Class Docker 里面的容器 : Java里面的对象 Object 通过类创建对象，通过镜像创建容器 4、Docker容器常见命令实战 简介：讲解Docker在云服务上的实际应用 1、 常用命令（安装部署好Dokcer后，执行的命令是docker开头）,xxx是镜像名称 搜索镜像：docker search xxx 列出当前系统存在的镜像：docker images 拉取镜像：docker pull xxx xxx是具体某个镜像名称(格式 REPOSITORY:TAG) REPOSITORY：表示镜像的仓库源,TAG：镜像的标签 运行一个容器：docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 rabbitmq:management docker run - 运行一个容器 -d 后台运行 -p 端口映射 rabbitmq:management (格式 REPOSITORY:TAG)，如果不指定tag，默认使用最新的 --name &quot;xxx&quot; 列举当前运行的容器：docker ps 检查容器内部信息：docker inspect 容器名称 删除镜像：docker rmi IMAGE_NAME 强制移除镜像不管是否有容器使用该镜像 增加 -f 参数， 停止某个容器：docker stop 容器名称 启动某个容器：docker start 容器名称 移除某个容器： docker rm 容器名称 （容器必须是停止状态） 文档： https://blog.csdn.net/permike/article/details/51879578 5、实战应用之使用Docker部署Nginx服务器 简介：讲解使用Docker部署Nginx服务器实战 1、获取镜像 docker run (首先会从本地找镜像，如果有则直接启动，没有的话，从镜像仓库拉起，再启动) docker search nignx 2、列举 docker images 3、拉取 docker pull nignx 3、启动 docker run -d --name &quot;xdclass_nginx&quot; -p 8088:80 nginx docker run -d --name &quot;xdclass_nginx2&quot; -p 8089:80 nginx docker run -d --name &quot;xdclass_nginx3&quot; -p 8090:80 nginx 4、访问 如果是阿里云服务，记得配置安全组，腾讯云也需要配置，这个就是一个防火墙 6、公司中Docker镜像仓库使用讲解 简介：讲解一般公司中镜像仓库在的使用 1、为啥要用镜像仓库 2、官方公共镜像仓库和私有镜像仓库 公共镜像仓库： 官方：https://hub.docker.com/，基于各个软件开发或者有软件提供商开发的 非官方：其他组织或者公司开发的镜像，供大家免费试用 私有镜像仓库： 用于存放公司内部的镜像，不提供给外部试用； SpringCloud 开发了一个支付系统 -》做成一个镜像 （操作系统+软件运行环境+用户程序） 7、高级篇幅之构建自己的镜像仓库 简介：使用阿里云搭建自己的镜像仓库 1、阿里云镜像仓库：https://dev.aliyun.com/search.html 点击管理控制台-》初次使用会提示开通，然后设置密码 xdclass.net123 2、使用阿里云私有镜像仓库 1)登录： docker login --username=794666918@qq.com registry.cn-shenzhen.aliyuncs.com 2) 推送本地镜像： docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:[镜像版本号] 例子： docker tag 2f415b0e9a6e registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:xd_rabbitmq-v1.0.2 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:xd_rabbitmq-v1.0.2 3)拉取镜像 线上服务器拉取镜像： docker login --username=794666918@qq.com registry.cn-shenzhen.aliyuncs.com docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:xd_rabbitmq-v1.0.2 启动容器： docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 2f415b0e9a6e 第十三章 微服务高级篇幅SpringCloud和Docker整合部署​​ 第1课 高级篇幅之构建SpringBoot应用docker镜像上集​​ 简介:使用Docker的maven插件，构建springboot应用​ 官方文档：https://spring.io/guides/gs/spring-boot-docker/ 1、步骤：maven里面添加配置pom.xml &lt;properties&gt; &lt;docker.image.prefix&gt;xdclass&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;finalName&gt;docker-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 配置讲解 Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。 ${project.build.finalName} 产出物名称，缺省为${project.artifactId}-${project.version} =============================================更多干货技术访问小D课堂官网 https://xdclass.net小D老师个人微信：jack794666918 公众号搜索：小D课堂第2课 高级篇幅之构建SpringBoot应用docker镜像下集 简介:打包SpringCloud镜像并上传私有仓库并部署 1、创建Dockerfile,默认是根目录，（可以修改为src/main/docker/Dockerfile,如果修则需要制定路径） 什么是Dockerfile : 由一系列命令和参数构成的脚本，这些命令应用于基础镜像, 最终创建一个新的镜像 FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 参数讲解： FROM &lt;image&gt;:&lt;tag&gt; 需要一个基础镜像，可以是公共的或者是私有的， 后续构建会基于此镜像，如果同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令 VOLUME 配置一个具有持久化功能的目录，主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录 ARG 设置编译镜像时加入的参数， ENV 是设置容器的环境变量 COPY : 只支持将本地文件复制到容器 ,还有个ADD更强大但复杂点 ENTRYPOINT 容器启动时执行的命令 EXPOSE 8080 暴露镜像端口 2、构建镜像 mvn install dockerfile:build 打标签 docker tag a1b9fc71720d registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 推送到镜像仓库 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 应用服务器拉取镜像 docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:docker-demo-v201808 docker run -d --name xdclass_docker_demo1 -p 8099:8080 a1b9fc71720d 3、查看启动日志 docker logs -f containerid 文档：https://yeasy.gitbooks.io/docker_practice/image/dockerfile/ 第3课 实战系列之注册中心打包Docker镜像 简介：讲解使用Docker打包注册中心，上传私有镜像仓库并部署 1、新增maven插件 &lt;properties&gt; &lt;docker.image.prefix&gt;xdclass&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;finalName&gt;docker-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2、新建Dockerfile FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 3、打包： mvn install dockerfile:build 4、推送阿里云镜像仓库 阿里云镜像仓库：https://dev.aliyun.com/search.html docker tag 062d2ddf272a registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:eureka-v20180825docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:eureka-v20180825docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:eureka-v20180825 5、查看日志 docker logs -f containerid 第4课 实战系列之部署RabbitMQ和配置中心打包Docker镜像 简介：讲解使用Docker打包配置中心，和部署RabbitMQ 1、服务地址 ssh root@47.106.120.173 部署 rabbitmq： docker run -d -p 5672:5672 -p 15672:15672 rabbitmq:management 2、推送镜像 docker tag 0f636543904e registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180825 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180825 docker pull registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180825 5、常见问题处理之升级云服务器 简介：处理上节课出现的问题，升级服务器注意事项 1、升级云服务器配置（购买配置后需要重启机器才生效） 2、启动完成后，需要开启docker 指令： systemctl start docker 3、所有对外的都要经过网关才可以对外，应用间通信(除非跨机房)都用内网通信 6、实战系列之Docker部署Redis 简介：使用Docker安装redis 1、搜索镜像 docker search redis 2、拉取 docker pull docker.io/redis 3、启动 docker run --name &quot;xd_redis&quot; -p 6379:6379 -d 4e8db158f18d 参考： docker run --name &quot;xd_redis&quot; -p 6379:6379 -d 4e8db158f18d --requirepass &quot;123456&quot; -v $PWD/data:/data 4、访问redis容器里面，进行操作 docker exec -it 295058d2b92e redis-cli 7、生产环境常见问题之配置中心访问 简介：讲解生产环境部署常见问题，配置中心访问路径变化 1、配置中心访问出错，路径不对 解决：修改所有的注册中心，增加下面配置 instance: instance-id: ${spring.cloud.client.ip-address}:${server.port} prefer-ip-address: true docker tag 50a12cd66210 registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180826 8、实战系列之打包Docker镜像打包商品服务和订单服务、网关 简介:打包Docker镜像部署商品服务和订单服务、网关 注意： 1、maven打包构建，会触发单元测试，部分情况可以跳过， mvn install -Dmaven.test.skip=true dockerfile:build 2、生产环境不能用localhost 或者 127.0.0.1, 一定要用内网通信ip (虚拟主机映射 hosts) 9、实战系列云服务器部署网关、订单、商品服务 简介：云服务部署商品服务、订单服务、网关服务 1、拉取镜像、启动 访问路径 http://47.106.120.173:8781/api/v1/order/save?product_id=5&amp;user_id=5 http://47.106.120.173:9000/apigateway/order/api/v1/order/save?user_id=5&amp;product_id=3&amp;token=232serer 第十四章 课程总结和常见问题处理 1、SpringCloud微服务常见问题和解决思路 简介：讲解SpringCloud开发实战常见问题，及解决思路 1、技术选择：SpringCloud全家桶，每个组件又有多个替代，改怎么选择 1）选择的时候根据公司里面团队人员熟悉程度，降低学习成本 2）选择社区活跃的并且文档相对较多的，怎么判断活跃，可以看github上代码提交和start数 2、云服务选择： 腾讯云，阿里云 ，遇到问题可以提交工单，有专人跟进 ​​ 3、部署了应用，但是访问不了​ 解决思路：​ 1)查看应用启动是否正常，如果有错误日志，复制错误日志去百度搜索！！！！！！！特别重要​​ 2）启动正常，则先在本机使用 CURL “http://lcoalhost:8080/api/v1/user/find&quot; 访问对应的接口，看是否有响应​ 3）启动正常，且curl有响应，则检查是否有关闭防火墙，或者开放对应的访问端口，开放端口才可以访问 4）腾讯云和阿里云都是有安全组，类似外层防火墙，一定要去web控制台检查是否有开启端口 4、内网和外网访问，鉴权问题安全问题 1）所有应用只能通过网关提供对外访问的入口 2）应用程序之间通讯，采用内网 5、程序出错或者异常: 复制错误日志去百度搜索，网上有很多人会遇到类似的错误，多积累，特别强调 2、课程总结和后续技术规划 简介：总结SpringCloud课程和微服务后续课程规划 1、springCloud全家桶，技术选择和知识点特别多，一定要学会记笔记，微服务更多关注的是里面架构和数据流转，而不是具体的业务。 2、SpringCloud架构这些配置，一般使用一次后就不会多次修改了，进入公司主要还是开发业务，业务开发一般都用springboot，比较少让新人搭建SpringCloud的架构 3、开发业务，无非就是CRUD，增删改查，只不过是初级和高级的区别，封装成通用和不通用的区别 ​​ 4、微服务和容器盛行的情况下，容器编排和自动缩扩容越来越重要​​ 可以关注：k8s / service mesh /server less 等技术 ​​ 总结：​ 1）后续会推出对应的课程，还有项目实战系列，大家记得关注 小D课堂，官网 ：https://xdclass.net,​​ 2）也可以加我微信交流： jack794666918​ 3）购买对应的课程后，记得进我们小D课堂官方的交流群，我会在里面分享主流技术和答疑，面试经验等等，还会同步更新资料和还超级干货分享 =============================================]]></content>
  </entry>
  <entry>
    <title><![CDATA[常见问题总结]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前端向后端传值： Button 和form 1234567function goUpdatePage(id) &#123; window.location.href = "$&#123;pageContext.request.contextPath&#125;/user/editcontroller?id=" + id;&#125; &lt;button type="button" onclick="goUpdatePage($&#123;user.id&#125;)" class="btn btn-primary btn-xs"&gt; &lt;i class=" glyphicon glyphicon-pencil"&gt;&lt;/i&gt;&lt;/button&gt; 开发中service层 必须要写 @service注解 ⚠️service中不要加@service。在service的实现serviceiml中加@service注解 开发的顺序 从前端传值到Controller 再到 service 再到serviceimpl 再到userdao 再到mybatis.xml再到数据库 数据库返回前端页面 引入mybatis 的多个mapper的配置文件 mapper.xml Spring Boot 的方式 12mybatis.mapper-locations=classpath:mybatis/mapper/*.xml ###idea警告：Field injection is not recommended ####Springboot开发 Dao中UserDao RoleDao中要加 @Mapper注解 # import和open项目是不一样的 出现上面的情况要import一下啊 兄ide Caused by: org.apache.ibatis.type.TypeException: Could not resolve type alias ‘BaseResultMap’ Cause: org.apache.ibatis.builder.BuilderException: Error resolving class. Ca 看到那个resultType了么，就是它惹的祸，这里把resultType改为resultMap就OK啦，重启tomcat，木有异常啦 跳转视图 用字符串哈 开发中前端的img要放到和框架的同一目录及下面哈。兄die]]></content>
  </entry>
  <entry>
    <title><![CDATA[ITerm2的配置]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2FIterm2%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ITerm2的配置问题每次vim的时候一定要source一下 啊 xiong die 学习资源 https://www.jianshu.com/p/9c3439cc3bdb 简书 https://github.com/sirius1024/iterm2-with-oh-my-zsh Github https://www.cnblogs.com/xishuai/p/mac-iterm2.html 博客园 https://blog.csdn.net/z3512498/article/details/51245853 CSDN 改变用户名 必须要使用vim的命令修改配置 常见的命令1234vi ~/.zshrcsource ~/.zshrc （soucre配置文件 让配置文件生效）文件放在itermgit下面 必须要在主题可以使用的情况下 进行以上的配置快捷键冲突 取词 copy失效 常见问题 安装完成后，在/bin目录下会多出一个zsh的文件。 Mac系统默认使用dash作为终端，可以使用命令修改默认使用zsh： 1chsh -s /bin/zsh 如果想修改回默认dash，同样使用chsh命令即可： 1chsh -s /bin/bash export MAVEN_HOME=/Java/apache-maven-3.5.4 export PATH=${PATH}:${MAVEN_HOME}/bin]]></content>
      <tags>
        <tag>Iterm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-web]]></title>
    <url>%2F2018%2F11%2F08%2FDocker%2FDocker-web%2F</url>
    <content type="text"><![CDATA[学习地址* https://www.imooc.com/video/14624（慕课网）-6⃣刘果国 #第一个 java web项目 （SpringBoot 项目打包成一个war包的方式） 一制作自己的景象 Dockerfile docker build 首先需要一个war文件 拷贝在桌面上 Docker images 1.建立一个Dockerfile vim Dockerfile 2. 下载Tomcat镜像 网易镜像中心 找Tomcat的镜像 https://c.163yun.com/hub#/m/home/ （包括JDK Tomcat） 1docker pull hub.c.163.com/library/tomcat:latest 站在巨人的肩上 3.编辑Dockerfile1234567在Mac终端中使用vim编辑文件步骤1. cd 文件所在的文件夹路径 &lt;回車&gt;2. 輸入 vim 文件名 &lt;回車&gt;3. 按下 i 鍵來编辑文本文字4. 退出vim編輯器： 不保存并退出 &lt;ESC&gt; :q! &lt;回車&gt; 保存并退出 &lt;ESC&gt; :wq &lt;回車&gt; from hub.c.163.com/library/tomcat MAINTAINER Freemana2017 1047629166@qq.com 1234cd /Users/apple/Desktop/Dockerwebls&gt; mv atcrodfunding3_ssm-0.0.1-SNAPSHOT.war atcrod.warmv atcrodfunding3_ssm-0.0.1-SNAPSHOT.war atcrod.war (用MV 重新命名一下) 进入文件夹里面 编写Dockerfile 学会看镜像的说明 1234567891011121314151617How to use this image.Run the default Tomcat server (CMD [\&quot;catalina.sh\&quot;, \&quot;run\&quot;]):$ docker run -it --rm tomcat:8.0You can test it by visiting http://container-ip:8080 in a browser or, if you need access outside the host, on port 8888:$ docker run -it --rm -p 8888:8080 tomcat:8.0You can then go to http://localhost:8888 or http://host-ip:8888 in a browser.The default Tomcat environment in the image for versions 7 and 8 is:⭐️CATALINA_BASE: /usr/local/tomcat⭐️CATALINA_HOME: /usr/local/tomcatCATALINA_TMPDIR: /usr/local/tomcat/tempJRE_HOME: /usrCLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar 1。编写Dockerfile 文件–Dockerfile12345from hub.c.163.com/library/tomcatMAINTAINER Freemana2017 1047629166@qq.comCOPY atcrod.war /usr/local/tomcat/webapps 2.创建镜像 –docker build 3.查看镜像–docker images 4.给镜像写名字 docker build -t atcrod:latest . 5.再次查看镜像 docker images ###二运行自己的容器1.docker run -d -p 8888:8080 atcrod 8888本机的端口号。8080Tomcat的端口号 去163.com查询 atcrod镜像的名字 2.docker ps 查看Tomcat的进程 检查容器是不是启动啦 3.netstat -na|grep 8888 检查端口是不是存在了 输入localhost:8888测试Tomcat是否启动啦 ⚠️ 以上只是web项目在Docker中的部署项目3.Docker 部署SpringBoot web项目 学习资源汇总 http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html https://blog.csdn.net/weixin_39800144/article/details/79214978 https://blog.csdn.net/weixin_39800144/article/details/79213276 https://bingohuang.com/spring-boot-docker/ FROM java:8 VOLUME /tmp COPY target/tran4spd-1.0-SNAPSHOT.jar resource.jar. #这边放的是Docker部署的jar包的位置 绝对路径 RUN bash -c “touch /resource.jar” EXPOSE 8080 ENTRYPOINT [“java”,”-jar”,”resource.jar”] # docker run -d -p 18080:8099 –name docker-resource leesia/resource:1.0 注意java-jar无法运行Tomcat要外置 1234567&lt;!-- https://mvnrepository.com/artifact/javax.servlet/servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; ##文件路径不要用中文！！！]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker SpringBoot]]></title>
    <url>%2F2018%2F11%2F07%2FDocker%2FDocker-SpringBoot%2F</url>
    <content type="text"><![CDATA[DockerMachine应用注意整个过程要等待一下 参考https://study.163.com/course/courseLearn.htm?courseId=1002892012#/learn/video?lessonId=1003309140&amp;courseId=1002892012 网易云课堂 动手玩Docker 安装DockerMachine docker-machine ls tcp://192.168.99.100:2376 name：cloudcomb docker-machine create –driver virtualbox cloudcomb Docker-machine env cloudcomb ⚠️第四个变量eval说的是当前Dockermachine的名字是—cloudcomb eval $(docker-machine env cloudcomb) 拷贝放到底下 使用网易蜂巢 Docker run hub.c163.com/library/busybox:latest echon hello world （unable。。这个过程要等待啊）⭐️ docker-machine rm cloudcomb 删除docker-machine SpringBoot整合Docker Emmmm.等我有钱了 把Xnip去掉哈哈 下载源码https://github.com/bingohuang/spring-boot-docker Git 通过命令行下载文件 先cd一下指定一下下载的路径 导入项目到Idea 然后查看一下源码 运行一下项目（访问一下 测试一下） Docker SpringBoot部署项目 ⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️ 1.install项目 找到这两个文件 放到桌面上 2.将这两个项目放到一个文件下，不知道为什么好像要把jar改名成gs-spring-boot-docker-0.0.1.jar 3.cd到文件下 ls一下4.执行 ˛docker version 5.执行 docker-machine env 6.执行eval $(docker-machine env)（复制后面的第四条） tcp://192.168.99.100:2376192.168.99.100 tcp://127.0.0.1:2376 tcp://127.0.0.1:2376 ###7.docker version（没有-） 8.ls一下目录 9.docker build -t cloudcomb/sun:1.0 . （桌面上要有jar包和dockerfilede 文件） 此时报错 没有gs-spring-boot-docker.jar文件 其实ls的时候就应该是gs-spring-boot-docker.jar 这儿是个bug。 解决办法 改jar包名 添加gs前缀 1https://docker.mirrors.ustc.edu.cn 10。docker build -t cloudcomb/sun:1.0 .（大佬说这一步是拉取镜像。用加速器 改名后重新执行命令）我们可以用大佬网易云的Dokcer镜像 11. docker images -a 12.docker run -p 1024:8080 -t cloudcomb/sun:1.0 . 注意 cloudcomb和前面的cloudcomb要一一对应 1024 与8080是一一对应的关系 Error: Unable to access jarfile /app.jar ⭐️ ADD user-server-0.0.1-SNAPSHOT.jar app.jar 要和pom的user-server 保持名字一样，不然maven打出来的包，docker找不到。 最终的结局办法 好像是将copy去掉了 注意看控制台打印的信息 兄dei DockerFile： Docker就是给一名字 gs-spring-bbot 贴一个Dockerfilr。 1234567891011121314151617181920212223242526272829303132333435FROM hub.c.163.com/xbingo/jdk8:latestfrom hub.c.163.com/library/tomcatMAINTAINER Freemana2017 1047629166@qq.comADD atcrodfunding3_ssm-0.0.1-SNAPSHOT.jar app.jarENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]COPY atcrod.war /usr/local/tomcat/webapps #FROM openjdk:8-jdk-alpine#VOLUME /tmp#ADD atcrodfunding3_ssm-0.0.1-SNAPSHOT.jar app.jar#ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]# #FROM hub.c.163.com/xbingo/jdk8:latest##ADD gs-spring-boot-docker-0.1.0.jar app.jar##ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] #这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:##FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载#VOLUME ，VOLUME 指向了一个/tmp的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/tmp作为工作目录。这个命令的效果是：#在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/tmp目录#ADD ，拷贝文件并且重命名#ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT#这样 Spring Boot 项目添加 Docker 依赖就完成了。 Dockerfile 用的war要有Tomcat 自己理解吧 多看一些视频笔记什么的 反正很难,,, 以上的文件是从github上拉的 现在自己构建SpringBoot -jar的应用 通过群里的指导 估计jar打包和war打包区别不大吧 下面通过SpringBoot构建Docker部署一下试试 https://waylau.com/docker-spring-boot/ http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html https://lw900925.github.io/docker/docker-springboot.html https://www.tianmaying.com/tutorial/spring-boot-docker https://bingohuang.com/spring-boot-docker/ https://www.imooc.com/search/?words=docker http://www.ityouknow.com/docker/2018/03/30/docker-machine.html https://spring.io/guides/gs/spring-boot-docker/ SpringBoot Docker https://lw900925.github.io/docker/docker-springboot.html http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html 主要环节 $ sudo docker tag [ImageId] ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号]$ sudo docker push ccr.ccs.tencentyun.com/[namespace]/[ImageName]:[镜像版本号] ⭐️ sudo docker tag 5fc4ede68fcd ccr.ccs.tencentyun.com/atcrod/latest sudo docker push ccr.ccs.tencentyun.com/atcrod/latest]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-Idea]]></title>
    <url>%2F2018%2F11%2F07%2FDocker%2FDocker-Idea%2F</url>
    <content type="text"><![CDATA[###1.Docker 在Intellij中的使用 Machine的安装 compose的安装 Docker的配置 首先学习什么东西都要用官网的东西 安装Docker的插件-看网上教程 看Docker插件的官网 hrer 学习英文。任何东西官网都用详细说明的 学习Docker 学习SpringBoot整合Docker 学习运维 下面开始Docker的学习 1.现在插件 2.看网址的教程 3.安装machin和compose machine和compose的安装参考 1.Gitbook书 https://yeasy.gitbooks.io/docker_practice/content/compose/install.html 2。官方文档（为主） https://docs.docker.com/machine/install-machine/ ⭐️ （为什么每次都要重新下载dockermachine） Docker-machine env 不能执行二进制文件 首先要 重新下载Dockermachihe 123base=https://github.com/docker/machine/releases/download/v0.14.0 &amp;&amp; curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/usr/local/bin/docker-machine &amp;&amp; chmod +x /usr/local/bin/docker-machine 3.Github https://github.com/docker/machine/releases https://github.com/docker/machine 2.有些东西放在了云收藏里面Docker的用户名是2018112#####安装Docker插件要开VPN 还有访问Gitbub也要开VPN wiredes的 安装Docker要安装DookerToolBox 3.Docker ！！Docker真是一个恐怖的东西 ######Docker的学习资源GitBook里面的Docker的附录部分 https://blog.lab99.org/post/docker-2016-07-14-faq.html 1.无独有偶通过Docker-SpirngBoot的学习了解了TCP socker Engine API URL的填写 Docker开启远程访问这是过程中产生的问题 安装了socket 以后想办法删除 PS：Docker服务中进程间通信通过/var/run/docker.sock实现，默认服务不提供监听端口，因此使用docker remote api 需要手动绑定端口。方法： 12&gt; `# service docker stop``# docker -d -H unix:``///var/run/docker.sock -H tcp://0.0.0.0:2375`&gt; ###2.点击+号添加一个docker配置，输入Name和Engine API URL，URL是docker服务地址，需要docker开启远程连接功能。CentOS中在docker启动参数里添加如下配置即可开启远程连接。 -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 下面是docker在idea中的安装 clouds里面没有Docker。在Docker中配置 TCP：tcp：//127.0.0.1:2376 注意这个是通过终端命令得到的 1234567docker-machine env cloudcombexport DOCKER_TLS_VERIFY=&quot;1&quot;export DOCKER_HOST=&quot;tcp://192.168.99.101:2376&quot;export DOCKER_CERT_PATH=&quot;/Users/apple/.docker/machine/machines/cloudcomb&quot;export DOCKER_MACHINE_NAME=&quot;cloudcomb&quot;# Run this command to configure your shell:# eval $(docker-machine env cloudcomb) 将前面的端口换成本地的 tcp:127.0.0.1:2376 emm睡一觉起来VPN打开要等一会 在终端输入dockerversion docker-machine env—Host is not running #学习资源：通过Github的搜索功能🔍 发现一些学习资料https://www.jetbrains.com/help/idea/docker.html alip1sudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latest 1234567891011FROM java:8VOLUME /tmpsudo docker pull ccr.ccs.tencentyun.com/freemana2017/atcrod:latestCOPY target/tran4spd-1.0-SNAPSHOT.jar resource.jarRUN bash -c &quot;touch /resource.jar&quot;EXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;resource.jar&quot;]# docker run -d -p 18080:8099 --name docker-resource leesia/resource:1.0]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的使用教程]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2FHexo%2F</url>
    <content type="text"><![CDATA[主题copy一份在apple中不需要终端new 或者 标题title直接复制也是可以的有时候有延迟下面就是图片的问题啦 用图床ipic解决问题 https://www.jianshu.com/p/dbc945b05d55 PIC https://sspai.com/post/39965 少数派 ### https://hexo.io/zh-cn/docs/front-matter 学习Hexo按照这个网站里面有教程 学习任何东西都要使用官方文档 其余学习的东西在safair收藏➕随笔 hexo里面 真的好累 搭建这个环境 总之就是照着官网的例子 然后使用这个模版 然后yml文件要写全 坑太多了 能出一本书 先这样]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
